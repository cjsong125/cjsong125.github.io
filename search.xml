<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法题（数组篇）</title>
    <url>/algo-array/</url>
    <content><![CDATA[<h1>1、简介</h1>
<blockquote>
<p>分类刷算法题（语言：java）：</p>
<p>​	博主将陆续按分类顺序发布力扣算法题的解析与代码。部分代码参考力扣解析，仅供参考，如有疑问，评论探讨。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p><strong>数组篇：</strong></p>
<p>遇到不会的排序试试</p>
<p>正向走不通反向思考</p>
</blockquote>
<h1>2、例题推荐</h1>
<h2 id="2-1、数组的遍历">2.1、数组的遍历</h2>
<h3 id="485-最大连续-1-的个数">485. 最大连续 1 的个数</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20210830193615584.png" alt="image-20210830193615584"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums..length;  <span class="comment">//数组长度</span></span><br><span class="line">        <span class="keyword">int</span> cur_num = <span class="number">0</span>;  <span class="comment">//当前1的数量</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;  <span class="comment">//最大连续1的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  <span class="comment">//循环遍历数组元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;  <span class="comment">//当前元素为0时，将当前记录1的数量设为0</span></span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">//当前元素为1的情况</span></span><br><span class="line">                index++; </span><br><span class="line">                <span class="keyword">if</span> (index &gt; max)&#123;  <span class="comment">//每次都与最大值比较，当前1的数量大于max，就赋值给max</span></span><br><span class="line">                    max = index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210831150555050.png" alt="image-20210831150555050"></p>
<h3 id="495-提莫攻击">495.提莫攻击</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20210831150232735.png" alt="image-20210831150232735"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> poisoning_time = <span class="number">0</span>;  <span class="comment">//中毒时间</span></span><br><span class="line">        <span class="keyword">if</span> (timeSeries..length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> duration;  <span class="comment">//如果数组只有一个数据，相当于攻击一次，就直接返回持续时间即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; timeSeries..length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == timeSeries..length-<span class="number">1</span>) &#123;</span><br><span class="line">                poisoning_time += duration;  <span class="comment">//最后一次攻击，直接把中毒时间加上持续时间</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (timeSeries[i+<span class="number">1</span>] - timeSeries[i] &gt;= duration)&#123;  <span class="comment">//两次攻击时间大于持续时间</span></span><br><span class="line">                	poisoning_time += duration;</span><br><span class="line">            	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                	poisoning_time += timeSeries[i+<span class="number">1</span>] - timeSeries[i];  <span class="comment">//两次攻击时间小于持续时间，直接加上时间差</span></span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> poisoning_time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210831150324274.png" alt="image-20210831150324274"></p>
<h3 id="414-第三大的数">414.第三大的数</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20210831214906271.png" alt="image-20210831214906271"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len  = nums..length;  <span class="comment">//数组长度</span></span><br><span class="line">        <span class="keyword">long</span> first, second, third;</span><br><span class="line">        first = second = third = Long..MIN_VALUE;  <span class="comment">//定义前三的数字</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math..max(nums[<span class="number">0</span>], nums[len - <span class="number">1</span>]);  <span class="comment">//数组长度不足3，直接返回最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums..length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (cur == first || cur == second) &#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">//重复数值直接跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; first) &#123;  <span class="comment">//当前值大于最大值，重新给一二三赋值</span></span><br><span class="line">                third = second;</span><br><span class="line">                second = first;</span><br><span class="line">                first = cur;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; second) &#123;  <span class="comment">//当前值大于第二大的值，重新给二三赋值</span></span><br><span class="line">                third = second;</span><br><span class="line">                second = cur;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; third) &#123;  <span class="comment">//当前值大于第三大的值，重新给三赋值</span></span><br><span class="line">                third = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> third == Long..MIN_VALUE ? (<span class="keyword">int</span>)first : (<span class="keyword">int</span>)third;  <span class="comment">//第三的值有改动就返回改动后的值，如果还是初始化的MIN_VALUE就返回最大值</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210831214956357.png" alt="image-20210831214956357"></p>
<h3 id="628-三个数的最大乘积">628.三个数的最大乘积</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20210901133222070.png" alt="image-20210901133222070"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays..sort(nums);</span><br><span class="line">        <span class="keyword">int</span> len = nums..length;</span><br><span class="line">        <span class="keyword">if</span> (nums[len-<span class="number">1</span>] * nums[len-<span class="number">2</span>] * nums[len-<span class="number">3</span>] &gt; nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[len-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[len-<span class="number">1</span>] * nums[len-<span class="number">2</span>] * nums[len-<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210901133310490.png" alt="image-20210901133310490"></p>
<h2 id="2-2、统计数组中的元素">2.2、统计数组中的元素</h2>
<h3 id="645-错误的集合">645.错误的集合</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20210902164136576.png" alt="image-20210902164136576"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums..length;</span><br><span class="line">        <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) cnts[x]++;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnts[i] == <span class="number">0</span>) ans[<span class="number">1</span>] = i;</span><br><span class="line">            <span class="keyword">if</span> (cnts[i] == <span class="number">2</span>) ans[<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210902164312092.png" alt="image-20210902164312092"></p>
<h3 id="697-数组的度">697.数组的度</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20210903143930144.png" alt="image-20210903143930144"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">50009</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums..length;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[N];  <span class="comment">//存放每个数字出现在的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] first = <span class="keyword">new</span> <span class="keyword">int</span>[N], last = <span class="keyword">new</span> <span class="keyword">int</span>[N];  <span class="comment">//记录每个数字的第一次出现的位置和最后出现的位置</span></span><br><span class="line">        Arrays..fill(first, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[i];</span><br><span class="line">            max = Math..max(max, ++cnt[t]);  <span class="comment">//遍历得到最大的度</span></span><br><span class="line">            <span class="keyword">if</span> (first[t] == -<span class="number">1</span>) first[t] = i;  <span class="comment">//记录第一次出现的位置</span></span><br><span class="line">            last[t] = i;  <span class="comment">//记录最后出现的位置；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer..MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt[t] == max) ans = Math..min(ans, last[t] - first[t] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210903144025429.png" alt="image-20210903144025429"></p>
<h3 id="448-找到所有数组中消失的数字">448.找到所有数组中消失的数字</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20210904155753264.png" alt="image-20210904155753264"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组记录法，需要额外数组记录数值是否出现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums..length;</span><br><span class="line">        <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];  <span class="comment">//建立数组记录数值的出现</span></span><br><span class="line">        Arrays..fill(cnts, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) cnts[n]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cnts[i] == <span class="number">0</span>) result..add(i);  <span class="comment">//cnts[i]==0说明没有出现当前数值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210904155720339.png" alt="image-20210904155720339"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希记录，在原数组进行记录，不实用额外空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenn = nums..length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (num - <span class="number">1</span>) % len;  <span class="comment">// 原数组坐标是0-(len-1)，所以需要num-1；对数组长度取余</span></span><br><span class="line">            nums[x] += len;  <span class="comment">//加上数组长度后，所有出现过的数值的索引都会大于len</span></span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= len) &#123;  <span class="comment">//小于len就说明该数值没有出现过，添加到ans</span></span><br><span class="line">                ret..add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210904163646180.png" alt="image-20210904163646180"></p>
<h3 id="442-数组中重复的数据">442.数组中重复的数据</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20210905191936088.png" alt="image-20210905191936088"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序后前后数值对比，重复的加入到结果中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays..sort(nums);  <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums..length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) result..add(nums[i]);  <span class="comment">//对比，前后数值相同就加入到结果中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210905192118065.png" alt="image-20210905192118065"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希标记</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums..length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = (x - <span class="number">1</span>) % len;  <span class="comment">//数组坐标是0-（len-1），所以减一除以长度就是该数值的索引</span></span><br><span class="line">            nums[y] += len;  <span class="comment">//数值索引位置的值加上数组长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">2</span> * len) result..add(i + <span class="number">1</span>);  <span class="comment">//如果数值出现两次，在上方就会加上了两次len，</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210905192011000.png" alt="image-20210905192011000"></p>
<h3 id="41-缺失的第一个正数">41.缺失的第一个正数</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20210907153657454.png" alt="image-20210907153657454"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*哈希表记录（参考力扣官方解析，来源：力扣（LeetCode））</span></span><br><span class="line"><span class="comment">	对于一个长度为N的数组，其中没有出现的最小正整数只能在[1,N+1] 中。这是因为如果[1,N] 都出现了，那么答案是N+1，否则答案是[1,N] 中没有出现的最小正整数。</span></span><br><span class="line"><span class="comment">	所以我们先将负数都设置为大于数组长度len的数，再将数值小于等于len的数的索引位置取负数，这样就可以再次遍历数组，第一个出现正数的数组下标加1就是最终结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums..length;</span><br><span class="line">        <span class="comment">// 将负数都取大于len的数，我们取len+1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = len + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将小于等于len的元素对应的位置变为负数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = Math..abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= len) &#123;</span><br><span class="line">                nums[num - <span class="number">1</span>] = -Math..abs(nums[num - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回第一个大于0的元素下标+1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210907153834803.png" alt="image-20210907153834803"></p>
<h3 id="274-H指数">274.H指数</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20210908141157229.png" alt="image-20210908141157229"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*排序法</span></span><br><span class="line"><span class="comment">	将数组排序，并从大到小遍历，最初将h设为0，每次遍历的值大于h，就将h+1，直到h无法再增加。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        Arrays..sort(citations);</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = citations..length - <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; citations[i] &gt; h) &#123;</span><br><span class="line">            h++; </span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210908141454984.png" alt="image-20210908141454984"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*数组计数</span></span><br><span class="line"><span class="comment">	根据题目可知h是一个不大于论文篇数n的数；建立一个数组来记录每个h的论文篇数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = citations..length;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];  <span class="comment">//计数数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (citations[i] &gt;= n) &#123;  <span class="comment">//因为h不大于论文篇数n，大于总篇数n的全部放在count[n]中</span></span><br><span class="line">                counter[n]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counter[citations[i]]++;  <span class="comment">//记录每个h的论文篇数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">//从大到小遍历</span></span><br><span class="line">            total += counter[i];  <span class="comment">//大于或等于当前引用次数i的总论文数</span></span><br><span class="line">            <span class="keyword">if</span> (total &gt;= i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210908142010151.png" alt="image-20210908142010151"></p>
<h2 id="2-3、数组的改变、移动">2.3、数组的改变、移动</h2>
<h3 id="453-最小操作次数使数组元素相等">453.最小操作次数使数组元素相等</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20210909162000724.png" alt="image-20210909162000724"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*排序法</span></span><br><span class="line"><span class="comment">	思路：本题正向思路是每次给n-1个元素+1，最少几次使得数组元素全部相等。我们可以反向思考一下，其实就是将最大的元素-1然后所有元素+1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays..sort(nums);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums..length; i++) &#123;</span><br><span class="line">            res += nums[i] - nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210909162037605.png" alt="image-20210909162037605"></p>
<h3 id="283-移动零">283.移动零</h3>
<p><img src="/algo-array/image-20210924143623905.png" alt="image-20210924143623905"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums..length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;  <span class="comment">// 记录0的个数</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i - count] = nums[i];  <span class="comment">// 将非0数字往前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[len - count] = <span class="number">0</span>;  <span class="comment">// 后面补0</span></span><br><span class="line">            count --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210924143743347.png" alt="image-20210924143743347"></p>
<h2 id="2-4、二维数组及滚动数组">2.4、二维数组及滚动数组</h2>
<h3 id="118-杨辉三角">118.杨辉三角</h3>
<p><img src="/algo-array/image-20210924145516923.png" alt="image-20210924145516923"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;  <span class="comment">// 前后添加1</span></span><br><span class="line">                    row..add(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    row..add(ret..get(i - <span class="number">1</span>)..get(j - <span class="number">1</span>) + ret..get(i - <span class="number">1</span>)..get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret..add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210924145648020.png" alt="image-20210924145648020"></p>
<h3 id="119-杨辉三角II">119.杨辉三角II</h3>
<p><img src="/algo-array/image-20210924150107217.png" alt="image-20210924150107217"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; C = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    row..add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    row..add(C..get(i - <span class="number">1</span>)..get(j - <span class="number">1</span>) + C..get(i - <span class="number">1</span>)..get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            C..add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> C..get(rowIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210924150203187.png" alt="image-20210924150203187"></p>
<h3 id="598-范围求和II">598.范围求和II</h3>
<p><img src="/algo-array/image-20210925141511488.png" alt="image-20210925141511488"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 本题可以用暴力解法，但是复杂度比较大</span></span><br><span class="line"><span class="comment">* 据题意，每次增加1都是从数组[0][0]开始，所以会有交集，最大整数肯定出现在数值[0][0]的这个交集中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] op: ops) &#123;</span><br><span class="line">            m = Math..min(m, op[<span class="number">0</span>]);</span><br><span class="line">            n = Math..min(n, op[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20210925142530640.png" alt="image-20210925142530640"></p>
<h2 id="2-5、数组的旋转">2.5、数组的旋转</h2>
<h3 id="189-旋转数组">189.旋转数组</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20211008113105216.png" alt="image-20211008113105216"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接暴力解法（超时），直接一个一个的移动</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums..length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[len-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = len-<span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[<span class="number">0</span>] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组反转（参考力扣官方解析）</span></span><br><span class="line"><span class="comment">// 基本步骤：先将数组整体翻转，在分别翻转前后两个部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums..length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums..length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums..length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">            end -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>原始数组</td>
<td>1 2 3 4 5 6 7</td>
</tr>
<tr>
<td>翻转所有元素</td>
<td>7 6 5 4 3 2 1</td>
</tr>
<tr>
<td>翻转[0, k mod n-1]区间的元素</td>
<td>5 6 7 4 3 2 1</td>
</tr>
<tr>
<td>翻转[k mod n, n-1]区间的元素</td>
<td>5 6 7 1 2 3 4</td>
</tr>
</tbody>
</table>
<h3 id="396-旋转函数">396.旋转函数</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20211009110251883.png" alt="image-20211009110251883"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在上一题的基础上修改(超时)，每一翻转一个数，计算总和比大小。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxRotateFunction</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums..length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums..length; i++) &#123;</span><br><span class="line">            max += i * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums..length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            reverse(nums, <span class="number">0</span>, nums..length - <span class="number">1</span>);</span><br><span class="line">            reverse(nums, <span class="number">1</span>, nums..length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums..length; j++) &#123;</span><br><span class="line">                sum += j * nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; max) max = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">            end -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：错位相减法</p>
<p>（作者：yixingzhang 链接：<a href="https://leetcode-cn.com/problems/rotate-function/solution/qian-lu-qi-qu-wang-wo-men-ke-yi-hu-xiang-iqax/">https://leetcode-cn.com/problems/rotate-function/solution/qian-lu-qi-qu-wang-wo-men-ke-yi-hu-xiang-iqax/</a>](<a href="https://leetcode-cn.com/u/yixingzhang/">https://leetcode-cn.com/u/yixingzhang/</a>)）</p>
<p>$$<br>
F(k) = 0 * A[0] + 1 * A[1] + … + (n-1) * A[n-1] \<br>
F(k+1) = 0 * A[n-1] + 1 * A[0] + 2 * A[1] + … + (n-1) * A[n-2] \<br>
F(k+1) - F(k) = -(n-1) * A[n-1] + 1 * A[0] + 1 * A[1] + … + 1 * A[n-2] \<br>
F(k+1) = F(k) - n * A[n-1] + 所有数的和 \<br>
F(k+i) = F(k+i-1) - n * A[n-i] + 所有数的和<br>
$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用到了数学的错位相减，可能不一定能想到</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxRotateFunction</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums..length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 统计数组所有数的和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算 F(0) 的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            max += count++ * i;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录上一个计算结果</span></span><br><span class="line">        <span class="keyword">int</span> tmp = max;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 利用等差数列求解</span></span><br><span class="line">            tmp = tmp + sum - n * nums[n - i];</span><br><span class="line">            <span class="keyword">if</span> (max &lt; tmp) &#123;</span><br><span class="line">                max = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20211010095254289.png" alt="image-20211010095254289"></p>
<h2 id="2-6、特定顺序遍历二维数组">2.6、特定顺序遍历二维数组</h2>
<h3 id="54-螺旋矩阵">54.螺旋矩阵</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20211021125924036.png" alt="image-20211021125924036"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路（参考力扣）：</span></span><br><span class="line"><span class="comment">	本题的数组循环不再是简单的双重选好就可以解决。可以看到仔细观察，这个循环的一个周期是什么，起止分别是什么：</span></span><br><span class="line"><span class="comment">	左上——》右上——》右下——》左下——》左上——》（第二个循环的左上）D:\Learning\PersonalBlog\CodeChenBlog\source/algo-arrayD:\Learning\PersonalBlog\CodeChenBlog\source/algo-arrayD:\Learning\PersonalBlog\CodeChenBlog\source/algo-array..</span></span><br><span class="line"><span class="comment">	这是一个完整的循环，所以依照这个思路写算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> rows = matrix..length, columns = matrix[<span class="number">0</span>]..length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = columns - <span class="number">1</span>, top = <span class="number">0</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix..length == <span class="number">0</span> || matrix[<span class="number">0</span>]..length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="comment">// 左上——》右上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> column = left; column &lt;= right; column++)&#123;</span><br><span class="line">                res..add(matrix[top][column]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右上——》右下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row = top + <span class="number">1</span>; row &lt;= bottom; row++)&#123;</span><br><span class="line">                res..add(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                <span class="comment">// 右下——》左下</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> column = right - <span class="number">1</span>; column &gt;= left; column--) &#123;</span><br><span class="line">                    res..add(matrix[bottom][column]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左下——》左上</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> row = bottom - <span class="number">1</span>; row &gt; top; row--) &#123;</span><br><span class="line">                    res..add(matrix[row][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 四个边界都向中间收拢</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/C:%5CUsers%5C86158%5CDesktop%5C%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211021124843.png" alt="微信图片_20211021124843"></p>
<h3 id="59-螺旋矩阵II">59.螺旋矩阵II</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20211023135855902.png" alt="image-20211023135855902"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这个题和上一个题其实是一样的，上一个题给了一个二维数组，需要螺旋给出相应结果；本题需要自己螺旋的建立一个数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, top = <span class="number">0</span>, bottom = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = left; column &lt;= right; column++) &#123;</span><br><span class="line">                matrix[top][column] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> row = top + <span class="number">1</span>; row &lt;= bottom; row++) &#123;</span><br><span class="line">                matrix[row][right] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> column = right -<span class="number">1</span>; column &gt;= left; column--) &#123;</span><br><span class="line">                    matrix[bottom][column] = num;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> row = bottom - <span class="number">1</span>; row &gt; top; row--) &#123;</span><br><span class="line">                    matrix[row][left] = num;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20211023112532355.png" alt="image-20211023112532355"></p>
<h3 id="498-对角线遍历">498.对角线遍历</h3>
<p>题目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">（参考力扣官方解析）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findDiagonalOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix..length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> N = matrix..length;</span><br><span class="line">        <span class="keyword">int</span> M = matrix[<span class="number">0</span>]..length;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定标志位来确定对角线走向，向上走还是向下走</span></span><br><span class="line">        <span class="keyword">int</span> direction = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[N*M];</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (row &lt; N &amp;&amp; column &lt; M) &#123;</span><br><span class="line">            </span><br><span class="line">            result[r++] = matrix[row][column];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过判断对角线走向来给row和column进行加或减</span></span><br><span class="line">            <span class="keyword">int</span> new_row = row + (direction == <span class="number">1</span> ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> new_column = column + (direction == <span class="number">1</span> ? <span class="number">1</span> : -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否是对角线走向最后一个元素 </span></span><br><span class="line">            <span class="keyword">if</span> (new_row &lt; <span class="number">0</span> || new_row == N || new_column &lt; <span class="number">0</span> || new_column == M) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (direction == <span class="number">1</span>) &#123;</span><br><span class="line">                    row += (column == M - <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>) ;</span><br><span class="line">                    column += (column &lt; M - <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    column += (row == N - <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                    row += (row &lt; N - <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 转向</span></span><br><span class="line">                direction = <span class="number">1</span> - direction;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                row = new_row;</span><br><span class="line">                column = new_column;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20211023223126569.png" alt="image-20211023223126569"></p>
<h2 id="2-7、二维数组变换">2.7、二维数组变换</h2>
<h3 id="566-重塑矩阵">566.重塑矩阵</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20211024111542427.png" alt="image-20211024111542427"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解法一：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> M = mat..length;</span><br><span class="line">        <span class="keyword">int</span> N = mat[<span class="number">0</span>]..length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出不合理，返回原数组</span></span><br><span class="line">        <span class="keyword">if</span> (M * N != r * c) &#123;</span><br><span class="line">            <span class="keyword">return</span> mat;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建结果数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="comment">// 控制结果数组的换行，当col到最后一列时就换行，将row+1换行，col置0，重新从第一列第row+1行开始存数据</span></span><br><span class="line">                <span class="keyword">if</span> (col == c) &#123;</span><br><span class="line">                    row += <span class="number">1</span>;</span><br><span class="line">                    col = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res[row][col] = mat[i][j];</span><br><span class="line">                col += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20211024111509427.png" alt="image-20211024111509427"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解法二(力扣官方解析):主要就是在存储数据时用了数学的除和取余，可能一般不一定能想到，思想和解法一是类似的，都是以列为基准来控制换行，取余就是列在递增，除整就是控制换行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat..length;</span><br><span class="line">        <span class="keyword">int</span> n = mat[<span class="number">0</span>]..length;</span><br><span class="line">        <span class="keyword">if</span> (m * n != r * c) &#123;</span><br><span class="line">            <span class="keyword">return</span> mat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m * n; ++x) &#123;</span><br><span class="line">            ans[x / c][x % c] = mat[x / n][x % n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20211024112152336.png" alt="image-20211024112152336"></p>
<h3 id="48-旋转图像">48.旋转图像</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20211025111528637.png" alt="image-20211025111528637"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参考力扣官方解析</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix..length;</span><br><span class="line">        <span class="comment">// 水平翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - i - <span class="number">1</span>][j];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20211025111659404.png" alt="image-20211025111659404"></p>
<h3 id="73-矩阵置零">73.矩阵置零</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20211028100343736.png" alt="image-20211028100343736"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参考：</span></span><br><span class="line"><span class="comment">作者：powcai</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn..com/problems/set-matrix-zeroes/solution/o1kong-jian-by-powcai/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这么版本较好理解</span></span><br><span class="line"><span class="comment">解析：主要需要想到将第一行和第一列作为标志位，最后的置零就通过第一行和第一列来判断是否置零。</span></span><br><span class="line"><span class="comment">	1、设置两个标志记录第一行和第一列是否存在0</span></span><br><span class="line"><span class="comment">	2、遍历除第一行和第一列元素，如果是0就将对应的第一行和第一列元素置零</span></span><br><span class="line"><span class="comment">	3、最后通过第一行和第一列为0的对应行和列置零</span></span><br><span class="line"><span class="comment">	4、第一步的两个标志如果是第一行和第一列原始数据就存在0，就需要将第一行或（和）第一列置零</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix..length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>]..length;</span><br><span class="line">        <span class="keyword">boolean</span> row0_flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> col0_flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 第一行是否有零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                row0_flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一列是否有零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                col0_flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把第一行第一列作为标志位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row0_flag) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (col0_flag) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20211026111942252.png" alt="image-20211026111942252"></p>
<h2 id="2-8、前缀和数组">2.8、前缀和数组</h2>
<h3 id="303-区域和检索-数据不可变">303.区域和检索-数据不可变</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20211028100658628.png" alt="image-20211028100658628"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解析：主要在数据处理时就将每一个数的前缀和求出，并存储起来，最后简单计算返回结果即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums..length;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[right + <span class="number">1</span>] - sums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20211028100843776.png" alt="image-20211028100843776"></p>
<h3 id="304-二维区域和检索-矩阵不可变">304.二维区域和检索 - 矩阵不可变</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20211028101439324.png" alt="image-20211028101439324"></p>
<p><img src="/algo-array/1614646585-JOesrN-304.002.jpeg" alt="1614646585-JOesrN-304.002.jpeg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解析：本题思路和上一题一样，需要处理数据，存储所有的前缀和，但是二维数据计算前缀和会复杂一点。需要将整体和一些局部相加减。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] sums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix..length;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = matrix[<span class="number">0</span>]..length;</span><br><span class="line">            sums = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="comment">// 当前格子的和 = 上方的格子的和 + 左边的格子的和的 - 左上角的格子的和 + 当前格子的值[和是指对应的前缀和，值是指原数组中的值]</span></span><br><span class="line">                    sums[i + <span class="number">1</span>][j + <span class="number">1</span>] = sums[i][j + <span class="number">1</span>] + sums[i + <span class="number">1</span>][j] - sums[i][j] + matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - sums[row1][col2 + <span class="number">1</span>] - sums[row2 + <span class="number">1</span>][col1] + sums[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20211028101712061.png" alt="image-20211028101712061"></p>
<h3 id="238-除自身意外数组的乘积">238.除自身意外数组的乘积</h3>
<p>题目：</p>
<p><img src="/algo-array/image-20211028141727060.png" alt="image-20211028141727060"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn..com/problems/product-of-array-except-self/solution/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解析：简单的使用双重循环求结果会超时，所以需要优化。</span></span><br><span class="line"><span class="comment">为了减少计算次数，我们需要将每次计算结果存储，每次就只需要乘一次。</span></span><br><span class="line"><span class="comment">建立一个数组answer，存结果。首先从左遍历原数据，将左边的数据相乘存储在answer中，从而得到所有的左边乘积。</span></span><br><span class="line"><span class="comment">再在answer中从右边开始遍历，设定一个变量存储右边的乘积，每次将右边的乘积乘以左边的乘积answer[i]，最后得到的answer就是结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums..length;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 因为索引为 &#x27;0&#x27; 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/algo-array/image-20211028142110706.png" alt="image-20211028142110706"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的*args和**kwargs</title>
    <url>/pyArgsKwargs/</url>
    <content><![CDATA[<h1 id="args和-kwargs"><a href="#args和-kwargs" class="headerlink" title="*args和**kwargs"></a>*args和**kwargs</h1><p><code>*args</code> 和 <code>**kwargs</code> 主要用于函数定义。 你可以将不定数量的参数传递给一个函数。</p>
<p>这里的不定的意思是：预先并不知道, 函数使用者会传递多少个参数给你, 所以在这个场景下使用这两个关键字。</p>
<span id="more"></span>

<ul>
<li><p><code>*args</code> 是用来发送一个非键值对的可变数量的参数列表给一个函数.</p>
<p>这里有个例子帮你理解这个概念:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def test_var_args(f_arg, *argv):</span><br><span class="line">    print(&quot;first normal arg:&quot;, f_arg)</span><br><span class="line">    for arg in argv:</span><br><span class="line">        print(&quot;another arg through *argv:&quot;, arg)</span><br><span class="line"></span><br><span class="line">test_var_args(&#x27;yasoob&#x27;, &#x27;python&#x27;, &#x27;eggs&#x27;, &#x27;test&#x27;)</span><br></pre></td></tr></table></figure>

<p>这会产生如下输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">first normal arg: yasoob</span><br><span class="line">another arg through *argv: python</span><br><span class="line">another arg through *argv: eggs</span><br><span class="line">another arg through *argv: test</span><br></pre></td></tr></table></figure>



<ul>
<li><p><code>**kwargs</code> 允许你将不定长度的<strong>键值对</strong>, 作为参数传递给一个函数。 如果你想要在一个函数里处理<strong>带名字的参数</strong>, 你应该使用<code>**kwargs</code>。</p>
<p>这里有个让你上手的例子:</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_me</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;0&#125; == &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(key, value))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>greet_me(name=<span class="string">&quot;yasoob&quot;</span>)</span><br><span class="line">name == yasoob</span><br></pre></td></tr></table></figure>

<p>现在你可以看出我们怎样在一个函数里, 处理了一个<strong>键值对</strong>参数了。</p>
<p>这就是<code>**kwargs</code>的基础, 而且你可以看出它有多么管用。 接下来让我们谈谈，你怎样使用<code>*args</code> 和 <code>**kwargs</code>来调用一个参数为列表或者字典的函数。</p>
<ul>
<li><p>使用*args和**kwargs来调用函数</p>
<p>那现在我们将看到怎样使用<code>*args</code>和<code>**kwargs</code> 来调用一个函数。 假设，你有这样一个小函数：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_args_kwargs</span>(<span class="params">arg1, arg2, arg3</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;arg1:&quot;</span>, arg1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;arg2:&quot;</span>, arg2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;arg3:&quot;</span>, arg3)</span><br></pre></td></tr></table></figure>

<p>你可以使用<code>*args</code>或<code>**kwargs</code>来给这个小函数传递参数。 下面是怎样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先使用 *args</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="string">&quot;two&quot;</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_args_kwargs(*args)</span><br><span class="line">arg1: two</span><br><span class="line">arg2: <span class="number">3</span></span><br><span class="line">arg3: <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在使用 **kwargs:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwargs = &#123;<span class="string">&quot;arg3&quot;</span>: <span class="number">3</span>, <span class="string">&quot;arg2&quot;</span>: <span class="string">&quot;two&quot;</span>, <span class="string">&quot;arg1&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_args_kwargs(**kwargs)</span><br><span class="line">arg1: <span class="number">5</span></span><br><span class="line">arg2: two</span><br><span class="line">arg3: <span class="number">3</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>标准参数与<code>*args、**kwargs</code>在使用时的顺序</p>
<p>那么如果你想在函数里同时使用所有这三种参数， 顺序是这样的：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_func(fargs, *args, **kwargs)</span><br></pre></td></tr></table></figure>



<ul>
<li><p>何时使用？</p>
<p>这需要根据需求而定。最常见的用例是在写函数装饰器的时候。</p>
<p>此外它也可以用来做猴子补丁(monkey patching)。猴子补丁的意思是在程序运行时(runtime)修改某些代码。 打个比方，你有一个类，里面有个叫<code>get_info</code>的函数会调用一个API并返回相应的数据。如果我们想测试它，可以把API调用替换成一些测试数据。例如：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> someclass</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_info</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Test data&quot;</span></span><br><span class="line"></span><br><span class="line">someclass.get_info = get_info</span><br></pre></td></tr></table></figure>



<p>文章内容来自：<a href="https://docs.pythontab.com/interpy/args_kwargs/When_to_use/">https://docs.pythontab.com/interpy/args_kwargs/When_to_use/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode精选TOP面试题——简单篇</title>
    <url>/algo-interviewTop-easy/</url>
    <content><![CDATA[<h1 id="LeetCode-精选-TOP-面试题——简单篇"><a href="#LeetCode-精选-TOP-面试题——简单篇" class="headerlink" title="LeetCode 精选 TOP 面试题——简单篇"></a>LeetCode 精选 TOP 面试题——简单篇</h1><p>TOP 面试题简单篇，以下解析为Python语言。</p>
<span id="more"></span>

<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><p>题目：</p>
<p><img src="/algo-interviewTop-easy/1-1.jpg"></p>
<p>解析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 建立一个哈希表</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h1><p>题目：</p>
<p><img src="/algo-interviewTop-easy/13-1.jpg"></p>
<p>解析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        Roman2Int = &#123;<span class="string">&#x27;I&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;V&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;X&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;L&#x27;</span>:<span class="number">50</span>,<span class="string">&#x27;C&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>,<span class="string">&#x27;M&#x27;</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        Int = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> Roman2Int[s[index]] &lt; Roman2Int[s[index + <span class="number">1</span>]]:</span><br><span class="line">                Int -= Roman2Int[s[index]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Int += Roman2Int[s[index]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Int + Roman2Int[s[-<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h1><p>题目：</p>
<p><img src="/algo-interviewTop-easy/14-1.jpg"></p>
<p>解析:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 求出所有字符串中最短的字符串长度</span></span><br><span class="line">        str_len = <span class="built_in">len</span>(strs[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">str</span>) &lt; str_len:</span><br><span class="line">                str_len = <span class="built_in">len</span>(<span class="built_in">str</span>)</span><br><span class="line">		</span><br><span class="line">        <span class="comment"># 字符串中一个一个字符比较</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(str_len):</span><br><span class="line">            c = strs[<span class="number">0</span>][i]</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> strs:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">str</span>[i] != c:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">            res += c</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络体系结构</title>
    <url>/net-hierarchicalDivision/</url>
    <content><![CDATA[<ul>
<li><p>常见的计算机网络体系结构</p>
<span id="more"></span></li>
</ul>
<p><img src="/net-hierarchicalDivision/image-20211222215636759.png"></p>
<blockquote>
<ul>
<li>物理层：<strong>该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。</strong>物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。</li>
<li>数据链路层：该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。基本数据单位为帧。主要的协议为以太网协议。两个重要的设备名称为网桥和交换机。</li>
<li>网络层：具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。</li>
<li>传输层：传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；重要设备：网关。</li>
<li>会话层：会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</li>
<li>表示层：表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</li>
<li>应用层：为操作系统或网络应用程序提供访问网络服务的接口。</li>
</ul>
<p>会话层、表示层和应用层重点：</p>
<ul>
<li>1&gt; 数据传输基本单位为报文；</li>
<li>2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</li>
</ul>
</blockquote>
<p><img src="/net-hierarchicalDivision/image-20211222221854834.png"></p>
<p>数据传输过程，详情看：<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=9&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1c4411d7jb?p=9&amp;spm_id_from=pageDriver</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门</title>
    <url>/docker-base/</url>
    <content><![CDATA[<p>Docker可以理解为自带环境的软件系统</p>
<span id="more"></span>

<h1 id="比较Docker和虚拟机技术的不同"><a href="#比较Docker和虚拟机技术的不同" class="headerlink" title="比较Docker和虚拟机技术的不同"></a>比较Docker和虚拟机技术的不同</h1><ul>
<li>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li>
<li>容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</li>
<li>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响</li>
</ul>
<blockquote>
<p>DevOps（开发、运维）</p>
</blockquote>
<p><strong>应用更快速的交付和部署</strong></p>
<p>传统：一堆帮助文档，安装程序</p>
<p>Docker：打包镜像发布测试，一键运行</p>
<p><strong>更便捷的升级和扩缩容</strong></p>
<p>使用了Docker之后，我们部署应用就和搭积木一样！</p>
<p>项目打包为一个镜像，扩展服务器时直接运行镜像即可</p>
<p><strong>更简单的系统运维</strong></p>
<p>在容器化之后，我们的开发，测试环境都是高度一致的</p>
<p><strong>更高效的计算资源利用</strong></p>
<p>Docker是内核级别的虚拟化，可以在一个物理机上运行很多容器实例，服务器的性能可以被压榨到极致</p>
<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><p><img src="/./docker-base/1.jpg"></p>
<p><strong>镜像（image）：</strong></p>
<p>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，Tomcat镜像==》run==》Tomcat01容器（提供服务器）</p>
<p><strong>容器（container）：</strong></p>
<p>docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的。</p>
<p>启动，停止，删除，基本命令</p>
<p>目前就可以把这个容器理解为就是一个简易的Linux系统</p>
<p><strong>仓库（repository）：</strong></p>
<p>仓库就是存放镜像的地方</p>
<p>仓库分为公有仓库和私有仓库</p>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><blockquote>
<p>安装</p>
</blockquote>
<p>帮助文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、卸载旧的版本</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">                  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、需要的安装包</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、设置镜像的仓库</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo #默认的国外的</span><br><span class="line">    </span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \ </span><br><span class="line">	http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #换成阿里云的</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新yum</span></span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、安装Docker相关东西 docker-ce社区版 ee企业版</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、启动Docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6、测试运行hello world</span></span><br><span class="line">sudo docker run hello-world</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最初是没有hello-world镜像的，运行命令后会自动下载</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7、查看下载的镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="/./docker-base/2.jpg"></p>
<h2 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">![3](D:\Learning\PersonalBlog\CodeChenBlog\source\_posts\docker-base\3.jpg)# 1、卸载依赖</span><br><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、删除资源</span></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /var/lib/docker  docker的默认工作路径</span></span><br></pre></td></tr></table></figure>



<h2 id="回顾helloworld流程"><a href="#回顾helloworld流程" class="headerlink" title="回顾helloworld流程"></a>回顾helloworld流程</h2><p><img src="/./docker-base/3.jpg"></p>
<h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p><strong>Docker是怎么工作的？</strong></p>
<p>Docker是一个client-server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问</p>
<p>DockerServer接受到Docker-client的指令，就会执行这个命令</p>
<p><img src="/./docker-base/4.jpg"></p>
<p><strong>Docker为什么比虚拟机（VM）快？</strong></p>
<ol>
<li><p>Docker有着比虚拟机更少的抽象层</p>
</li>
<li><p>Docker利用的是宿主机的内核，vm需要是Guest os</p>
<p><img src="/./docker-base/5.jpg"></p>
</li>
</ol>
<p>所以，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest os，分钟级别的，而docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级的。</p>
<h1 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version     # 显示docker的版本信息</span><br><span class="line">docher info 	   # 显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker 命令 --help  # 帮助命令</span><br></pre></td></tr></table></figure>

<p>帮助文档的地址：<a href="https://docs.docker.com/engine/reference/commandline/">https://docs.docker.com/engine/reference/commandline/</a></p>
<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p>docker images 查看本地的主机上所有镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   3 months ago   13.3kB</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解析</span></span><br><span class="line">REPOSITORY  镜像的仓库源</span><br><span class="line">TAG         镜像的标签</span><br><span class="line">IMAGE ID    镜像的id</span><br><span class="line">CREATED     镜像的创建时间</span><br><span class="line">SIZE        镜像的大小</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项</span></span><br><span class="line">-a， --all   列出所有的镜像</span><br><span class="line">-q， --quiet 只显示镜像的id</span><br></pre></td></tr></table></figure>

<p><strong>docker search搜索镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   11920     [OK]       </span><br><span class="line">mariadb                           MariaDB Server is a high performing open sou…   4559      [OK]       </span><br><span class="line">mysql/mysql-server                Optimized MySQL Server Docker images. Create…   895                  [OK]</span><br><span class="line">percona                           Percona Server is a fork of the MySQL relati…   567       [OK]       </span><br><span class="line">phpmyadmin                        phpMyAdmin - A web interface for MySQL and M…   415       [OK]       </span><br><span class="line">centos/mysql-57-centos7           MySQL 5.7 SQL database server                   92                   </span><br><span class="line">mysql/mysql-cluster               Experimental MySQL Cluster Docker images. Cr…   90                   </span><br><span class="line">centurylink/mysql                 Image containing mysql. Optimized to be link…   59                   [OK]</span><br><span class="line">databack/mysql-backup             Back up mysql databases to... anywhere!         54                   </span><br><span class="line">prom/mysqld-exporter                                                              46                   [OK]</span><br><span class="line">deitch/mysql-backup               REPLACED! Please use http://hub.docker.com/r…   41                   [OK]</span><br><span class="line">tutum/mysql                       Base docker image to run a MySQL database se…   35                   </span><br><span class="line">linuxserver/mysql                 A Mysql container, brought to you by LinuxSe…   34                   </span><br><span class="line">schickling/mysql-backup-s3        Backup MySQL to S3 (supports periodic backup…   31                   [OK]</span><br><span class="line">mysql/mysql-router                MySQL Router provides transparent routing be…   23                   </span><br><span class="line">centos/mysql-56-centos7           MySQL 5.6 SQL database server                   21                   </span><br><span class="line">arey/mysql-client                 Run a MySQL client from a docker container      20                   [OK]</span><br><span class="line">fradelg/mysql-cron-backup         MySQL/MariaDB database backup using cron tas…   18                   [OK]</span><br><span class="line">genschsa/mysql-employees          MySQL Employee Sample Database                  9                    [OK]</span><br><span class="line">openshift/mysql-55-centos7        DEPRECATED: A Centos7 based MySQL v5.5 image…   6                    </span><br><span class="line">ansibleplaybookbundle/mysql-apb   An APB which deploys RHSCL MySQL                3                    [OK]</span><br><span class="line">devilbox/mysql                    Retagged MySQL, MariaDB and PerconaDB offici…   3                    </span><br><span class="line">jelastic/mysql                    An image of the MySQL database server mainta…   2                    </span><br><span class="line">centos/mysql-80-centos7           MySQL 8.0 SQL database server                   2                    </span><br><span class="line">widdpim/mysql-client              Dockerized MySQL Client (5.7) including Curl…   1                    [OK]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项</span></span><br><span class="line">--filter=STARS=3000  # 搜索出来的镜像就是STARS大于3000的</span><br></pre></td></tr></table></figure>

<p><strong>docker pull 下载镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像 docker pull 镜像名[:tag]</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker pull mysql</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Pull complete </span><br><span class="line">93619dbc5b36: Pull complete </span><br><span class="line">99da31dd6142: Pull complete </span><br><span class="line">626033c43d70: Pull complete </span><br><span class="line">37d5d7efb64e: Pull complete </span><br><span class="line">ac563158d721: Pull complete </span><br><span class="line">d2ba16033dad: Pull complete </span><br><span class="line">688ba7d5c01a: Pull complete </span><br><span class="line">00e060b6d11d: Pull complete </span><br><span class="line">1c04857f594f: Pull complete </span><br><span class="line">4d7cfa90e6ea: Pull complete </span><br><span class="line">e0431212d27d: Pull complete </span><br><span class="line">Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等价</span></span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定版本下载</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Already exists </span><br><span class="line">93619dbc5b36: Already exists </span><br><span class="line">99da31dd6142: Already exists </span><br><span class="line">626033c43d70: Already exists </span><br><span class="line">37d5d7efb64e: Already exists </span><br><span class="line">ac563158d721: Already exists </span><br><span class="line">d2ba16033dad: Already exists </span><br><span class="line">0ceb82207cd7: Pull complete </span><br><span class="line">37f2405cae96: Pull complete </span><br><span class="line">e2482e017e53: Pull complete </span><br><span class="line">70deed891d42: Pull complete </span><br><span class="line">Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure>

<p><strong>docker rmi 删除镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos ~]# docker rmi -f 容器id  # 删除指定的容器</span><br><span class="line">[root@VM-24-12-centos ~]# docker rmi -f 容器id 容器id 容器id  # 删除多个容器</span><br><span class="line">[root@VM-24-12-centos ~]# docker rmi -f $(docker images -aq)  # 删除全部容器</span><br></pre></td></tr></table></figure>



<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>说明：有了镜像才可以创建容器</strong></p>
<p>下载centos镜像来测试学习</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>

<p><strong>新建容器并启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">--name=&quot;Name&quot;  # 容器名字，用来区分容器</span><br><span class="line">-d             # 后台方式运行</span><br><span class="line">-it            # 使用交互方式运行，进入容器查看内容</span><br><span class="line">-p             # 指定容器的端口 -p 8080:8080</span><br><span class="line">	-p ip：主机端口：容器端口</span><br><span class="line">	-p 主句端口：容器端口（常用）</span><br><span class="line">	-p 容器端口</span><br><span class="line">	容器端口</span><br><span class="line">-P              # 随机指定端口</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试，启动并进入容器</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@0e3aa4e3d192 /]# ls  # 查看容器内的centos，基础版本，很多命令都是不完整的</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从容器中退回主机</span></span><br><span class="line">[root@0e3aa4e3d192 /]# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p><strong>列出所有运行中的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker ps 命令</span></span><br><span class="line">    # 列出当前正在运行的容器</span><br><span class="line">-a  # 列出当前正在运行的容器+历史运行过的容器</span><br><span class="line">-n=？  # 显示最近创建的容器</span><br><span class="line">-q  # 只显示容器的编号</span><br><span class="line"></span><br><span class="line">[root@VM-24-12-centos ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@VM-24-12-centos ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND       CREATED         STATUS                      PORTS     NAMES</span><br><span class="line">0e3aa4e3d192   centos        &quot;/bin/bash&quot;   3 minutes ago   Exited (0) 53 seconds ago             practical_chaplygin</span><br><span class="line">385350d5ac9c   hello-world   &quot;/hello&quot;      26 hours ago    Exited (0) 26 hours ago               vigilant_galileo</span><br></pre></td></tr></table></figure>

<p><strong>退出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit  # 直接容器停止并退出</span><br><span class="line">ctrl+P+Q  # 容器不停止退出</span><br></pre></td></tr></table></figure>

<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器id  # 删除指定的容器</span><br><span class="line">docker rm -f $(docker ps -aq)  # 删除所有容器</span><br><span class="line">docker ps -a -q|xargs docker rm  # 删除所有容器</span><br></pre></td></tr></table></figure>

<p><strong>启动和停止容器的操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器id  # 启动容器</span><br><span class="line">docker restart 容器id  # 重启容器</span><br><span class="line">docker stop 容器id  # 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id  # 强制停止当前容器</span><br></pre></td></tr></table></figure>



<h2 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h2><p><strong>后台启动容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令docker run -d 镜像名</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker run -d centos</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 问题docker ps，发现centos停止了</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常见的坑：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Nginx，容器启动后，发现自己没有提供服务，就会立即停止，就是没有程序了</span></span><br></pre></td></tr></table></figure>

<p><strong>查看日志</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --tail 容器，没有日志</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自己写一段shell脚本</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker run -d centos /bin/sh -c &quot;while true;do echo cjsong;sleep 1;done&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">[root@VM-24-12-centos ~]<span class="comment"># docker ps</span></span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS        PORTS     NAMES</span><br><span class="line">0f3c557a8105   centos    &quot;/bin/sh -c &#x27;while t…&quot;   2 seconds ago   Up 1 second             nervous_colden</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示日志</span></span><br><span class="line">-tf  # 显示日志</span><br><span class="line">--tail number  # 显示日志的条数</span><br><span class="line">[root@VM-24-12-centos ~]# docker logs -tf --tail 10 0f3c557a8105</span><br></pre></td></tr></table></figure>

<p><strong>查看容器中的进程信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令 docker top 容器id</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker top 0f3c557a8105</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                30196               30177               0                   17:17               ?                   00:00:00            /bin/sh -c while true;do echo cjsong;sleep 1;done</span><br><span class="line">root                31689               30196               0                   17:23               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sl</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>查看镜像元数据</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令 docker inspect 容器id</span></span><br><span class="line"></span><br><span class="line">[root@VM-24-12-centos ~]# docker inspect 0f3c557a8105</span><br></pre></td></tr></table></figure>

<p><strong>进入当前正在运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker exex -it 容器id bashShell</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS     NAMES</span><br><span class="line">0f3c557a8105   centos    &quot;/bin/sh -c &#x27;while t…&quot;   3 hours ago   Up 3 hours             nervous_colden</span><br><span class="line">[root@VM-24-12-centos ~]# docker exec -it 0f3c557a8105 /bin/bash</span><br><span class="line">[root@0f3c557a8105 /]# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 09:17 ?        00:00:02 /bin/sh -c while true;do echo cjsong;sleep 1;done</span><br><span class="line">root      9802     0  0 12:01 pts/0    00:00:00 /bin/bash</span><br><span class="line">root      9823     1  0 12:01 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/s</span><br><span class="line">root      9824  9802  0 12:01 pts/0    00:00:00 ps -ef</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker attach 0f3c557a8105</span><br><span class="line">正在执行当前的代码。。。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span>  进入容器后开启一个新的终端，可以在里面操作（常用）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker attach  进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure>

<p><strong>从容器内拷贝文件到主机上</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器id：容器内路径 目的的主机路径</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前主机目录下</span></span><br><span class="line">[root@VM-24-12-centos home]# ls</span><br><span class="line">lighthouse</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入docker容器内部</span></span><br><span class="line">[root@VM-24-12-centos home]# docker exec -it 0f3c557a8105 /bin/bash</span><br><span class="line">[root@0f3c557a8105 /]# cd /home</span><br><span class="line">[root@0f3c557a8105 home]# ls</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在容器内新建一个文件</span></span><br><span class="line">[root@0f3c557a8105 home]# touch test.py</span><br><span class="line">[root@0f3c557a8105 home]# exit</span><br><span class="line">exit</span><br><span class="line">[root@VM-24-12-centos home]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS     NAMES</span><br><span class="line">0f3c557a8105   centos    &quot;/bin/sh -c &#x27;while t…&quot;   3 hours ago   Up 3 hours             nervous_colden</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件拷贝出来到主机上</span></span><br><span class="line">[root@VM-24-12-centos home]# docker cp 0f3c557a8105:/home/test.py /home</span><br><span class="line">[root@VM-24-12-centos home]# ls</span><br><span class="line">lighthouse  test.py</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝是一个手动过程，未来我们使用-v卷的技术，可以实现</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/./docker-base/6.jpg"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">attach	Attach to a running container                        # 当前shel1 attach 连接指足运行镜像</span><br><span class="line">build	Build an image from a Dockerfile                     # 通过Dockerfile定制镜像</span><br><span class="line">commit	Create a new image from a container changes          # 提交当前容器为新的镜像</span><br><span class="line">cp		Copy files/Folders from the containers filesystem to the host path  # 从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line">create	Create a new container                               # 创建一个新的容器,同run，但不启动容器</span><br><span class="line">diff	Inspect changes on a container&#x27;s filesystem          # 查看docker容器变化</span><br><span class="line">events	Get real time events from the server                 # 从docker服务获取容器实时事件</span><br><span class="line">exec	Run a command in an existing container               # 在已存在的容器上运行命令</span><br><span class="line">export	Stream the contents of a container as a tar archive  # 导出容器的内容流作为一个 tar归档文件[对应import]</span><br><span class="line">history	Show the history of an image                         # 展示一个镜像形成历史</span><br><span class="line">images	List images                                          # 列出系统当前镜像</span><br><span class="line">import	Create a new filesystem image from the contents of a tarball  # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line">info	Display system-wide information                      # 显示系统相关信息</span><br><span class="line">inspect	Return low-1evel information on a container          # 查看容器详细信息</span><br><span class="line">ki1l	Ki11 a running container                             # ki1l指定docker容器</span><br><span class="line">1oad	Load an image from a tar archive                     # 从一个tar包中加载一个镜像[对应save]</span><br><span class="line">login	Register or Login to the docker registry server      # 注册或者登陆一个docker源服务器</span><br><span class="line">logout	Log out from a Docker registry server                # 从当前Docker registry退出</span><br><span class="line">logs	Fetch the logs of a container                        # 输出当前容器日志信息</span><br><span class="line">port	Lookup the public-facing port which is NAT-ed to PRIVATE_PORT  # 查看映射端口对应的容器内部源端口</span><br><span class="line">pause	Pause all processes within a container               # 暂停容器</span><br><span class="line">ps		List containers                                      # 列出容器列表</span><br><span class="line">pu11	Pull an image or a repository from the docker registry server  # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line">push	Push an image or a repository to the docker registry server  # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line">restart	Restart a running container                          # 重启运行的容器</span><br><span class="line">rm		Remove one or more containers                        # 移除一个或者多个容器</span><br><span class="line">rmi		Remove one or more images  # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或-f强制册除]</span><br><span class="line">run		Run a command in a new container                     # 创建一个新的容器并运行―个命令</span><br><span class="line">save	Save an image to a tar archive                       # 保存一个镜像为一个:tar 包[对应1oad]</span><br><span class="line">search	Search for an image on the Docker Hub                # 在docker hub中搜索镜像</span><br><span class="line">start	Start a stopped containers                           # 启动容器</span><br><span class="line">stop	Stop a running containers                            # 停止容器</span><br><span class="line">tag		Tag an image into a repository                       # 给源中镜像打标签</span><br><span class="line">top		Lookup the running processes of a container          # 查看容器中运行的进程信息</span><br><span class="line">unpause	Unpause a paused container                           # 取消暂停容器</span><br><span class="line">version	Show the docker version information                  # 查看docker版本号</span><br><span class="line">wait	Block until a container stops，then print its exit code  # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure>

<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><ul>
<li>portainer</li>
<li>Rancher</li>
</ul>
<p><strong>什么是portainer</strong></p>
<p>Docker图形化界面管理工具，提供一个后台面板提供我们操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \</span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure>

<p>安装后，通过外网地址:8088就可以访问了</p>
<p>可视化面板平时不会使用，测试玩玩即可！</p>
<h1 id="Docker镜像讲解"><a href="#Docker镜像讲解" class="headerlink" title="Docker镜像讲解"></a>Docker镜像讲解</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。<br>所有的应用，直接打包docker镜像，就可以直接跑起来!</p>
<p><strong>如何得到镜像:</strong></p>
<ul>
<li>从远程仓库下载朋友拷贝给你</li>
<li>自己制作—个镜像DockerFile</li>
</ul>
<h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><blockquote>
<p>UnionFS（联合文件系统）</p>
</blockquote>
<p>UnionFS (联合文件系统）: Union文件系统( UnionFS ) 是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual file system)。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>特性:一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<blockquote>
<p>Docker镜像加载原理</p>
</blockquote>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<p>bootfs(bot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs (root file system)，在bootfs之上。包含的就是典型Linux系统中的/dev, /proc, /bin, /letc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu , Centos等等。</p>
<p><img src="/./docker-base/7.jpg"></p>
<p>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M ?</p>
<p>对于一个精简的Os , rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别,因此不同的发行版可以公用bootfs。</p>
<h2 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commint  提交容器成为一个新的副本</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令和git原理类似</span></span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot;  容器id 目标镜像名：[TAG]</span><br></pre></td></tr></table></figure>

<p><strong>实战测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动一个默认的Tomcat</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现这个默认的Tomcat是没有webapps应用，镜像的原因，官方的镜像默认webapps下面是没有文件的</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自己拷贝进去基本的文件</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交镜像</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker commit -a=&quot;cjsong&quot; -m=&quot;add webapps app&quot; 34232a0abc7b tomcat01:1.0</span><br><span class="line">0sha256:340e80fe4d77ca0cb32bb1852560d616cb850a9b924ad544edd5a4e4c7fbd055</span><br><span class="line">[root@VM-24-12-centos ~]# docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">tomcat01              1.0       340e80fe4d77   21 seconds ago   684MB</span><br><span class="line">nginx                 latest    605c77e624dd   11 days ago      141MB</span><br><span class="line">tomcat                9.0       b8e65a4d736d   2 weeks ago      680MB</span><br><span class="line">tomcat                latest    fb5657adc892   2 weeks ago      680MB</span><br></pre></td></tr></table></figure>

<p>这里就算入门Docker了！</p>
<p>以下章节是Docker的精髓！</p>
<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h2><p><strong>docker的理念：</strong>将应用和环境打包成一个镜像</p>
<p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！==需求：数据额可持续化==</p>
<p>MySQL，容器删了，删库跑路！==需求：MySQL数据可以存放在本地==</p>
<p>容器之间可以有一个数据共享的技术，Docker容器产生的数据，同步到本地</p>
<p>这就是卷技术，目录的挂载，将我们的容器内的目录挂载到Linux上</p>
<p><img src="/./docker-base/8.jpg"></p>
<p><strong>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的</strong></p>
<h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><blockquote>
<p>方式一：直接使用命令来挂载 -v</p>
</blockquote>
<p><img src="/./docker-base/10.jpg" alt="10"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker run -it -v /home/ceshi:/home centos /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动起来后可以通过docker inspect 容器id</span></span><br></pre></td></tr></table></figure>

<p><img src="/./docker-base/9.jpg"></p>
<p>测试文件的同步</p>
<p><img src="/./docker-base/10.jpg"></p>
<p>再测试：</p>
<p>停止容器，在宿主机上修改文件，启动容器，容器内的数据依旧是同步的</p>
<p>可以理解为映射！</p>
<p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步！</p>
<h2 id="实战：安装MySQL"><a href="#实战：安装MySQL" class="headerlink" title="实战：安装MySQL"></a>实战：安装MySQL</h2><p>思考：MySQL数据持久化的问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取镜像</span></span><br><span class="line">[root@VM-24-12-centos /]# docker pull mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行容器，需要做数据挂载  <span class="comment"># 注意：安装启动mysql，需要配置密码</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 官方测试：docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql：tag</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动我们的mysql容器</span></span><br><span class="line">-d 后台信息</span><br><span class="line">-p 端口映射</span><br><span class="line">-v 卷挂载</span><br><span class="line">-e 环境配置</span><br><span class="line">--name 容器名字</span><br><span class="line">[root@VM-24-12-centos /]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动成功之后，我们在本地使用sqlyog来测试连接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sqlyog-连接到服务器的3310 --- 3310和容器内的3306映射，这个时候我们就可以连接上了</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在本地测试创建一个数据库，查看一下我们映射的路径是否ok！</span></span><br></pre></td></tr></table></figure>

<p>我们将mysql容器删除，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能</p>
<h2 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载</span></span><br><span class="line">-v 容器内路径</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有的volume的情况</span></span><br><span class="line">[root@VM-24-12-centos home]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     16014f9579f5636bb71e4d427db32f3eafb95f1e2d9cf11e4c405ecee273dc8c</span><br><span class="line">local     fdc4ea0787124d820de9c4d504bbfc087ec568802c4ae952e36f2fee48e12183</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现，这种就是匿名挂载，我们在-v只写了容器</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 具名挂载</span></span><br><span class="line">[root@VM-24-12-centos home]# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class="line">598a15e9ea392222cd6c8bbf6b2cdc11f9d4775a57150ec2fcbb685c41967fa3</span><br><span class="line">[root@VM-24-12-centos home]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     16014f9579f5636bb71e4d427db32f3eafb95f1e2d9cf11e4c405ecee273dc8c</span><br><span class="line">local     fdc4ea0787124d820de9c4d504bbfc087ec568802c4ae952e36f2fee48e12183</span><br><span class="line">local     juming-nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过-v 卷面：容器内路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下这个卷</span></span><br><span class="line">[root@VM-24-12-centos home]# docker volume inspect juming-nginx</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2022-01-10T21:07:15+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;juming-nginx&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>所有的docker容器内的卷，没有指定目录的情况下都是在**/var/lib/docker/volumes/xxxx/_data**<br>我们通过具名挂载可以方便找到我们的一个卷，大多数情况下使用的是<strong>具名挂载</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如何确定是具名挂载还是匿名挂载，还是指定路径挂载</span></span><br><span class="line">-v  容器内路径             # 匿名挂载</span><br><span class="line">-v  卷名:容器内路径         # 具名挂载</span><br><span class="line">-v  /宿主机路径::容器内路径  # 指定路径挂载</span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 -v 容器内路径：ro rw 改变读写权限</span></span><br><span class="line">ro  readonly   # 只读</span><br><span class="line">rw  readwrite  # 可读可写</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一旦设置了容器权限，容器对我们挂载出来的内容就有限定了</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro  nginx</span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw  nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ro只要看到ro就说明这个路径只能通过宿主机来操作，容器内就是无法操作</span></span><br></pre></td></tr></table></figure>



<h2 id="初识Dockerfile"><a href="#初识Dockerfile" class="headerlink" title="初识Dockerfile"></a>初识Dockerfile</h2><p>Dockerfile就是用来构建docker镜像的构建文件，命令脚本。</p>
<p>通过脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个dockerfile文件，名字可以随机 建议 Dockerfile</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件中的内容 指令（大写） 参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里的每个命令，就是镜像的一层</span></span><br><span class="line">[root@VM-24-12-centos docker-test-volume]# pwd</span><br><span class="line">/home/docker-test-volume</span><br><span class="line">[root@VM-24-12-centos docker-test-volume]# vim dockerfile1</span><br><span class="line">[root@VM-24-12-centos docker-test-volume]# cat dockerfile1 </span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line"></span><br><span class="line">CMD echo &quot;-----end-----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line">[root@VM-24-12-centos docker-test-volume]# docker build -f dockerfile1 -t cjsong/centos:1.0 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM centos</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 5d0da3dc9764</span></span><br><span class="line">Step 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 530b2d93f754</span></span><br><span class="line">Removing intermediate container 530b2d93f754</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 9d8126e3d119</span></span><br><span class="line">Step 3/4 : CMD echo &quot;-----end-----&quot;</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 02ca258a0415</span></span><br><span class="line">Removing intermediate container 02ca258a0415</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 51b222329824</span></span><br><span class="line">Step 4/4 : CMD /bin/bash</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> a53427c2f2fb</span></span><br><span class="line">Removing intermediate container a53427c2f2fb</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 17c7b7128830</span></span><br><span class="line">Successfully built 17c7b7128830</span><br><span class="line">Successfully tagged cjsong/centos:1.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动自己写的容器</span></span><br></pre></td></tr></table></figure>

<p><img src="/./docker-base/11.jpg"></p>
<p>这个卷和外部一定有一个同步的目录</p>
<p><img src="/./docker-base/12.jpg"></p>
<p>查看一下卷挂载的路径</p>
<p><img src="/./docker-base/13.jpg"></p>
<p>测试一下刚才的文件是否同步出去了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos docker-test-volume]# cd /var/lib/docker/volumes/b9c329c7d0847132b4059231f559694f2060bd2b7e3bafd2e2363573c5f15b88/_data</span><br><span class="line">[root@VM-24-12-centos _data]# ls</span><br><span class="line">container.txt</span><br><span class="line">[root@VM-24-12-centos _data]# </span><br></pre></td></tr></table></figure>

<p>这种方式我们未来使用的十分多，因为我们通常会构建自己的镜像</p>
<p>假设构建镜像时没有挂载卷，要手动镜像挂载 -v 卷名：容器内路径</p>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>两个mysql同步数据</p>
<p><img src="/./docker-base/14.jpg"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动3个容器，通过我们刚才自己写的镜像启动</span></span><br></pre></td></tr></table></figure>

<p><img src="/./docker-base/15.jpg"></p>
<p><img src="/./docker-base/16.jpg"></p>
<p>只要通过–volume-from，我们就可以容器间的数据共享了</p>
<p>父容器删了也不影响子容器的数据</p>
<p>多个mysql实现数据共享</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos /]# docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"></span><br><span class="line">[root@VM-24-12-centos /]# docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volume-from mysql01 mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个时候，可以实现两个容器数据同步</span></span><br></pre></td></tr></table></figure>



<p><strong>结论</strong></p>
<p>容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止</p>
<p>但是一旦持久化到了本地，这个时候，本地的数据是不会删除的</p>
<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><p>dockerfile是用来构建docker镜像的文件，命令参数脚本</p>
<p>构建步骤：</p>
<ol>
<li>编写一个dockerfile文件</li>
<li>docker build 构建成为一个镜像</li>
<li>docker run 运行镜像</li>
<li>docker push 发布镜像（DockerHub、阿里云镜像仓库）</li>
</ol>
<h2 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h2><p><strong>基础知识：</strong></p>
<ol>
<li>每个保留关键字（指令）都必须是大写字母</li>
<li>执行从上到下顺序执行</li>
<li>#表示注释</li>
<li>每一个指令都会创建提交一个新的镜像层，并提交</li>
</ol>
<p><img src="/./docker-base/17.jpg"></p>
<p>dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单</p>
<p>Docker镜像逐渐成为企业交付的标准，必须要掌握</p>
<p>DockerFile：构建文件，定义了一切的步骤，源代码</p>
<p>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行的产品</p>
<p>Docker容器：容器就是镜像运行起来提供服务器</p>
<h2 id="DockerFile的指令"><a href="#DockerFile的指令" class="headerlink" title="DockerFile的指令"></a>DockerFile的指令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM          # 基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER    # 镜像是谁写的，姓名+邮箱</span><br><span class="line">RUN           # 镜像构建的时候需要运行的命令</span><br><span class="line">ADD           # 步骤：Tomcat镜像，这个Tomcat压缩包，添加内容</span><br><span class="line">WORKDIR       # 镜像的工作目录</span><br><span class="line">VOLUME        # 挂载的目录</span><br><span class="line">EXPOST        # 暴露端口配置</span><br><span class="line">CMD           # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT    # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="line">ONBUILD       # 当构建一个被继承DockerFile这个时候就会运行ONBUILD的指令。触发指令。</span><br><span class="line">COPY          # 类似ADD，将我们文件拷贝到镜像中</span><br><span class="line">ENV           # 构建的时候设置环境变量</span><br></pre></td></tr></table></figure>

<p><img src="/./docker-base/18.jpg"></p>
<p>以前都是使用别人的镜像，有了这些指令后，我们可以自己写一个镜像。</p>
<h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><p>Docker Hub中99%镜像都是从这个基础镜像过来的 FROM scratch，然后配置需要的软件来进行的构建</p>
<p><img src="/./docker-base/19.jpg"></p>
<blockquote>
<p>创建一个自己的centos</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、编写Dockerfile文件</span></span><br><span class="line">[root@VM-24-12-centos dockerfile]# cat mydockerfile-centos </span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER codeChen&lt;735709343@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;-----end-----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、通过这个文件构建镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令docker build -f dockerfile文件路径 -t 镜像名:[tag]</span></span><br><span class="line">Successfully built 7a26a1ca5051</span><br><span class="line">Successfully tagged mycentos:0.1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、测试运行</span></span><br></pre></td></tr></table></figure>

<p>我们可以列出本地进行的变更历史</p>
<p><img src="/./docker-base/20.jpg"></p>
<p>我们可以根据history研究一下镜像是怎么做的</p>
<blockquote>
<p>CMD 和 ENTRYPOINT区别</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CMD           # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT    # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br></pre></td></tr></table></figure>

<p>测试CMD</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编写Dockerfile文件</span></span><br><span class="line">[root@VM-24-12-centos dockerfile]# vim dockerfile-cmd-test</span><br><span class="line">[root@VM-24-12-centos dockerfile]# cat dockerfile-cmd-test </span><br><span class="line">FROM centos</span><br><span class="line">CMD [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像</span></span><br><span class="line">[root@VM-24-12-centos dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest .</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line">Step 1/2 : FROM centos</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 5d0da3dc9764</span></span><br><span class="line">Step 2/2 : CMD [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 798fb44a5a98</span></span><br><span class="line">Removing intermediate container 798fb44a5a98</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> dd5e2ef6c441</span></span><br><span class="line">Successfully built dd5e2ef6c441</span><br><span class="line">Successfully tagged cmdtest:latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> run运行，发现ls -a 命令运行成功</span></span><br><span class="line">[root@VM-24-12-centos dockerfile]# docker run dd5e2ef6c441</span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib64</span><br><span class="line">lost+found</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">var</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 想追加一个命令 -l   ls -al</span></span><br><span class="line">[root@VM-24-12-centos dockerfile]# docker run dd5e2ef6c441 -l</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cmd的情况下 -l 替换了CMD[<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>]命令，-l不是命令所以报错</span></span><br></pre></td></tr></table></figure>

<p>测试ENTRYPOINT</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos dockerfile]# vim dockerfile-entrypoint-test</span><br><span class="line">[root@VM-24-12-centos dockerfile]# cat dockerfile-entrypoint-test </span><br><span class="line">FROM centos</span><br><span class="line">EMTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"></span><br><span class="line">[root@VM-24-12-centos dockerfile]# docker build -f dockerfile-entrypoint-test -t entrypoint-test .</span><br><span class="line">Sending build context to Docker daemon  4.096kB</span><br><span class="line">Step 1/2 : FROM centos</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 5d0da3dc9764</span></span><br><span class="line">Step 2/2 : ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> de769740d0d0</span></span><br><span class="line">Removing intermediate container de769740d0d0</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> ea54c2dc6a5f</span></span><br><span class="line">Successfully built ea54c2dc6a5f</span><br><span class="line">Successfully tagged entrypoint-test:latest</span><br><span class="line">[root@VM-24-12-centos dockerfile]# docker run ea54c2dc6a5f</span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib64</span><br><span class="line">lost+found</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">var</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 追加命令是直接拼接在我们的ENTRYPOINT命令后面</span></span><br><span class="line">[root@VM-24-12-centos dockerfile]# docker run ea54c2dc6a5f -l</span><br><span class="line">total 56</span><br><span class="line">drwxr-xr-x   1 root root 4096 Jan 14 06:54 .</span><br><span class="line">drwxr-xr-x   1 root root 4096 Jan 14 06:54 ..</span><br><span class="line">-rwxr-xr-x   1 root root    0 Jan 14 06:54 .dockerenv</span><br><span class="line">lrwxrwxrwx   1 root root    7 Nov  3  2020 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x   5 root root  340 Jan 14 06:54 dev</span><br><span class="line">drwxr-xr-x   1 root root 4096 Jan 14 06:54 etc</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 home</span><br><span class="line">lrwxrwxrwx   1 root root    7 Nov  3  2020 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx   1 root root    9 Nov  3  2020 lib64 -&gt; usr/lib64</span><br><span class="line">drwx------   2 root root 4096 Sep 15 14:17 lost+found</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 media</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 mnt</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 opt</span><br><span class="line">dr-xr-xr-x 120 root root    0 Jan 14 06:54 proc</span><br><span class="line">dr-xr-x---   2 root root 4096 Sep 15 14:17 root</span><br><span class="line">drwxr-xr-x  11 root root 4096 Sep 15 14:17 run</span><br><span class="line">lrwxrwxrwx   1 root root    8 Nov  3  2020 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 srv</span><br><span class="line">dr-xr-xr-x  13 root root    0 Jan 11 12:42 sys</span><br><span class="line">drwxrwxrwt   7 root root 4096 Sep 15 14:17 tmp</span><br><span class="line">drwxr-xr-x  12 root root 4096 Sep 15 14:17 usr</span><br><span class="line">drwxr-xr-x  20 root root 4096 Sep 15 14:17 var</span><br></pre></td></tr></table></figure>

<p>Dockerfile中很多命令偶读十分相似，我们需要了解它们的区别。</p>
<h2 id="实战：Tomcat镜像"><a href="#实战：Tomcat镜像" class="headerlink" title="实战：Tomcat镜像"></a>实战：Tomcat镜像</h2><ol>
<li><p>准备镜像文件Tomcat压缩包，jdk压缩包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos tomcat]# ll</span><br><span class="line">total 84016</span><br><span class="line">-rw-r--r-- 1 root root 11582777 Jan 14 21:50 apache-tomcat-9.0.56.tar.gz</span><br><span class="line">-rw-r--r-- 1 root root 74444709 Jan 14 21:50 jdk-8u311-linux-aarch64.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>编写dockerfile文件，官方命名<strong>Dockerfile</strong>，build会自动寻找这个文件，就不需要-f指定了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Dockerfile文件</span></span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER CodeChen&lt;735709343@qq.com&gt;</span><br><span class="line"></span><br><span class="line">COPY readme.txt /usr/local/readme.txt</span><br><span class="line"></span><br><span class="line">ADD jdk-8u311-linux-x64.tar.gz /usr/local/</span><br><span class="line">ADD apache-tomcat-9.0.56.tar.gz /usr/local/</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_311</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.56</span><br><span class="line">ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.56</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.56/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.56/bin/logs/catalina.out</span><br></pre></td></tr></table></figure></li>
<li><p>构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker build</span></span><br><span class="line">[root@VM-24-12-centos tomcat]# docker build -t diytomcat .</span><br></pre></td></tr></table></figure></li>
<li><p>启动容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos tomcat]# docker run -d -p 9090:8080 --name CodeChenTomcat -v /home/CodeChen/build/tomcat/test:/usr/local/apache-tomcat-9.0.56/webapps/test -v /home/CodeChen/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.56/logs diytomcat</span><br></pre></td></tr></table></figure></li>
<li><p>访问测试</p>
</li>
<li><p>发布项目（由于做了卷挂载，我们直接在本地编写项目发布了）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;CodeChen&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Hello World!&lt;br/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">System.out.println(<span class="string">&quot;-----my test web logs-----&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h2><blockquote>
<p>DockerHub</p>
</blockquote>
<ol>
<li><p><a href="https://hub.docker.com/">https://hub.docker.com/</a>   注册自己的账号</p>
</li>
<li><p>确定这个账号可以登录</p>
</li>
<li><p>在我们服务器上提交自己的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos ~]# docker login --help</span><br><span class="line"></span><br><span class="line">Usage:  docker login [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line">Log in to a Docker registry.</span><br><span class="line">If no server is specified, the default is defined by the daemon.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --password string   Password</span><br><span class="line">      --password-stdin    Take the password from stdin</span><br><span class="line">  -u, --username string   Username</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>登录后就可以提交镜像</p>
</li>
<li><p>提交镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 现将镜像的TAG改名，必须带dockerHub的账面名</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker tag 844c55be72a6 账号名/tomcat:1.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交镜像</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker push 账号名/tomcat:1.0</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>阿里云镜像服务上</p>
</blockquote>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="/./docker-base/21.jpg"></p>
<h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="理解Docker0"><a href="#理解Docker0" class="headerlink" title="理解Docker0"></a>理解Docker0</h2><p>清空所有环境</p>
<blockquote>
<p>测试</p>
</blockquote>
<p><img src="/./docker-base/22.jpg"></p>
<p>三个网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 问题：docker 是如何处理容器网络访问的？</span></span><br></pre></td></tr></table></figure>

<p><img src="/./docker-base/23.jpg"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">[root@VM-24-12-centos ~]<span class="comment"># docker run -d -P --name tomcat01 tomcat</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内部网络地址 ip addr， 发现容器启动的时候会得到一个eth0@if262 ip地址，docker分配的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有ip指令的，进入容器执行apt update &amp;&amp; apt install -y iproute2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ping指令apt update &amp;&amp; apt install -y inetutils-ping</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker exec -it tomcat01 ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">70: eth0@if71: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 思考，Linux能不能ping通容器内部</span></span><br><span class="line">[root@VM-24-12-centos ~]# ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.051 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.054 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.052 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.053 ms</span><br><span class="line">^C</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以ping通</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理</p>
</blockquote>
<ol>
<li><p>我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0</p>
<p>桥接模式，使用的技术是veth-pair技术</p>
<p>再次测试ip addr</p>
<p><img src="/./docker-base/24.jpg"></p>
</li>
<li><p>再启动一个容器测试，发现又多了一对网卡</p>
<p><img src="/./docker-base/25.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 我们发现这些容器带来的网卡，都是一对一对的</span><br><span class="line"># veth-pair 就是一对虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相邻</span><br><span class="line"># 正因为有这个特性，veth-pair充电一个桥梁，连着各种虚拟网络设备的</span><br><span class="line"># Openstac，Docker容器之间的连接，OVS的连接，都是使用veth-pair技术</span><br></pre></td></tr></table></figure></li>
<li><p>我们来测试 tomcat01 和 tomcat02</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos ~]# docker exec -it tomcat02 ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.139 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.068 ms</span><br><span class="line">^C</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结论：容器和容器间是可以互相ping通的</span></span><br></pre></td></tr></table></figure>

<p><img src="/./docker-base/26.jpg"></p>
</li>
</ol>
<p>结论：tomcat01和tomcat02是共用的一个路由器，docker0</p>
<p>所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用IP</p>
<blockquote>
<p>小结</p>
</blockquote>
<p>Docker使用的是Linux的桥接，宿主机中的一个Docker容器的网络 docker0</p>
<p><img src="/./docker-base/27.jpg"></p>
<p>​                Docker中所有的网络接口都是虚拟的。虚拟的转发效率高（内网传递文件）</p>
<p>​                只要容器删除，对应的网桥一堆就没了</p>
<h2 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h2><blockquote>
<p>思考一个场景，我们编写一个微服务，database url=ip:，项目部重启，数据库ip换掉了，我们希望可以处理这个问题，可以名字来进行访问容器？</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos ~]# docker exec -it tomcat02 ping docker01</span><br><span class="line">ping: docker01: Name or service not known</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如何解决这个问题？</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker exec -it tomcat02 ping tomcat01</span><br><span class="line">ping: tomcat01: Name or service not known</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过--link就可以解决</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat</span><br><span class="line">40f1831102ec395d004511311d4929d51ac2f6c0b2b74660795ed475c182d951</span><br><span class="line">[root@VM-24-12-centos ~]# docker exec -it tomcat03 ping tomcat02</span><br><span class="line">PING tomcat02 (172.17.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=0 ttl=64 time=0.107 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.087 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.081 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 反向可以ping通吗？</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker exec -it tomcat02 ping tomcat03</span><br><span class="line">ping: tomcat03: Name or service not known</span><br></pre></td></tr></table></figure>

<p>探索：inspect！</p>
<p><img src="/./docker-base/28.jpg"></p>
<p>其实这个tomcat03就是在本地配置了tomcat02的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看hosts配置，在这里可以发现</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker exec -it tomcat03 cat /etc/hosts</span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line">172.17.0.3	tomcat02 5127a5a11c80</span><br><span class="line">172.17.0.4	40f1831102ec</span><br></pre></td></tr></table></figure>

<p>本质探索：–link就是我们在hosts配置中增加了一个172.17.0.3    tomcat02 5127a5a11c80</p>
<p><strong>不建议使用–link</strong></p>
<p>自定义网络，不适用docker0</p>
<p>docker0问题：它不支持容器名连接访问</p>
<h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><blockquote>
<p>查看所有的docker网络</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">9015d2de5076   bridge    bridge    local</span><br><span class="line">d424bc564388   host      host      local</span><br><span class="line">c05e1cec9830   none      null      local</span><br></pre></td></tr></table></figure>

<p><strong>网络模式</strong></p>
<p>bridge：桥接docker（默认）</p>
<p>none：不配置网络</p>
<p>host：和宿主机共享网络</p>
<p>container：容器网络连通（用得少，局限性大）</p>
<p><strong>测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们直接启动的命令 --net bridge。而这个就是我们的docker0</span></span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat01 --net bridge tomcat</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker0特点：默认，域名不能访问， --link可以打通连接</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们可以自定义一个网络</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">d52c8dfc3f43e3093db8fac8610a6bfcb730dc94130f348b35e6a8c724063bfd</span><br><span class="line">[root@VM-24-12-centos ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">9015d2de5076   bridge    bridge    local</span><br><span class="line">d424bc564388   host      host      local</span><br><span class="line">d52c8dfc3f43   mynet     bridge    local</span><br><span class="line">c05e1cec9830   none      null      local</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们自己的网络就创建好了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos ~]# docker network inspect mynet</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;mynet&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;d52c8dfc3f43e3093db8fac8610a6bfcb730dc94130f348b35e6a8c724063bfd&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2022-01-15T19:26:58.202086579+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;6c2933400d5f7a2cb89576102cc1a3a32de688fc49606025cc21ef5229995f80&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat-net-01&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;14d101d7465b1befcac43d3ff4a23b0aaaed71684cde4e6e869093bd9475a9e3&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;8649eb40b3e4aa6de2feab6898d15783b9946b76a802782b3bbdaef1a27a5f03&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat-net-02&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;c0fcc13bee04c3cb60f5ddc8a2d933ebce2ce694a71cf07e2c588b284ce974d1&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次测试</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker exec -it tomcat-net-01 ping 192.168.0.3</span><br><span class="line">PING 192.168.0.3 (192.168.0.3): 56 data bytes</span><br><span class="line">64 bytes from 192.168.0.3: icmp_seq=0 ttl=64 time=0.101 ms</span><br><span class="line">64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.073 ms</span><br><span class="line">64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.083 ms</span><br><span class="line">^C--- 192.168.0.3 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 0.073/0.086/0.101/0.000 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 现在不使用--link也可以ping名字了</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker exec -it tomcat-net-01 ping tomcat-net-02</span><br><span class="line">PING tomcat-net-02 (192.168.0.3): 56 data bytes</span><br><span class="line">64 bytes from 192.168.0.3: icmp_seq=0 ttl=64 time=0.080 ms</span><br><span class="line">64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.093 ms</span><br><span class="line">64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.083 ms</span><br><span class="line">^C--- tomcat-net-02 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 0.080/0.085/0.093/0.000 ms</span><br></pre></td></tr></table></figure>

<p>自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络</p>
<p>好处：</p>
<p>redis - 不同的集群使用不用的网络，保证集群是安全和健康的</p>
<p>mysql - 不同的集群使用不同的网络，保证集群是安全和健康的</p>
<h2 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h2><p><img src="/./docker-base/29.jpg"></p>
<p><img src="/./docker-base/30.jpg" alt="30"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试打通 tomcat01 --mynet</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连通之后就是将 tomcat01 放到了 mynet 网络下</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一个容器两个ip地址</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 阿里云服务 公网ip 私网ip</span></span><br></pre></td></tr></table></figure>

<p><img src="/./docker-base/31.jpg"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">![32](D:\Learning\PersonalBlog\CodeChenBlog\source\_posts\docker-base\32.jpg)# tomcat01可以ping成功了</span><br><span class="line">[root@VM-24-12-centos ~]# docker exec -it tomcat01 ping tomcat-net-01</span><br><span class="line">PING tomcat-net-01 (192.168.0.2): 56 data bytes</span><br><span class="line">64 bytes from 192.168.0.2: icmp_seq=0 ttl=64 time=0.089 ms</span><br><span class="line">64 bytes from 192.168.0.2: icmp_seq=1 ttl=64 time=0.085 ms</span><br><span class="line">64 bytes from 192.168.0.2: icmp_seq=2 ttl=64 time=0.099 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tomcat02没有打通</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker exec -it tomcat02 ping tomcat-net-01</span><br><span class="line">ping: unknown host</span><br></pre></td></tr></table></figure>



<p>结论：假设要跨网络操作别人，就需要使用docker network connect 连通</p>
<h2 id="实战：部署Redis集群"><a href="#实战：部署Redis集群" class="headerlink" title="实战：部署Redis集群"></a>实战：部署Redis集群</h2><p><img src="/./docker-base/32.jpg"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建网卡</span></span><br><span class="line">[root@VM-24-12-centos ~]# docker network create redis --subnet 172.38.0.0/16</span><br><span class="line">884ebcd83c61febde438596b1edfb53c7df22b814be5eb4c3b67db2b594b9caa</span><br><span class="line">[root@VM-24-12-centos ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">9015d2de5076   bridge    bridge    local</span><br><span class="line">d424bc564388   host      host      local</span><br><span class="line">d52c8dfc3f43   mynet     bridge    local</span><br><span class="line">c05e1cec9830   none      null      local</span><br><span class="line">884ebcd83c61   redis     bridge    local</span><br><span class="line">[root@VM-24-12-centos ~]# </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过脚本创建六个redis配置</span></span><br><span class="line">for port in $(seq 1 6); \</span><br><span class="line">do \</span><br><span class="line">mkdir -p /mydata/redis/node-$&#123;port&#125;/conf</span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">port 6379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1$&#123;port&#125;</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">docker run -p 637$&#123;port&#125;:6379 -p 1637$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \</span><br><span class="line">-v /mydata/redis/node-$&#123;port&#125;/data:/data \</span><br><span class="line">-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; \</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一个一个的启动</span></span><br><span class="line">docker run -p 6371:6379 -p 16371:16379 --name redis-1 \</span><br><span class="line">-v /mydata/redis/node-1/data:/data \</span><br><span class="line">-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -p 6376:6379 -p 16376:16379 --name redis-6 \</span><br><span class="line">-v /mydata/redis/node-6/data:/data \</span><br><span class="line">-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建集群</span></span><br><span class="line">[root@VM-24-12-centos redis]# docker exec -it redis-1 /bin/sh</span><br><span class="line">/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cl</span><br><span class="line">uster-replicas 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 172.38.0.15:6379 to 172.38.0.11:6379</span><br><span class="line">Adding replica 172.38.0.16:6379 to 172.38.0.12:6379</span><br><span class="line">Adding replica 172.38.0.14:6379 to 172.38.0.13:6379</span><br><span class="line">M: 7974a0d896bc29eb2c3327e1323ea57690636813 172.38.0.11:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 717715dd5d6410d67f5409a62fda87c57cdd9442 172.38.0.12:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 1cebf3078d1560ab9e2de241f395912b8d1864cd 172.38.0.13:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 44017ab43f38cc76c48b583709069fa03c4acb5e 172.38.0.14:6379</span><br><span class="line">   replicates 1cebf3078d1560ab9e2de241f395912b8d1864cd</span><br><span class="line">S: 90d32dcaa9a977c61bcdb6f85186b1831f782286 172.38.0.15:6379</span><br><span class="line">   replicates 7974a0d896bc29eb2c3327e1323ea57690636813</span><br><span class="line">S: 8059c7709198db5c32c9153c0a9eb3601023ef6b 172.38.0.16:6379</span><br><span class="line">   replicates 717715dd5d6410d67f5409a62fda87c57cdd9442</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 172.38.0.11:6379)</span></span><br><span class="line">M: 7974a0d896bc29eb2c3327e1323ea57690636813 172.38.0.11:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 717715dd5d6410d67f5409a62fda87c57cdd9442 172.38.0.12:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 44017ab43f38cc76c48b583709069fa03c4acb5e 172.38.0.14:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1cebf3078d1560ab9e2de241f395912b8d1864cd</span><br><span class="line">S: 8059c7709198db5c32c9153c0a9eb3601023ef6b 172.38.0.16:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 717715dd5d6410d67f5409a62fda87c57cdd9442</span><br><span class="line">S: 90d32dcaa9a977c61bcdb6f85186b1831f782286 172.38.0.15:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7974a0d896bc29eb2c3327e1323ea57690636813</span><br><span class="line">M: 1cebf3078d1560ab9e2de241f395912b8d1864cd 172.38.0.13:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>docker搭建redis集群完成</p>
<p><img src="/./docker-base/33.jpg"></p>
<p>使用docker之后，所有的技术都会慢慢的变得简单起来！</p>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><h1 id="CI-CD之Jenkins"><a href="#CI-CD之Jenkins" class="headerlink" title="CI/CD之Jenkins"></a>CI/CD之Jenkins</h1><p>资料来源于狂神讲Docker教学视频。</p>
<p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=40&amp;spm_id_from=333.1007.top_right_bar_window_history.content.click">https://www.bilibili.com/video/BV1og4y1q7M4?p=40&amp;spm_id_from=333.1007.top_right_bar_window_history.content.click</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统基础知识</title>
    <url>/os-base/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>现代计算机系统由一个或多个处理器、主存、键盘、鼠标、显示器以及各种输入输出设备构成。</p>
<p>操作系统：在硬件的基础之上，计算机安装了一层软件，这层软件就称之为操作系统，它能够通过响应用户的指令来控制硬件，程序员可以不用直接和硬件打交道。我们常用的通讯软件、办公软件等软件都是建立在操作系统之上。</p>
<p>我们常见的操作系统主要有Windows、Linux、macOS等等。</p>
</blockquote>
<p><img src="/os-base/1.jpg"></p>
<h1 id="计算机硬件简介"><a href="#计算机硬件简介" class="headerlink" title="计算机硬件简介"></a>计算机硬件简介</h1><blockquote>
<ol>
<li>CPU<ul>
<li>CPU 是计算机的大脑，它主要和内存进行交互，从内存中提取指令并执行它。</li>
</ul>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门</title>
    <url>/redis-base/</url>
    <content><![CDATA[<h1 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h1><h2 id="为什么要用Nosql？"><a href="#为什么要用Nosql？" class="headerlink" title="为什么要用Nosql？"></a>为什么要用Nosql？</h2><blockquote>
<ol>
<li>单机MySQL的年代</li>
</ol>
</blockquote>
<p><img src="/./redis-base/1.jpg"></p>
<p>90年代，一个基本的网站访问量一般不会太大，单个数据库完全足够</p>
<p>那个时候，更多的是使用静态网页，HTML，服务器根本没有太大的压力</p>
<p>思考：这种情况下，整个网站的瓶颈是什么？</p>
<ol>
<li>数据量如果太大，一个机器放不下</li>
<li>数据的索引300万就一定要建立索引。数据的索引（B+Tree），一个机器内存放不下</li>
<li>访问量（读写混合），一个服务器承受不了</li>
</ol>
<p>只要你开始出现以上的三种情况之一，那么就必须要升级</p>
<blockquote>
<ol start="2">
<li>Memcached（缓存） + MySQL + 垂直拆分（读写分离）</li>
</ol>
</blockquote>
<p>网站80%的情况都是在读，每次都要去查询数据库的话就十分麻烦，所以我们希望减轻数据库的压力，我们可以使用缓存来保证效率。</p>
<p>发展过程：优化数据结构和索引–》文件缓存（I/O）–》Memcached（当时最热门的技术）</p>
<p><img src="/./redis-base/2.jpg"></p>
<blockquote>
<ol start="3">
<li>分库分表 + 水平拆分 + MySQL集群</li>
</ol>
</blockquote>
<p>技术和业务在发展的同时，对人的要求也越来越高了</p>
<p><strong>本质：数据库（读，写）</strong></p>
<p>早些年MyISAM：表锁，十分影响效率，高并发下就会出现严重的锁问题</p>
<p>转战Innodb：行锁</p>
<p>慢慢的就开始使用分库分表来解决写的压力，MySQL在那个年代推出了表分区，但并没有很多公司使用。</p>
<p>MySQL的集群，很好满足了那个年代的需求</p>
<p><img src="/./redis-base/3.jpg"></p>
<blockquote>
<ol start="4">
<li>最近的年代</li>
</ol>
</blockquote>
<p>2010–2020十年之间，世界已经发生了翻天覆地的变化；（定位，也是一种数据，音乐，热榜。。。）</p>
<p>MySQL等关系型数据库就不够用了，数据量很多，变化很快</p>
<p>MySQL有的使用它来存储一些比较大的文件，博客，图片，数据库表很大，效率就低了，如果有一种数据库来专门处理这种数据，MySQL压力就变得十分小（研究如何处理这些问题）大数据的IO压力下，表几乎没法更改</p>
<blockquote>
<p>目前一个基本的互联网项目</p>
</blockquote>
<p><img src="/./redis-base/4.jpg"></p>
<blockquote>
<p>为什么要用NoSQL</p>
</blockquote>
<p>用户个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长</p>
<p>这时候我们就需要使用NoSQL数据库，NoSQL可以很好的处理以上的情况。</p>
<h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h2><blockquote>
<p>NoSQL</p>
</blockquote>
<p>NoSQL = Not Only SQL（不仅仅是SQL）</p>
<p>关系型数据库：表格，行，列（POI）</p>
<p>泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代，尤其是超大规模的高并发的社区。暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的，而且是我们当下必须掌握的一个技术</p>
<p>很多数据类型，用户的个人信息，社交网络，地理位置，这些数据类型的存储不需要一个固定的格式，不需要过多的操作就可以横向扩展。Map&lt;String,Object&gt;使用键值对来控制。</p>
<blockquote>
<p>NoSQL特点</p>
</blockquote>
<p>解耦</p>
<ol>
<li><p>方便扩展（数据之间没有关系，很好扩展）</p>
</li>
<li><p>大数据量高性能（Redis 一秒写8万次，读取11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高）</p>
</li>
<li><p>数据类型时多样型的（不需要事先设计数据库！随取随用！如果是数据量十分大的表，很多人就无法设计了）</p>
</li>
<li><p>传统RDBMS和NoSQL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传统的RDBMS</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中</span><br><span class="line">- 操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础的事务</span><br><span class="line">- ......</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NoSQL</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图像数据库（社交关系）</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE （异地多活）</span><br><span class="line">- 高性能，高可用，高可扩展</span><br><span class="line">- ......</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>3V + 3高</p>
</blockquote>
<p>大数据时代的3V：主要是描述问题的</p>
<ul>
<li>海量Volume</li>
<li>多样Variety</li>
<li>实时Velocity</li>
</ul>
<p>大数据时代的3高：主要对程序的要求</p>
<ul>
<li>高并发</li>
<li>高可拓</li>
<li>高性能</li>
</ul>
<p>真正在公司中的实践：NoSQL+RDBMS一起使用才是最强的</p>
<h2 id="阿里巴巴演进分析"><a href="#阿里巴巴演进分析" class="headerlink" title="阿里巴巴演进分析"></a>阿里巴巴演进分析</h2><p>如果你未来想当一个架构师：没有什么是加一层解决不了的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1、商品的基本信息</span><br><span class="line">	名称、价格、商家信息；</span><br><span class="line">	关系型数据库就可以解决了！ MySQL / Oracle</span><br><span class="line">	淘宝内部的MySQL不是大家用的MySQL</span><br><span class="line">	</span><br><span class="line"># 2、商品的描述、评论（文字比较多）</span><br><span class="line">	文档型数据库中，MongoDB</span><br><span class="line">	</span><br><span class="line"># 3、图片</span><br><span class="line">	分布式文件系统 FastDFS</span><br><span class="line">	- 淘宝自己的  TFS</span><br><span class="line">	- Google    GFS</span><br><span class="line">	- Hadoop    HDFS</span><br><span class="line">	- 阿里云     oss</span><br><span class="line">	</span><br><span class="line"># 4、商品的关键字（搜索）</span><br><span class="line">	- 搜索引擎  solr  elasticsearch</span><br><span class="line">	- ISearch：多隆</span><br><span class="line">	</span><br><span class="line"># 5、商品热门的波段信息</span><br><span class="line">	- 内存数据库</span><br><span class="line">	- Redis Tair、Memache...</span><br><span class="line">	</span><br><span class="line"># 6、商品的交易，外部的支付接口</span><br><span class="line">	- 三方应用</span><br></pre></td></tr></table></figure>



<h2 id="NoSQL的四大类"><a href="#NoSQL的四大类" class="headerlink" title="NoSQL的四大类"></a>NoSQL的四大类</h2><p><strong>KV键值对：</strong></p>
<ul>
<li>新浪：Redis</li>
<li>美团：Redis + Tair</li>
<li>阿里、百度：Redis + memcache</li>
</ul>
<p><strong>文档型数据库（bson格式和json一样）：</strong></p>
<ul>
<li>MongoDB（一般必须要掌握）<ul>
<li>MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档！</li>
<li>MongoDB是一个介于关系型数据库和非关系型数据库中间的产品，MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的</li>
<li>ConthDB</li>
</ul>
</li>
</ul>
<p><strong>列存储数据库：</strong></p>
<ul>
<li>HBase</li>
<li>分布式文件系统</li>
</ul>
<p><strong>图关系数据库：</strong></p>
<ul>
<li>不是存图形，而是存关系的，比如：朋友圈社交网络，广告推荐</li>
<li>Neo4j，InfoGrid</li>
</ul>
<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Redis是什么？</p>
</blockquote>
<p>Redis（<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver )，即远程字典服务</p>
<p>是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API</p>
<p>免费和开源，当下最热门的NoSQL技术之一，也被人们称之为结构化数据库</p>
<blockquote>
<p>Redis能干嘛？</p>
</blockquote>
<ol>
<li>内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）</li>
<li>效率高，可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器（浏览量）</li>
<li>……</li>
</ol>
<blockquote>
<p>特性</p>
</blockquote>
<ol>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
<li>……</li>
</ol>
<p>主要：Windows在GitHub上下载（停更很久了）</p>
<p>Redis推荐都是在Linux服务器上搭建的。</p>
<h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><ol>
<li><p>下载安装包 redis-6.2.6.tar.gz</p>
</li>
<li><p>解压安装包</p>
<p><img src="/./redis-base/5.jpg"></p>
</li>
<li><p>进入解压后的文件夹，可以看到我们redis的配置文件</p>
<p><img src="/./redis-base/6.jpg"></p>
</li>
<li><p>基本的环境安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="/./redis-base/7.jpg"></p>
</li>
</ol>
<p><img src="/./redis-base/8.jpg"></p>
<ol start="5">
<li><p>Redis的默认安装路径 /usr/local/bin</p>
<p><img src="/./redis-base/9.jpg"></p>
</li>
<li><p>将Redis配置文件复制到我们当前目录下</p>
<p><img src="/./redis-base/10.jpg"></p>
</li>
<li><p>Redis默认不是后台启动的，修改配置文件</p>
<p><img src="/./redis-base/11.jpg"></p>
</li>
<li><p>启动Redis服务</p>
<p><img src="/./redis-base/12.jpg"></p>
</li>
<li><p>使用redis-cli进行连接测试</p>
<p><img src="/./redis-base/13.jpg"></p>
</li>
<li><p>查看redis的进程是否开启</p>
<p><img src="/./redis-base/14.jpg"></p>
</li>
<li><p>关闭Redis服务</p>
<p><img src="/./redis-base/15.jpg"></p>
</li>
</ol>
<h2 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h2><p><strong>redis-benchmark</strong>是一个压力测试工具</p>
<p>官方自带的性能测试工具</p>
<p>redis-benchmark命令参数</p>
<p>图片来自菜鸟教程：</p>
<p><img src="/./redis-base/16.jpg"></p>
<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试：100个并发连接  100000请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br></pre></td></tr></table></figure>

<p><img src="/./redis-base/17.jpg"></p>
<p><img src="/./redis-base/18.jpg" alt="18"></p>
<p>如何查看这些分析呢？</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis默认有16个数据库</p>
<p><img src="/./redis-base/19.jpg"></p>
<p>默认使用的是第0个</p>
<p>可以使用select进行切换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos cconfig]<span class="comment"># redis-cli </span></span><br><span class="line">127.0.0.1:6379&gt; select 3   <span class="comment"># 切换数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; dbsize  <span class="comment"># 查看数据库大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p><img src="/./redis-base/20.jpg"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br></pre></td></tr></table></figure>

<p>清楚当前数据库flushdb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure>

<p>清楚全部数据库的内容FLUSHALL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; FLUSHALL</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379[3]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Redis是单线程的！</p>
</blockquote>
<p>Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就用单线程了。</p>
<p>Redis是C语言写的，官方提供的数据为100000+的QPS，完全不比同样是用于key-value的Memecache差。</p>
<p><strong>Redis为什么单线程还那么快？</strong></p>
<ol>
<li>误区1：高性能的服务器一定是多线程的？</li>
<li>误区2：多线程（CPU上下文会切换）一定比单线程效率高</li>
</ol>
<p>核心：redis是将多有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案。</p>
<h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><blockquote>
<p>官网文档</p>
</blockquote>
<p><img src="/./redis-base/21.jpg"></p>
<p>全段翻译：</p>
<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p>
<h2 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; FLUSHALL   <span class="comment"># 清空数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *   <span class="comment"># 查看所有的key</span></span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name codechen</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 25</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS name   <span class="comment"># 判断当前的key是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS name1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; move name 1   <span class="comment"># 移除当前的key</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name codechen</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;codechen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; EXPIRE name 10   <span class="comment"># 设置key的过期时间，单位是秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name   <span class="comment"># 查看当前key的剩余时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name codechen</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name   <span class="comment"># 查看当前key的数据类型</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> age</span><br><span class="line">string</span><br></pre></td></tr></table></figure>



<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 v1   <span class="comment"># 设置值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1   <span class="comment"># 获得值</span></span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; keys *   <span class="comment"># 获得所有的key</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;key1&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS key1   <span class="comment"># 判断key是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; APPEND key1 <span class="string">&quot;hello&quot;</span>   <span class="comment"># 追加字符串，如果当前key不存在，就相当于setkey</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN key1   <span class="comment"># 获取字符串的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; APPEND key1 <span class="string">&quot;codechen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 15</span><br><span class="line">127.0.0.1:6379&gt; STRLEN key1</span><br><span class="line">(<span class="built_in">integer</span>) 15</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1hellocodechen&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># i++</span></span><br><span class="line"><span class="comment"># 步长 i+=</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0   <span class="comment"># 初试浏览量0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr views   <span class="comment"># 自增1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr views   <span class="comment"># 自减1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBY views 10   <span class="comment"># 设置步长，指定增量</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; DECRBY views 10   <span class="comment"># 设置步长，指定减量</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串范围</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 <span class="string">&quot;hello,codechen&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;hello,codechen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 3   <span class="comment"># 截取字符串 [0,3]</span></span><br><span class="line"><span class="string">&quot;hell&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 -1   <span class="comment"># 获取全部的字符串 和 get key一样</span></span><br><span class="line"><span class="string">&quot;hello,codechen&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key2 abcdefg</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SETRANGE key2 1 xx   <span class="comment"># 替换指定位置开始的字符串</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;axxdefg&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># setex（set with expire）   # 设置过期时间</span></span><br><span class="line"><span class="comment"># setnx（set if not exist）  # 不存在再设置（在分布式锁中经常使用）</span></span><br><span class="line">127.0.0.1:6379&gt; setex key3 30 <span class="string">&quot;hello&quot;</span>   <span class="comment"># 设置key3的值为hello，30秒后过期</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) 22</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setnx mykey <span class="string">&quot;redis&quot;</span>   <span class="comment"># 如果们mykey不存在，创建mykey</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;mykey&quot;</span></span><br><span class="line">2) <span class="string">&quot;key2&quot;</span></span><br><span class="line">3) <span class="string">&quot;key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; setnx mykey <span class="string">&quot;MongoDB&quot;</span>   <span class="comment"># 如果没有可以存在，创建失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mset</span></span><br><span class="line"><span class="comment"># mget</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3   <span class="comment"># 同时设置多个值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3   <span class="comment"># 同时获取多个值</span></span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k4 v4   <span class="comment"># msetnx是一个原子性的操作，要么一起成功，要么一起失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="built_in">set</span> user:1&#123;name:zhangsan,age:3&#125;   <span class="comment"># 设置一个user:1对象值为json字符来保存一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125; ，如此设计在Redis中是完全ok的</span></span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age:2</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> MSET</span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># getset  先get再set</span></span><br><span class="line">127.0.0.1:6379&gt; getset db redis   <span class="comment"># 如果不存在值，则返回nil</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getset db mongdb   <span class="comment"># 如果存在值，获取原来的值，并设置新的值</span></span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;mongdb&quot;</span></span><br></pre></td></tr></table></figure>



<p>String类似的使用场景：value除了是我们的字符串还可以是我们的数字</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量</li>
<li>粉丝数</li>
<li>对象缓冲存储</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>基本的数据类型，列表</p>
<p><img src="/./redis-base/22.jpg"></p>
<p>在redis里，我们可以把list玩成栈、队列阻塞队列。</p>
<p>所有的list命令都是l开头的，redis不区分大小写命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##########################</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list one   <span class="comment"># 将一个或多个值插入到列表头部（左边）</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1   <span class="comment"># 获取list中的值</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 1   <span class="comment"># 通过区间获取具体的值</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Rpush list right   <span class="comment"># 将一个或多个值插入到列表尾部（右边）</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;right&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;right&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lpop list   <span class="comment"># 移除list的第一个元素</span></span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpop list   <span class="comment"># 移除list的最后一个元素</span></span><br><span class="line"><span class="string">&quot;right&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 1   <span class="comment"># 通过下标获取list的某一个值</span></span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 0   </span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; llen list   <span class="comment"># 返回列表长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################</span></span><br><span class="line">移除指定的值</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">4) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 one   <span class="comment"># 移除list集合中指定个数的value，精准匹配</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 three</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 three</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line">trim 修建</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello3&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 2   <span class="comment"># 通过下标截取指定的长度，这个list已经被改变了，截断只剩下窃取的元素</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line">rpoplpush   <span class="comment"># 移除列表的最后一个元素，将他移动到新的列表中</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; rpoplpush mylist myotherlist</span><br><span class="line"><span class="string">&quot;hello2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myotherlist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line">lset   <span class="comment"># 将列表中指定小标的值替换为另一个值，更新操作</span></span><br><span class="line">127.0.0.1:6379&gt; exists list</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item   <span class="comment"># 如果不存在列表我们去更新就会报错</span></span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lpush list value1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item   <span class="comment"># 如果存在，更新当前小标的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;item&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 1 other   <span class="comment"># 如果不存在，则会报错</span></span><br><span class="line">(error) ERR index out of range</span><br><span class="line"></span><br><span class="line"><span class="comment">#############################################</span></span><br><span class="line">linsert   <span class="comment"># 将某个具体的value插入到列表中某个元素的前面或者后面</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; linsert mylist before <span class="string">&quot;world&quot;</span> <span class="string">&quot;other&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;other&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; linsert mylist after <span class="string">&quot;world&quot;</span> <span class="string">&quot;new&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;other&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">4) <span class="string">&quot;new&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>实际上是一个链表</li>
<li>如果可以不存在，创建新的链表</li>
<li>如果可以存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在</li>
<li>在两边插入或者改动值，效率最高，中间元素，相对来说效率会低一点</li>
</ul>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>set中的值是不能重复的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span>   <span class="comment"># set集合中添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;codechen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;lovecodechen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset   <span class="comment"># 查看指定set的所有值</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;lovecodechen&quot;</span></span><br><span class="line">3) <span class="string">&quot;codechen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello   <span class="comment"># 判断某一个值是不是在set集合中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember myset world</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line">127.0.0.1:6379&gt; scard myset   <span class="comment"># 获取set集合中的内容元素个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment">###################################################</span></span><br><span class="line">rem</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; srem myset hello   <span class="comment"># 移除set集合中的指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;lovecodechen2&quot;</span></span><br><span class="line">2) <span class="string">&quot;lovecodechen&quot;</span></span><br><span class="line">3) <span class="string">&quot;codechen&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;lovecodechen2&quot;</span></span><br><span class="line">2) <span class="string">&quot;lovecodechen&quot;</span></span><br><span class="line">3) <span class="string">&quot;codechen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset   <span class="comment"># 随机抽选出一个元素</span></span><br><span class="line"><span class="string">&quot;lovecodechen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;codechen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;lovecodechen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;lovecodechen2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;codechen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2   <span class="comment"># 随机抽选出指定个数的元素</span></span><br><span class="line">1) <span class="string">&quot;lovecodechen2&quot;</span></span><br><span class="line">2) <span class="string">&quot;codechen&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;lovecodechen2&quot;</span></span><br><span class="line">2) <span class="string">&quot;lovecodechen&quot;</span></span><br><span class="line">3) <span class="string">&quot;codechen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset   <span class="comment"># 随机删除一些set集合中的元素</span></span><br><span class="line"><span class="string">&quot;codechen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line"><span class="string">&quot;lovecodechen2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;lovecodechen&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################</span></span><br><span class="line"><span class="comment"># 将一个指定的值，移动到另一个set集合中</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;codechen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 <span class="string">&quot;set2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 <span class="string">&quot;codechen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;world&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class="line">1) <span class="string">&quot;set2&quot;</span></span><br><span class="line">2) <span class="string">&quot;codechen&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line">微博，B站，共同关注（并集）</span><br><span class="line">数字集合类：</span><br><span class="line">	- 差集</span><br><span class="line">	- 交集</span><br><span class="line">	- 并集</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 d</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 e</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SDIFF key1 key2   <span class="comment"># 差集</span></span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER key1 key2   <span class="comment"># 交集  共同好友就可以这样实现</span></span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION key1 key2   <span class="comment"># 并集</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">3) <span class="string">&quot;d&quot;</span></span><br><span class="line">4) <span class="string">&quot;b&quot;</span></span><br><span class="line">5) <span class="string">&quot;e&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Map集合，key-Map（相当于key-（key-value））</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash field1 codechen   <span class="comment"># set一个具体key-value</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1</span><br><span class="line"><span class="string">&quot;codechen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field1 hello field2 world   <span class="comment"># set过个具体key-value</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash field1 field2   <span class="comment"># 获取多个字段值</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash   <span class="comment"># 获取全部</span></span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">4) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash field1   <span class="comment"># 删除hash指定key字段，对应value值也就消失了</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field2&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line">hlen</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field1 hello field2 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HGETALL myhash</span><br><span class="line">1) <span class="string">&quot;field&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;field1&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello&quot;</span></span><br><span class="line">5) <span class="string">&quot;field2&quot;</span></span><br><span class="line">6) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hlen myhash   <span class="comment"># 获取hash表</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash field1   <span class="comment"># 判断hash中指定字段是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash field3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment"># 只</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash  <span class="comment"># 只获取所有field</span></span><br><span class="line">1) <span class="string">&quot;field&quot;</span></span><br><span class="line">2) <span class="string">&quot;field1&quot;</span></span><br><span class="line">3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals myhash   <span class="comment"># 值获取所有value</span></span><br><span class="line">1) <span class="string">&quot;world&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line">incr decr</span><br><span class="line">127.0.0.1:6379&gt; hset myhash field3 5   <span class="comment"># 指定增量</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field3 1</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field3 -1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; hset myhash field4 hello   <span class="comment"># 如果不存在则可以设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash field4 world   <span class="comment"># 如果存在则不能设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>hash变更的数据 user name age，尤其是用户信息之类的，经常变动的信息，hash更适合于对象的存储，String更适合字符串存储</p>
<h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><p>在set的基础上，增加了一个值，set k1 v1  zset k1 score1 v1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myset 1 one   <span class="comment"># 添加一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 two 3 three   <span class="comment"># 添加多个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange myset 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">排序</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 zhangsan   <span class="comment"># 添加三个用户</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 500 wangwu</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># zrangebyscore key min max</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf   <span class="comment"># 显示全部用户 从小到大</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary +inf -inf</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores   <span class="comment"># 显示全部的用户并且附带成绩</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">5) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">6) <span class="string">&quot;5000&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1   <span class="comment"># 从大到小进行排序</span></span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">2) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf 2500 withscores   <span class="comment"># 显示工资小于2500员工的升序排序</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment"># 移除rem中的元素</span></span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem salary zhangsan   <span class="comment"># 移除有序集合中指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zcard salary   <span class="comment"># 获取有序集合中的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment">###################################################</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 world 3 codechen</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 3   <span class="comment"># 获取指定区间的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>



<h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h2 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h2><p>朋友的定位，附近的人，打车距离计算？</p>
<p>Redis的Geo在Redis3.2版本就推出了。这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！</p>
<blockquote>
<p>getadd</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># getadd 添加地理位置</span></span><br><span class="line"><span class="comment"># 规则：两极无法直接添加，我们一般会下载城市数据，直接通过程序一次性导入</span></span><br><span class="line"><span class="comment"># 参数key值</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 114.05 22.52 shenzhen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 108.96 34.26 xian</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>getpos</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city beijing   <span class="comment"># 获取指定城市的经度纬度</span></span><br><span class="line">1) 1) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geopos china:city chongqing</span><br><span class="line">1) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>deodist</p>
</blockquote>
<p>两人之间的距离</p>
<p>单位：</p>
<ul>
<li>m表示单位为米</li>
<li>km表示单位为千米</li>
<li>mi表示单位为英里</li>
<li>ft表示单位为英尺</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai</span><br><span class="line"><span class="string">&quot;1067378.7564&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai km</span><br><span class="line"><span class="string">&quot;1067.3788&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing chongqing km</span><br><span class="line"><span class="string">&quot;1464.0708&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>georadius</p>
</blockquote>
<p>找附近的人？（获得所有附近的人的地址，定位）通过半径来查询</p>
<p>获得指定数量的人</p>
<p>所有数据应该都录入：china:city，才会让结果更加清晰</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km   <span class="comment"># 以110,30这个经纬度为中心，寻找方圆1000km以内的城市</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist   <span class="comment"># 显示到中间距离的位置</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;341.9374&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;483.8340&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withcoord   <span class="comment"># 显示他人的定位信息</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withcoord count 1   <span class="comment"># 筛选出指定的结果</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>GEORADIUSBYMEMBER</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找出位于指定元素周围的其他元素</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km</span><br><span class="line">1) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shanghai 400 km</span><br><span class="line">1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">2) <span class="string">&quot;shanghai&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>DEOHASH命令-返回一个或多个位置元素的Geohash表示</p>
</blockquote>
<p>该命令将返回11个字符的Geohash字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近</span></span><br><span class="line">127.0.0.1:6379&gt; geohash china:city beijing chongqing</span><br><span class="line">1) <span class="string">&quot;wx4fbxxfke0&quot;</span></span><br><span class="line">2) <span class="string">&quot;wm5xzrybty0&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>geo底层的实现原理其实就是Zset，我们可以使用Zset命令操作Geo</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash china:city beijing chongqing</span><br><span class="line">1) <span class="string">&quot;wx4fbxxfke0&quot;</span></span><br><span class="line">2) <span class="string">&quot;wm5xzrybty0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city beijing   <span class="comment"># 移除指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1   <span class="comment"># 查看全部元素</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><blockquote>
<p>基数</p>
</blockquote>
<blockquote>
<p>简介</p>
</blockquote>
<p>Redis 2.8.9版本就更新了Hyperloglog数据结构</p>
<p>Redis Hyperloglog 基数统计的算法</p>
<p>优点：占用的内存是固定，2^64不同的元素的技术，只需要12kb内存，如果要从内存角度来比较的话Hyperloglog首选。</p>
<p><strong>网页的UV（一个人访问一个网站多次，但是还是算作一个人）</strong></p>
<p>传统的方式，set保存用户的id，然后就可以统计set中的元素数量作为标准判断</p>
<p>这个方式如果保存大量的用户id，就会比较麻烦，我们的目的是为了技术，而不是保存用户id；</p>
<p>0.81错误率！统计UV任务，可以忽略不计的</p>
<blockquote>
<p>测试使用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd mykey a b c d e f g h i j   <span class="comment"># 创建第一组元素mykey</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey   <span class="comment"># 统计mykey元素的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey2 i j z x c v b n m   <span class="comment"># 创建第二组元素mykey2</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey2</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2   <span class="comment"># 合并两组mykey mykey2 =》 mykey3 并集</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey3   <span class="comment"># 看并集的数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 15</span><br></pre></td></tr></table></figure>

<p>如果允许容错，那么一定可以使用Hyperloglog</p>
<p>如果不允许容错，就使用set或者自己的数据类型即可</p>
<h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><blockquote>
<p>位存储</p>
</blockquote>
<p>统计用户信息，活跃，不活跃！登录、未登录！打卡，365打卡！两个状态的，都可以使用Bitmaps！</p>
<p>Bitmaps位图，数据结构，都是操作二进制位来进行记录，就只有0和1</p>
<p>使用bitmap来记录周一到周日的打卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>查看某一天是否打卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 6</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>统计操作，统计打卡的天数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign   <span class="comment"># 统计这周的打卡记录</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>



<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！</p>
<p>一次性、顺序性、排他性！执行一系列的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">----- 队列 <span class="built_in">set</span> <span class="built_in">set</span> <span class="built_in">set</span> 执行 -----</span><br></pre></td></tr></table></figure>

<p>Redis事务没有隔离级别的概念</p>
<p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行</p>
<p>Redis单条命令是保存原子性的，但是事务不保证原子性的</p>
<p>redis的事务：</p>
<ul>
<li>开启事务（multi）</li>
<li>命令入队（其他命令）</li>
<li>执行事务（exec）</li>
</ul>
<blockquote>
<p>正常执行事务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi   <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>   <span class="comment"># 执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure>

<blockquote>
<p>放弃事务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; discard   <span class="comment"># 取消事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k4   <span class="comment"># 事务队列中的命令都不会被执行</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译型异常（代码有问题！命令有错），事务中所有的命令都不会被执行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; getset k3   <span class="comment"># 错误的命令</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;getset&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k5 v5</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>   <span class="comment"># 执行事务报错</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get k5   <span class="comment"># 所有的命令都不会被执行</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>运行时异常（1/0），如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 <span class="string">&quot;v1&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range   <span class="comment"># 虽然第一条命令报错了，但是依旧正常执行成功</span></span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>监控</p>
</blockquote>
<p>悲观锁：</p>
<ul>
<li>很悲观，认为什么时候都会出问题，无论做什么都会加锁</li>
</ul>
<p>乐观锁：</p>
<ul>
<li>很乐观，认为什么时候都不会出问题，所以不会上锁，更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
<blockquote>
<p>Redis监视测试</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money   <span class="comment"># 监视money对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi   <span class="comment"># 事务正常接受，数据期间没有发生变动，这个时候就正常执行成功</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure>

<p>测试多线程修改值，使用watch可以当做redis的乐观锁操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>   <span class="comment"># 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果修改失败，获取最新的值就好</span></span><br><span class="line">127.0.0.1:6379&gt; unwatch   <span class="comment"># 如果发现事务执行失败，就先解锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money   <span class="comment"># 获取最新的值，再次监控</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRBY money 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY money 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>   <span class="comment"># 对比监视的值，是否发生变化，如果没有变化，name可以执行成功，如果变了就执行失败</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 999</span><br><span class="line">2) (<span class="built_in">integer</span>) 1000</span><br></pre></td></tr></table></figure>



<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>使用Java来操作Redis</p>
<blockquote>
<p>什么是Jedis时候Redis官方推荐的java连接开发工具，使用Java操作Redis中间件，如果你要使用java操作redis，那么一定要对Jedis十分的熟悉</p>
</blockquote>
<h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><blockquote>
<p>单位</p>
</blockquote>
<p><img src="/./redis-base/23.jpg"></p>
<ol>
<li>配置文件unit单位对大小写不敏感</li>
</ol>
<blockquote>
<p>包含</p>
</blockquote>
<p><img src="/./redis-base/24.jpg"></p>
<p>可以把多个配置文件配置过来</p>
<blockquote>
<p>网络</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1 -::1   <span class="comment"># 绑定的ip</span></span><br><span class="line"></span><br><span class="line">protected-mode yes   <span class="comment"># 保护模式</span></span><br><span class="line"></span><br><span class="line">port 6379   <span class="comment"># 端口设置</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通用GENERAL</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">daemonize yes   <span class="comment"># 以守护进程的方式运行，默认是no，需要手动配置为yes</span></span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis_6379.pid   <span class="comment"># 如果以后台的方式运行，我们就需要指定一个pid文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="comment"># Specify the server verbosity level.</span></span><br><span class="line"><span class="comment"># This can be one of:</span></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice</span><br><span class="line">logfile <span class="string">&quot;&quot;</span>   <span class="comment"># 日志的文件位置名</span></span><br><span class="line">databases 16   <span class="comment"># 数据库的数量，默认是16个数据库</span></span><br><span class="line">always-show-logo no   <span class="comment"># 是否显示logo</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>快照SNAPSHOTTING</p>
</blockquote>
<p>持久化，在规定的时间内，执行多少次操作，则会持久化到文件</p>
<p>Redis是内存数据库，如果没有持久化，那么数据断电即失！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果3600内，如果至少有1个key进行了修改，我们就进行持久化操作</span></span><br><span class="line"><span class="comment"># save 3600 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果300内，如果至少100个key进行了修改，我们就进行持久化操作</span></span><br><span class="line"><span class="comment"># save 300 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果60内，如果至少10000个key进行了修改，我们就进行持久化操作</span></span><br><span class="line"><span class="comment"># save 60 10000</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes   <span class="comment"># 持久化如果出错，是否需要继续工作</span></span><br><span class="line"></span><br><span class="line">rdbcompression yes   <span class="comment"># 是否压缩rdb文件，需要消耗一些cpu资源</span></span><br><span class="line"></span><br><span class="line">rdbchecksum yes   <span class="comment"># 保存rdb文件时，进行错误的检查校验</span></span><br><span class="line"></span><br><span class="line">dir ./   <span class="comment"># rdb保存的目录</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>REPLICATION复制</p>
</blockquote>
<blockquote>
<p>SECURITY</p>
</blockquote>
<p>可以在这里设置redis的密码，默认是没有密码的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get requirepass   <span class="comment"># 获取密码</span></span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass <span class="string">&quot;123456&quot;</span>   <span class="comment"># 设置密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>限制CLIENTS</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">maxclients 10000   <span class="comment"># 默认最大客户端数量</span></span><br><span class="line">maxmemory &lt;bytes&gt;   <span class="comment"># Redis配置最大的内存容量</span></span><br><span class="line">maxmemory-policy noeviction   <span class="comment"># 内存达到上限之后的处理策略</span></span><br><span class="line">	1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） </span><br><span class="line">    2、allkeys-lru ： 删除lru算法的key   </span><br><span class="line">    3、volatile-random：随机删除即将过期key   </span><br><span class="line">    4、allkeys-random：随机删除   </span><br><span class="line">    5、volatile-ttl ： 删除即将过期的   </span><br><span class="line">    6、noeviction ： 永不过期，返回错误	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>APPEND ONLY 模式   aof配置</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly no   <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span>   <span class="comment"># 持久化的文件名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always   # 每次修改都会sync，消耗性能</span></span><br><span class="line">appendfsync everysec   <span class="comment"># 每秒执行一次sync，可能会丢失这个ls的数据</span></span><br><span class="line"><span class="comment"># appendfsync no       # 不执行sync，这个时候操作系统自己同步数据，速度最快</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>面试和工作，持久化都是重点!</p>
<p>Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失，。所以Redis提供了持久化功能</p>
<h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><blockquote>
<p>什么是RDB</p>
</blockquote>
<p><img src="/./redis-base/25.jpg"></p>
<p>在指定的时间间隔呢内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<p>Redis会单独创建（fork）一个子进程类进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置。</p>
<p><strong>RDB配置保存的是dump.rdb</strong>，都是在我们的配置文件中快照中进行配置的</p>
<p><img src="/./redis-base/26.jpg"></p>
<p><img src="/./redis-base/27.jpg"></p>
<blockquote>
<p>触发机制</p>
</blockquote>
<ol>
<li>save的规则满足的情况下，会自动触发rdb规则</li>
<li>执行flushall命令，也会触发我们的rdb规则</li>
<li>退出redis，也会产生rdb文件</li>
</ol>
<p>备份就会自动生成一个dump.rdb</p>
<blockquote>
<p>恢复rdb文件</p>
</blockquote>
<ol>
<li>只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb恢复其中的数据</li>
<li>查看需要存放的位置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/bin&quot;</span>   <span class="comment"># 如果在这个目录下存在dump.rdb文件，启动就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性不高</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要一定的时间间隔进程操作，如果redis意外宕机了，这个最后一次修改数据就没有了</li>
<li>fork进程的时候，会占用一定的内容空间</li>
</ul>
<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍！</p>
<blockquote>
<p>是什么</p>
</blockquote>
<p><img src="/./redis-base/28.jpg"></p>
<p>以日志的形式来记录每个写操作，将Redis执行过程的所有指令都记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p><strong>Aof保存的是appendonly.aof文件</strong></p>
<blockquote>
<p>append</p>
</blockquote>
<p><img src="/./redis-base/29.jpg"></p>
<p>默认是不开启的，需要手动改成yes</p>
<p>重启，redis就可以生效了</p>
<p>优点：</p>
<ul>
<li>每次修改都同步，文件的完整或更好</li>
<li>每秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步，效率最高的</li>
</ul>
<p>缺点：</p>
<ul>
<li>相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢</li>
<li>aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li>
</ul>
<p>扩展：</p>
<ol>
<li>RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</li>
<li>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不适用任何持久化</li>
<li>同时开启两种持久化方式<ul>
<li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段</li>
</ul>
</li>
<li>性能建议<ul>
<li>因为RDB文件只用做后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则</li>
<li>如果Enable AOF，好处是在最恶情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一式带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值</li>
<li>如果不Enable AOF，仅靠Master-Slave Replication实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB问文件，载入新的那个，微博就是这种架构。</li>
</ul>
</li>
</ol>
<h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p>Redis发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接受消息。</p>
<p>Redis客户端可以订阅任意数量的频道</p>
<p>订阅/发布消息图：</p>
<p>第一个：消息发送者；第二个：频道；第三个：消息订阅者</p>
<p><img src="/./redis-base/30.jpg"></p>
<p>下图展示了频道channel1，以及订阅这个频道的三个客户端——client2、client5和client1之间的关系：</p>
<p><img src="/./redis-base/31.jpg"></p>
<p>当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="/./redis-base/32.jpg" alt="32"></p>
<blockquote>
<p>命令</p>
</blockquote>
<p>这些命令被广泛用于构建即时通信应用，比如网络聊天室（chatroom）和实时广播、实时提醒等。</p>
<p><img src="/./redis-base/33.jpg"></p>
<blockquote>
<p>测试</p>
</blockquote>
<p>订阅端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE codechen   <span class="comment"># 订阅一个频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;codechen&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待读取推送的消息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;codechen&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello,codechen&quot;</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;codechen&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello,redis&quot;</span></span><br></pre></td></tr></table></figure>

<p>发送端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH codechen <span class="string">&quot;hello,codechen&quot;</span>   <span class="comment"># 发布者发布消息到频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH codechen <span class="string">&quot;hello,redis&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理</p>
</blockquote>
<p>Redis是使用C实现的，通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现，籍此加深对Redis的理解。</p>
<p>Redis通过PUBLISH 、SUBSCRIBE和PSUBSCRIBE等命令实现发布和订阅功能。</p>
<p>通过SUBSCRIBE命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个channel，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE命令的关键，就是将客户端添加到给定 channel 的订阅链表中。</p>
<p>通过PUBLISH命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p>
<p>Pub/Sub从字面上理解就是发布( Publish )与订阅(Subscribe )，在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<blockquote>
<p>使用场景</p>
</blockquote>
<ul>
<li>实时消息系统</li>
<li>实时聊天（频道当做聊天室，将消息显示给所有人即可）</li>
<li>订阅，关注系统都是可以的</li>
</ul>
<p>稍微复杂的场景我们就会使用消息中间件MQ</p>
<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；<strong>数据的复制是单向的，只能由主节点到从节点。</strong>Master以写为主，Slave以读为主。</p>
<p><strong>默认情况下，每台Redis服务器都是主节点</strong>；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<p><strong>主从复制的作用主要包括:</strong></p>
<ol>
<li>数据冗余︰主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复∶当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。</li>
<li>负载均衡︰在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载;尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用（集群）基石∶除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ol>
<p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下︰</p>
<ol>
<li><p>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大;</p>
</li>
<li><p>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，<strong>单台Redis最大使用内存不应该超过20G</strong>。</p>
</li>
</ol>
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
<p>对于这种场景，我们可以使用如下架构（一主三从）：</p>
<p><img src="/./redis-base/34.jpg"></p>
<p>主从复制，读写分离！80%的情况下都是在进行读操作！减缓服务器的压力，架构中经常使用，一主二从。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>只配置从库，不配置主库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication   <span class="comment"># 查看当前库的信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master   <span class="comment"># 角色 master</span></span><br><span class="line">connected_slaves:0   <span class="comment"># 没有从机</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:b8141a09033161c9584c3f34bf20c3aa0bee07fa</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>

<p>复制3个配置文件，然后修改对应的信息</p>
<ul>
<li>端口</li>
<li>pid名字</li>
<li>log文件名字</li>
<li>dump.rdb名字</li>
</ul>
<p><img src="/./redis-base/35.jpg"></p>
<p>修改后，启动三个redis服务器，通过进程查看。</p>
<h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><p><strong>默认情况下，每台Redis服务器都是主节点</strong>；我们一般情况下只用配置从机就好了</p>
<p>一主（79）二从（80,81）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379   <span class="comment"># SLAVEOF host 6379 </span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave   <span class="comment"># 从机</span></span><br><span class="line">master_host:127.0.0.1   <span class="comment"># 可以看到主机的信息</span></span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:2</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:14</span><br><span class="line">slave_repl_offset:14</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:93a581049167b5e51ecccf7135105e4235cad660</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:14</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主机中查看信息</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1   <span class="comment"># 多了从机配置</span></span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=42,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:93a581049167b5e51ecccf7135105e4235cad660</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:42</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:42</span><br></pre></td></tr></table></figure>

<p><img src="/./redis-base/36.jpg"></p>
<p>真实的主从配置应该在配置文件中配置，这样才是永久的，命令配置是临时的。</p>
<blockquote>
<p>细节</p>
</blockquote>
<p>主机可以学，从机不能写，只能读。主机中的所有信息和数据，都会自动被从机保存！</p>
<p>主机写：</p>
<p><img src="/./redis-base/37.jpg"></p>
<p>从机只能读取内容：</p>
<p><img src="/./redis-base/38.jpg" alt="38"></p>
<p>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！</p>
<p>如果是使用命令行配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！</p>
<blockquote>
<p>复制原理</p>
</blockquote>
<p>Slave启动成功连接到master后会发送一个sync同步命令</p>
<p>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<strong>master将传送整个数据文件到slave，并完成一次完全同步。</strong></p>
<p><strong>全量复制：</strong>而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p><strong>增量复制：</strong>Master继续将新的所有收集到的修改命令依次传给slave，完成同步</p>
<p>但是只要是重新连接master，一次完全同步（全量复制)将被自动执行</p>
<blockquote>
<p>层层链路</p>
</blockquote>
<p>上一个M连接下一个S</p>
<p><img src="/./redis-base/39.jpg"></p>
<p>这个也可以完成我们的主从复制</p>
<blockquote>
<p>如果没有老大了，这个时候能不能选择一个老大出来呢？</p>
</blockquote>
<p>谋朝篡位</p>
<p>如果主机断开了连接，我们可以使用 SLAVEOF NO ONE让自己成为主机，其他的节点就可以手动连接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>（自动选举老大的模式）</p>
<blockquote>
<p>概述</p>
</blockquote>
<p>主从切换技术的方法是∶当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel (哨兵）架构来解决这个问题。</p>
<p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数<strong>自动将从库转换为主库</strong>。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p>
<p><img src="/./redis-base/40.jpg"></p>
<p>这里的哨兵有两个作用</p>
<ul>
<li><p>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</p>
</li>
<li><p>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</p>
</li>
</ul>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<p><img src="/./redis-base/41.jpg"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称劝<strong>客观下线</strong>。</p>
<blockquote>
<p>测试</p>
</blockquote>
<p>目前是一主二从</p>
<ol>
<li><p>配置哨兵配置文件sentinel.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 1</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>

<p>后面的这个数字1，代表主机挂了，slave投票决定让谁接替成为主机。</p>
</li>
<li><p>启动哨兵</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos cconfig]<span class="comment"># redis-sentinel sentinel.conf </span></span><br><span class="line">3512:X 21 Jan 2022 11:28:36.611 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">3512:X 21 Jan 2022 11:28:36.611 <span class="comment"># Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=3512, just started</span></span><br><span class="line">3512:X 21 Jan 2022 11:28:36.611 <span class="comment"># Configuration loaded</span></span><br><span class="line">3512:X 21 Jan 2022 11:28:36.612 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._                                             </span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis 6.2.6 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```//    _.,_ <span class="string">&#x27;&#x27;</span>-._                                  </span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 3512</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           https://redis.io       </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |                                  </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>                                       </span><br><span class="line">          `-._        _.-<span class="string">&#x27;                                           </span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span>                                               </span><br><span class="line"></span><br><span class="line">3512:X 21 Jan 2022 11:28:36.612 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">3512:X 21 Jan 2022 11:28:36.617 <span class="comment"># Sentinel ID is 5f209051b2d5198664598db2478727744ac941c0</span></span><br><span class="line">3512:X 21 Jan 2022 11:28:36.617 <span class="comment"># +monitor master myredis 127.0.0.1 6379 quorum 1</span></span><br><span class="line">3512:X 21 Jan 2022 11:28:36.618 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379</span><br><span class="line">3512:X 21 Jan 2022 11:28:36.622 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p>如果master节点断开了，这个时候会从从机中随机选择一个服务器（有一个投票算法）</p>
<p><img src="/./redis-base/42.jpg"></p>
</li>
</ol>
<p>哨兵日志：</p>
<p><img src="/./redis-base/43.jpg"></p>
<p>如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！</p>
<blockquote>
<p>哨兵模式</p>
</blockquote>
<p>优点：</p>
<ol>
<li>哨兵集群，基于主从复制模型，所有的主从配置优点，它全有</li>
<li>主从可以切换，故障可以转移，系统的可用性就会更好</li>
<li>哨兵模式就是主从模式的升级，手动到自动，更加健壮</li>
</ol>
<p>缺点：</p>
<ol>
<li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择</li>
</ol>
<blockquote>
<p>哨兵模式的全部配置</p>
</blockquote>
<h1 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h1><p>在这里我们不会详细的区分析解决方案的底层，(专题)</p>
<p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p>
<p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>布隆过滤器</strong></p>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力;</p>
<p><img src="/./redis-base/44.jpg"></p>
<p><strong>缓存空对象</strong></p>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p>
<p><img src="/./redis-base/45.jpg"></p>
<p>但是这种方法会存在两个问题:</p>
<p>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键;</p>
<p>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<h2 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h2><blockquote>
<p>概述</p>
</blockquote>
<p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞</p>
<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。</p>
<p><strong>加互斥锁</strong></p>
<p>分布式锁︰使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis宕机！</p>
<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p><img src="/./redis-base/46.jpg"></p>
<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>redis高可用</strong></p>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台reds，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。</p>
<p><strong>限流降级</strong></p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p><strong>数据预热</strong></p>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<p>学习视频：</p>
<p><a href="https://www.bilibili.com/video/BV1S54y1R7SB?p=1">https://www.bilibili.com/video/BV1S54y1R7SB?p=1</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手</title>
    <url>/TCP-ThreeHandshakes/</url>
    <content><![CDATA[<h1>什么是TCP？</h1>
<p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>TCP旨在适应支持多网络应用的分层协议层次结构。 连接到不同但互连的计算机通信网络的主计算机中的成对进程之间依靠TCP提供可靠的通信服务。TCP假设它可以从较低级别的协议获得简单的，可能不可靠的数据报服务。 原则上，TCP应该能够在从硬线连接到分组交换或电路交换网络的各种通信系统之上操作。</p>
<p><strong>TCP运输连接有一下三个阶段：</strong></p>
<ul>
<li>建立TCP连接：通过三报文建立TCP连接；</li>
<li>数据传输：基于已建立的TCP连接进行可靠的数据传输；</li>
<li>关闭连接：数据传输结束后，通过四报文来释放TCP连接。</li>
</ul>
<h1>TCP首部格式</h1>
<p><img src="/./TCP-ThreeHandshakes/2964446-ab077ff3902529a3.webp" alt></p>
<p><strong>源端口:</strong> 占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程。<br>
<strong>目的端口:</strong> 占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程。</p>
<p><strong>序号:</strong> 占32比特，取值范围[0, 2^32-1]，序号增加到最后一个后，下一个序号就又回到0。指出本TCP报文段数据载荷的第一个字节的序号</p>
<p><strong>确认号:</strong> 占32比特，取值范围[0,2^32-1]，确认号增加到最后一个后，下一个确认号就又回到0。指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。若确认号=n，则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据。</p>
<p><strong>确认标志位ACK：</strong> 取值为1时确认号字段才有效；取值为0时确认号字段无效。TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1。</p>
<p><strong>数据偏移：</strong> 占4比特，并以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际上是指出了TCP报文段的首部长度。</p>
<p><strong>窗口：</strong> 占16比特，以字节为单位。指出发送本报文段的一方的接收窗。</p>
<p><strong>同步标志位SYN：</strong> 在TCP连接建立时用来同步序号。</p>
<p><strong>终止标志位FIN：</strong> 用来释放TCP连接。</p>
<p><strong>复位标志位RST：</strong> 用来复位TCP连接。</p>
<p><strong>推送标志位PSH：</strong> 接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付。</p>
<p><strong>校验和：</strong> 占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</p>
<p><strong>紧急指针：</strong> 占16比特，以字节为单位，用来指明紧急数据的长度。</p>
<p><strong>填充：</strong> 由于选项的长度可变，因此使用填充来确保报文段首部能被4整除，(因为数据偏移字段，也就是首部长度字段，是以4字节为单位的)。</p>
<h1>TCP的连接建立</h1>
<p>TCP 建立连接的过程叫做<strong>握手</strong>，握手需要在客户和服务器之间交换三个TCP 报文段，称之为<strong>三报文握手</strong>，采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</p>
<p><strong>三次握手过程：</strong></p>
<p>1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
<p>（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
<p>（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
<p><img src="/./TCP-ThreeHandshakes/2964446-aa923712d5218eeb.webp" alt></p>
<p><strong>TCP的连接建立要解决以下三个问题：</strong></p>
<ul>
<li>使TCP双方能够确知对方的存在</li>
<li>使TCP双方能够协商一些参数</li>
<li>使TCP双方能够对运输实体资源进行分配</li>
</ul>
<h1>三次握手总结</h1>
<p>三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p>
<p><strong>① 首先客户端向服务器发送一个 SYN 包，并等待服务器确认</strong>，其中：</p>
<ul>
<li>标志位为 SYN，表示请求建立连接；</li>
<li>序号为 Seq = x（x 一般取随机数）；</li>
<li>随后客户端进入 SYN-SENT 阶段。</li>
</ul>
<p><strong>② 服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文</strong>，其中：</p>
<ul>
<li>标志位为 SYN 和 ACK，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；</li>
<li>序号为 Seq = y；</li>
<li>确认号为 Ack = x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，随后服务器端进入 SYN-RECV 阶段。</li>
</ul>
<p>**③ 客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文。**其中：</p>
<ul>
<li>标志位为 ACK，表示确认收到服务器端同意连接的信号；</li>
<li>序号为 Seq = x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；</li>
<li>确认号为 Ack= y + 1，表示收到服务器端序号 seq，并将其值加 1 作为自己的确认号 Ack 的值。</li>
<li>随后客户端进入 ESTABLISHED。</li>
</ul>
<p>当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。</p>
<h1>是否可以使用“两报文握手”建立连接？</h1>
<p><strong>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？</strong></p>
<p>考虑这样一种情况，TCP客户进程发出一个TCP连接请求报文段，但该报文段在某些网络节点长时间滞留了，这必然会造成该报文段的超时重传。假设重传的报文段被TCP服务器进程正常接收，TCP服务器进程给TCP客户进程发送一个TCP连接请求确认报文段，并进入连接已建立状态。</p>
<img src="/./TCP-ThreeHandshakes/1645172698-plyoRW-image-20220218150759628.png" style="zoom: 50%;">
<p>请注意: 由于我们改为两报文握手，因此TCP服务器进程发送完TCP连接请求确认报文段后，进入的是<strong>连接已建立状态</strong>，而不像三报文握手那样进入同步已接收状态，TCP服务器进程并等待TCP客户进程发来针对TCP连接请求确认报文段的普通确认报文段。</p>
<p>TCP客户进程收到TCP连接请求确认报文段后进入TCP<strong>连接已建立状态</strong>，但不会给TCP服务器进程发送针对该报文段的普通确认报文段。</p>
<p><strong>现在，TCP双方都处于连接已建立状态，他们可以相互传输数据，之后可以通过四报文挥手来释放连接，TCP双方都进入了关闭状态。</strong></p>
<img src="/./TCP-ThreeHandshakes/1645172759-bFIvVT-image-20220218151153736.png" style="zoom:50%;">
<p>一段时间后，之前滞留在网络中的那个失效的TCP连接请求报文段到达了TCP服务器进程，TCP 服务器进程会误认为这是TCP客户进程又发起了一个新的TCP连接请求，于是给TCP客户进程发送TCP连接请求确认报文段并进入连接已建立状态。该报文段到达TCP客户进程，由于TCP客户进程并没有发起新的TCP连接请求，并且处于关闭状态，因此不会理会该报文段。</p>
<p>但TCP服务器进程已进入了连接已建立状态，他认为新的TCP连接已建立好了，并一直等待TCP客户进程发来数据。<strong>这将白白浪费TCP服务器进程所在主机的很多资源。</strong></p>
<p><strong>综上所述，采用三报文握手，而不是两报文握手来建立TCP连接，是为了防止已失效的连接请求报文段突然又传送到了TCP服务器进程因而导致错误。</strong></p>
<p><strong>总结：</strong></p>
<p>三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。</p>
<p>我们知道网络往往是非理想状态的（存在丢包和延迟），当客户端发起创建连接的请求时，如果服务器直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直接收不到返回的数据包。</p>
<p>由于客户端可能设置了一个超时时间，一段时间后就关闭了连接建立的请求，再重新发起新的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，服务器端的端口就会一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。长此以往， 这样的端口越来越多，就会造成服务器开销的浪费。</p>
<p>部分图文来自：</p>
<p>作者：林深时见鹿<br>
链接：<a href="https://leetcode-cn.com/circle/discuss/Db0Oab/">https://leetcode-cn.com/circle/discuss/Db0Oab/</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-advanced</title>
    <url>/docker-advanced/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>Docker Compose轻松高效的管理容器。</p>
<p>作用：批量容器编排</p>
<p>Compose是Docker官方的开源项目。需要安装</p>
<p>docker-compose up 100个服务</p>
<p>Compose：重要的概念</p>
<ul>
<li>服务services，容器，应用（web、redis、mysql…）</li>
<li>项目project。一组关联的容器。（博客。web、mysql等等）</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这个可能有点慢</span></span><br><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 换这个</span></span><br><span class="line">sudo curl -L &quot;https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>2、授权</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>3、查看安装是否成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control bin]# docker-compose version</span><br><span class="line">docker-compose version 1.25.5, build 8a1c60f6</span><br><span class="line">docker-py version: 4.1.0</span><br><span class="line">CPython version: 3.7.5</span><br><span class="line">OpenSSL version: OpenSSL 1.1.0l  10 Sep 2019</span><br></pre></td></tr></table></figure>



<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>官网：<a href="https://docs.docker.com/compose/gettingstarted/">Get started with Docker Compose | Docker Documentation</a></p>
<p>1、创建一个项目文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir composetest</span><br><span class="line">cd composetest</span><br></pre></td></tr></table></figure>

<p>2、在文件夹中创建一个app.py文件，内容如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">import redis</span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=&#x27;redis&#x27;, port=6379)</span><br><span class="line"></span><br><span class="line">def get_hit_count():</span><br><span class="line">    retries = 5</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            return cache.incr(&#x27;hits&#x27;)</span><br><span class="line">        except redis.exceptions.ConnectionError as exc:</span><br><span class="line">            if retries == 0:</span><br><span class="line">                raise exc</span><br><span class="line">            retries -= 1</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def hello():</span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    return &#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;.format(count)</span><br></pre></td></tr></table></figure>

<p>3、创建一个Dockerfile文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> syntax=docker/dockerfile:1</span></span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP=app.py</span><br><span class="line">ENV FLASK_RUN_HOST=0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">EXPOSE 5000</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure>

<p>4、在compose文件中定义服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version: &quot;3.9&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:5000&quot;</span><br><span class="line">  redis:</span><br><span class="line">    image: &quot;redis:alpine&quot;</span><br></pre></td></tr></table></figure>

<p>5、构建、启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>





<h2 id="yaml规则"><a href="#yaml规则" class="headerlink" title="yaml规则"></a>yaml规则</h2><p>docker-compose.yaml 核心</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">3层!</span></span><br><span class="line"></span><br><span class="line">version: &#x27;&#x27;   #版本</span><br><span class="line">services :   #服务</span><br><span class="line">  服务1: web</span><br><span class="line">    #服务配置</span><br><span class="line">    images</span><br><span class="line">    build</span><br><span class="line">    network</span><br><span class="line">    ……</span><br><span class="line">  服务2: redis</span><br><span class="line">  ……</span><br><span class="line">  服务3: redis</span><br><span class="line"><span class="meta">#</span><span class="bash">其他配置网络/卷、全局规则</span></span><br><span class="line">volumes:</span><br><span class="line">networks:</span><br><span class="line">configs :</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ansible基础</title>
    <url>/ansible-base/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>主机列表</p>
<table>
<thead>
<tr>
<th>主机名</th>
<th>IP地址</th>
<th>角色</th>
</tr>
</thead>
<tbody><tr>
<td>control</td>
<td>192.168.4.253</td>
<td>控制节点（manager）</td>
</tr>
<tr>
<td>Node1</td>
<td>192.168.4.1</td>
<td>被控制节点（test）</td>
</tr>
<tr>
<td>Node2</td>
<td>192.168.4.2</td>
<td>被控制节点（proxy）</td>
</tr>
<tr>
<td>Node3</td>
<td>192.168.4.3</td>
<td>被控制节点（web1）</td>
</tr>
<tr>
<td>Node4</td>
<td>192.168.4.4</td>
<td>被控制节点（web2）</td>
</tr>
<tr>
<td>Node5</td>
<td>192.168.4.5</td>
<td>被控制节点（database）</td>
</tr>
</tbody></table>
<p>1 修改控制主机的/etc/hosts文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ~]# cat /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.31.162 control</span><br><span class="line">192.168.31.26  node1</span><br><span class="line">192.168.31.208 node2</span><br><span class="line">192.168.31.248 node3</span><br><span class="line">192.168.31.217 node4</span><br><span class="line">192.168.31.165 node5</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样就可以直接ping node1</span></span><br></pre></td></tr></table></figure>

<p>2 修改控制主机的/etc/hosts、配置SSH密钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ~]# ssh-keygen -f /root/.ssh/id_rsa -N &#x27;&#x27;</span><br><span class="line">[root@MiWiFi-R1CL-srv ~]# for i in node1 node3  # 只开启了两台节点</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">do</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     ssh-copy-id <span class="variable">$i</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">done</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此后，就可以直接ssh node1连接其他节点，无密码连接</span></span><br></pre></td></tr></table></figure>

<p>3 控制端安装ansible</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install ansible</span><br></pre></td></tr></table></figure>



<p>4 被控制端节点操作</p>
<ul>
<li>ansible默认通过ssh协议管理机器</li>
<li>被管理主机要开启ssh服务，并允许控制主机登录</li>
<li>被管理主机需要安装有python</li>
</ul>
<p>5 修改配置文件</p>
<ul>
<li><p>主配置文件ansible.cfg（/etc/ansible/ansible.cfg）</p>
</li>
<li><p>ansible配置文件查找顺序</p>
<ul>
<li>首先检测ANSIBLE_CONFIG变量定义的配置文件</li>
<li>首次检查当前目录的./absible.cfg文件</li>
<li>再次检查当前用户家目录下~/ansible.cfg文件</li>
<li>最后检查/etc/ansible/ansible.cfg文件</li>
</ul>
</li>
<li><p>建议，在用户家目录创建配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ~]# mkdir ~/ansible</span><br><span class="line">[root@MiWiFi-R1CL-srv ~]# vim ~/ansible/ansible.cfg</span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# cat ansible.cfg </span><br><span class="line">[defaults]</span><br><span class="line">inventory = ~/ansible/hosts</span><br></pre></td></tr></table></figure></li>
<li><p>将被管理端主机写入一个主机列表文件（主机清单）</p>
<p>参考/etc/ansible/hosts</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ansible]# vim ~/ansible/hosts</span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# cat ~/ansible/hosts</span><br><span class="line">[test]</span><br><span class="line">node1</span><br><span class="line">[proxy]</span><br><span class="line">node2</span><br><span class="line">[webserver]</span><br><span class="line">node3</span><br><span class="line">node4</span><br><span class="line">[database]</span><br><span class="line">node5</span><br><span class="line">[cluster:children]</span><br><span class="line">webserver</span><br><span class="line">database</span><br></pre></td></tr></table></figure></li>
<li><p>测试ansible环境与配置是否正常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible all --list-hosts</span><br><span class="line">  hosts (5):</span><br><span class="line">    node2</span><br><span class="line">    node1</span><br><span class="line">    node3</span><br><span class="line">    node4</span><br><span class="line">    node5</span><br><span class="line">    </span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible node1 -m ping</span><br><span class="line">node1 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible node1,node2,node3 -m ping</span><br><span class="line">node3 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">node1 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">node2 | UNREACHABLE! =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;msg&quot;: &quot;Failed to connect to the host via ssh: ssh: connect to host node2 port 22: No route to host&quot;, </span><br><span class="line">    &quot;unreachable&quot;: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible webserver -m ping</span><br><span class="line">node4 | UNREACHABLE! =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;msg&quot;: &quot;Failed to connect to the host via ssh: ssh: Could not resolve hostname node4: Name or service not known&quot;, </span><br><span class="line">    &quot;unreachable&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">node3 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="ansible-ad-hoc"><a href="#ansible-ad-hoc" class="headerlink" title="ansible ad-hoc"></a>ansible ad-hoc</h1><p>Ansible ad-hoc是一种通过命令行批量管理的方式</p>
<ul>
<li>格式: ansible 主机集合-m模块名-a “参数”</li>
<li>其他参数: <ul>
<li>-k 使用密码远程</li>
<li>-i 指定主机列表文件</li>
</ul>
</li>
</ul>
<ul>
<li>模块就是脚本（多数为python脚本）<ul>
<li>多数脚本都支持参数</li>
<li>默认模块为command</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible node1 -m command -a &#x27;uptime&#x27;</span><br><span class="line">node1 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line"> 15:49:13 up 25 min,  2 users,  load average: 0.01, 0.03, 0.05</span><br><span class="line"> </span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible node1 -m command -a &#x27;uname -r&#x27;</span><br><span class="line">node1 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">3.10.0-1160.59.1.el7.x86_64</span><br><span class="line"></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible node1 -a &#x27;ip a s&#x27;</span><br><span class="line">node1 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:1b:77:65 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.31.26/24 brd 192.168.31.255 scope global noprefixroute dynamic ens33</span><br><span class="line">       valid_lft 41663sec preferred_lft 41663sec</span><br><span class="line">    inet6 fe80::5e91:f1e8:6f7a:b159/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:1f:76:c2 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:1f:76:c2 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    </span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -a &#x27;date&#x27;</span><br><span class="line">node1 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">2022年 03月 19日 星期六 15:50:20 CST</span><br><span class="line"></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible node1 -m command -a &#x27;uptime&#x27;</span><br><span class="line">node1 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line"> 15:52:17 up 28 min,  2 users,  load average: 0.00, 0.01, 0.05</span><br></pre></td></tr></table></figure>



<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote>
<p>// 列出所有模块</p>
<p>ansible-doc -l</p>
<p>// 过滤模块</p>
<p>ansible-doc -l |grep yum</p>
<p>// 查看模块帮助</p>
<p>ansible-doc yum </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看安装的模块</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible-doc -l</span><br><span class="line">fortios_router_community_list                                 Configure commun...</span><br><span class="line">azure_rm_devtestlab_info                                      Get Azure DevTes...</span><br><span class="line">ecs_taskdefinition                                            register a task ...</span><br><span class="line">avi_alertscriptconfig                                         Module for setup...</span><br><span class="line">tower_receive                                                 Receive assets f...</span><br><span class="line">netapp_e_iscsi_target                                         NetApp E-Series ...</span><br><span class="line">azure_rm_acs                                                  Manage an Azure ...</span><br><span class="line">fortios_log_syslogd2_filter                                   Filters for remo...</span><br><span class="line">junos_rpc                                                     Runs an arbitrar...</span><br><span class="line">na_elementsw_vlan                                             NetApp Element S...</span><br><span class="line">pn_ospf                                                       CLI command to a...</span><br><span class="line">pn_snmp_vacm                                                  CLI command to c...</span><br><span class="line">cp_mgmt_service_sctp                                          Manages service-...</span><br><span class="line">onyx_ospf                                                     Manage OSPF prot...</span><br><span class="line">icx_command                                                   Run arbitrary co...</span><br><span class="line">cs_snapshot_policy                                            Manages volume s...</span><br><span class="line">nxos_install_os                                               Set boot options...</span><br><span class="line">cnos_static_route                                             Manage static IP...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看总共的模块数</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible-doc -l | wc -l</span><br><span class="line">3387</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="shell模块"><a href="#shell模块" class="headerlink" title="shell模块"></a>shell模块</h2><blockquote>
<p><strong>command和shell模块的区别</strong></p>
<ul>
<li>command模块的命令不启动shell,直接通过ssh执行命令</li>
<li>command不支持bash的特性，如管道和重定向等功能</li>
<li>所有需要调用shell的功能都无法使用</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 往<span class="built_in">test</span>主机中添加文件</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m shell -a &quot;touch /tmp/123.txt&quot;</span><br><span class="line">[WARNING]: Consider using the file module with state=touch rather than running</span><br><span class="line">&#x27;touch&#x27;.  If you need to use command because file is insufficient you can add</span><br><span class="line">&#x27;warn: false&#x27; to this command task or set &#x27;command_warnings=False&#x27; in ansible.cfg</span><br><span class="line">to get rid of this message.</span><br><span class="line">node1 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看<span class="built_in">test</span>主机的连接情况</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m shell -a &quot;who&quot;</span><br><span class="line">node1 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">root     pts/0        2022-03-19 15:25 (192.168.31.33)</span><br><span class="line">root     pts/1        2022-03-19 16:07 (control)</span><br></pre></td></tr></table></figure>



<ul>
<li><p>ansible使用ssh远程连接被管理主机</p>
<p>退出ssh后所有状态失效</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换目录</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansibel test -m shell -a &quot;cd/tmp&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建文件（注意：没有指定路径，是在家目录创建的文件）</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m shell -a &quot;touch my.txt&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看文件失败</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m shell -a &quot;ls /tmp/my.txt&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用<span class="built_in">chdir</span>参数切换工作目录</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m shell -a &quot;chdir=/tmp touch my.txt&quot;</span><br></pre></td></tr></table></figure>



<ul>
<li>shell模块支持判断（creates、removes）<ul>
<li>creates文件名：文件存在，不执行shell命令</li>
<li>removes文件名：文件不存在，不执行shell命令</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果<span class="built_in">test</span>主机存在密钥就不执行，不存在就生成密钥</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m shell -a &quot;ssh-keygen -f ~/.ssh/id_rsa -N &#x27;&#x27; creates=~/.ssh/id_rsa&quot;</span><br><span class="line">node1 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">skipped, since /root/.ssh/id_rsa exists</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果没有按照unzip软件包，则不执行解压命令</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible node1,node2 -m shell -a &quot;unzip /root/test.zip removes=/bin/unzip&quot;</span><br><span class="line">[WARNING]: Consider using the unarchive module rather than running &#x27;unzip&#x27;.  If</span><br><span class="line">you need to use command because unarchive is insufficient you can add &#x27;warn:</span><br><span class="line">false&#x27; to this command task or set &#x27;command_warnings=False&#x27; in ansible.cfg to get</span><br><span class="line">rid of this message.</span><br><span class="line">node2 | FAILED | rc=9 &gt;&gt;</span><br><span class="line">unzip:  cannot find or open /root/test.zip, /root/test.zip.zip or /root/test.zip.ZIP.non-zero return code</span><br><span class="line">node1 | FAILED | rc=9 &gt;&gt;</span><br><span class="line">unzip:  cannot find or open /root/test.zip, /root/test.zip.zip or /root/test.zip.ZIP.non-zero return code</span><br></pre></td></tr></table></figure>



<h2 id="script模块"><a href="#script模块" class="headerlink" title="script模块"></a>script模块</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将脚本文件test.sh传入node1主机并执行，这个脚本文件是临时文件，执行完后，node1会删除</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible node1 -m script -a &quot;./test.sh&quot;</span><br></pre></td></tr></table></figure>



<h2 id="file模块"><a href="#file模块" class="headerlink" title="file模块"></a>file模块</h2><p>file模块可以创建文件，目录，链接；修改权限与属性等</p>
<p>幂等性：任意次执行所产生的影响均与一次执行的影响相同</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">新建文件state=touch</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m file -a &quot;path=/tmp/file.txt state=touch&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">创建目录state=directory</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m file -a &quot;path=/tmp/mydir state=directory&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">修改文件或目录权限</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m file l -a &quot;path=/tmp/file.txt owner=sshd group=adm mode=0777&quot;</span><br></pre></td></tr></table></figure>



<h2 id="copy模块"><a href="#copy模块" class="headerlink" title="copy模块"></a>copy模块</h2><p>将文件拷贝到远程主机</p>
<p>backup=yes如果目标主机有同名文件，则先备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">新建测试文件</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# echo AAA &gt;~la3.txt</span><br><span class="line"></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m copy -a &quot;src=~la3.txt dest=/root/&quot;</span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m copy -a &quot;src=~la3.txt dest=/root/3a.txt&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">通过content可以直接提供文件内容, n代表回车</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m copy l -a &quot;content=&#x27;hello the world\n&#x27; dest=/root/new.txt&quot;</span><br></pre></td></tr></table></figure>



<h2 id="fetch模块"><a href="#fetch模块" class="headerlink" title="fetch模块"></a>fetch模块</h2><p>与copy类似，但是作用相反</p>
<p>可以将其他主机的文件拷贝到本地</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将远程主机的hostname文件下载到本地家目录,dest是本地目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 多台主机fetch时，如果重名后天会自行重命名</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m fetch -a &quot;src=/etc/hostname dest=~/&quot;</span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ls ~l</span><br></pre></td></tr></table></figure>



<h2 id="lineinfile-replace模块"><a href="#lineinfile-replace模块" class="headerlink" title="lineinfile | replace模块"></a>lineinfile | replace模块</h2><ul>
<li>在修改单个文件的单行内容时可以使用lineinfile模块</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在letc/issue文件中添加一行内容hello world，默认添加到最后</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m lineinfile -a &quot;path=/etc/lissue line=&#x27;hello world&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">基于幂等原则，重复执行，不会创建多行内容</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m lineinfile -a &quot;path=/etc/issue line=&#x27;helle world&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">将内容插入到Kernel行的后面</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m lineinfile -a &quot;path=/etc/issue line=&#x27;insert&#x27; insertafter=&#x27;Kernel&#x27;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>lineinfile会替换一整行，replace可以替换关键词</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将/etc/issue文件全文所有的Kernel替换为0cean</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m replace l -a &quot;path=/etc/issue.net regexp=Kernel replace=Ocean&quot;</span><br></pre></td></tr></table></figure>



<h2 id="user模块"><a href="#user模块" class="headerlink" title="user模块"></a>user模块</h2><ul>
<li>user模块可以实现Linux系统账户管理</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">远程<span class="built_in">test</span>组中的所有主机并创建系统账户tuser1</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m user -a &quot;name=tuser1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建账户并设置对应的账户属性</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m user -a &quot;name=tuser2 uid=1010 group=adm groups=daemon,root home=/home/tuser2&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改账户密码，修改密码必须使用password_hash()算法</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m user -a &quot;name=tuser1 password=&#123;&#123;&#x27;abc&#x27;| password_hash(&#x27;sha512&#x27;)&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>



<h2 id="yum-repository模块"><a href="#yum-repository模块" class="headerlink" title="yum_repository模块"></a>yum_repository模块</h2><ul>
<li>使用yum_repository可以创建或修改yum源配置文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">新建一个yum源配置文件/etclyum.repos.d/myyum.repo</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m yum_repository -a &quot;name=myyum description=hello baseurl=ftp://192.168.31.126/centos gpgcheck=no&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">yum源文件名为myyum，该文件的内容如下:</span></span><br><span class="line">[myyum]</span><br><span class="line">baseurl = ftp://192.168.31.126/centosgpgcheck = 0</span><br><span class="line">name = hello</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改yum源文件内容</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m yum_repository -a &quot;name=myyumdescription=test baseurl=ftp://192.168.4.254/centos gpgcheck=yes gpgkey=...&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">删除yum源文件myyum</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m yum_repository -a &quot;name=myyum state=absent&quot;</span><br></pre></td></tr></table></figure>



<h2 id="yum模块"><a href="#yum模块" class="headerlink" title="yum模块"></a>yum模块</h2><ul>
<li><p>使用yum模块可以安装、卸载、升级软件包</p>
<p>state：present（安装）|absent（卸载）|latest（升级）</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装unzip软件包</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m yum -a &quot;name=unzip state=present&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">升级unzip软件包，软件名称可以是*，代表升级所有软件包</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m yum -a &quot;name=unzip state=latest&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">卸载unzip软件包</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m yum -a &quot;name=unzip state=absent&quot;</span><br></pre></td></tr></table></figure>



<h2 id="逻辑卷相关模块"><a href="#逻辑卷相关模块" class="headerlink" title="逻辑卷相关模块"></a>逻辑卷相关模块</h2><ul>
<li><p>lvg模块：创建、删除卷组（VG），修改卷组大小</p>
<p>state：present（创建）|absent（删除）</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装lvm2软件包</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m yum -a &quot;name=lvm2&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建名称为myvg的卷组,该卷组由/dev/sdb1组成</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m lvg -a &quot;vg=myvg pvs=/dev/sdb1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改卷组大小</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m lvg -a &quot;vg=myvg pvs=/dev/sdb1,/devlsdb2&quot;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>lvol模块：创建、删除逻辑卷(LV)，修改逻辑卷大小 </p>
<p>state：present（创建）|absent（删除）</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用myvg这个卷组创建一个名称为mylv的逻辑卷</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m lvol -a &quot;Iv=mylv vg=myvg size=2G&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改LV逻辑卷大小</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m Ivol -a &quot;Iv=mylv vg=myvg size=4G&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">删除逻辑卷</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m lvol -a &quot;lv=mylv vg=myvg state=absent force=yes&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">删除卷组myvg</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible test -m lvg -a &quot;vg=myvg state=absent&quot;</span><br></pre></td></tr></table></figure>



<h1 id="sudo提权"><a href="#sudo提权" class="headerlink" title="sudo提权"></a>sudo提权</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>sudo（以超级管理员或其他的身份执行命令）</li>
<li>基本流程<ul>
<li>管理员需要先授权（修改/etc/sudoers文件）</li>
<li>普通用户已sudo的形式执行命令</li>
<li>可以通过sudo -l查看授权情况</li>
</ul>
</li>
</ul>
<h2 id="sudoers语法"><a href="#sudoers语法" class="headerlink" title="sudoers语法"></a>sudoers语法</h2><ul>
<li>修改/etc/sudoers的方法<ul>
<li>visudo（带语法检查，默认没有颜色提示）</li>
<li>vim /etc/sudoers（不带语法检查，默认有颜色提示）</li>
</ul>
</li>
<li>授权格式如下：<ul>
<li>用户或组 主机列表=（提权身份） [NOPASSWD]：命令列表</li>
<li>命令需要些绝对路径</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ansible]# cat /etc/sudoers</span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line"><span class="meta">%</span><span class="bash">wheel ALL=(ALL) ALL</span></span><br></pre></td></tr></table></figure>



<ul>
<li>测试（在node1中）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在node1创建一个新用户jerry</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ~]# useradd jerry</span><br><span class="line">[root@MiWiFi-R1CL-srv ~]# passwd jerry</span><br><span class="line">更改用户 jerry 的密码 。</span><br><span class="line">新的 密码：</span><br><span class="line">无效的密码： 密码少于 8 个字符</span><br><span class="line">重新输入新的 密码：</span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时很多服务命令jerry用户无法使用，需要root授权</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改配置文件，使用visudo，和vim  /etc/sudoers都可以</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时就可以使用sudo systemctl方式使用这个命令</span></span><br></pre></td></tr></table></figure>

<p><img src="/ansible-base/Learning/PersonalBlog\CodeChenBlog\source_posts\ansible-base\Snipaste_2022-03-20_15-09-10.jpg"></p>
<ul>
<li>在所有被管理主机配置sudo，让alice可以管理系统服务<ul>
<li>默认普通用户无权执行systemctl命令</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible all -m lineinfile -a &quot;path=/etc/sudoers line=&#x27;alice ALL=(ALL)/usr/bin/systemctl&#x27;&quot;</span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ssh alice@node1   # 密码123456</span><br><span class="line">[alice@proxy ~]$ sudo -l</span><br><span class="line">[alice@proxy ~]$ sudo systemctl restart chronyd   #验证</span><br></pre></td></tr></table></figure>

<ul>
<li>在所有被管理主机配置sudo，让alice可以执行任何命令<ul>
<li>使用NOPASSWD开启无密码验证</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible all -m lineinfile -a &quot;path=/etc/sudoers line=&#x27;aliceALL=(ALL) NOPASSWD:ALL&quot;</span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ssh alice@node1</span><br><span class="line">[alice@proxy ~]$ sudo -l</span><br><span class="line">[alice@proxy ~]$ sudo systemctl restart chronyd		#不需要输入密码</span><br></pre></td></tr></table></figure>



<h1 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h1><ul>
<li>修改~/ansible/ansible.cfg<ul>
<li>修改sudo相关配置（参考/etc/ansible/ansible.cfg）</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ansible]# vim ~/ansible/ansible.cfg</span><br><span class="line">[defaults]</span><br><span class="line">inventory = ~/ansible/hosts</span><br><span class="line">remote_user = alice   #以什么用户远程被管理主机</span><br><span class="line"><span class="meta">#</span><span class="bash">host_key_checking = False   <span class="comment">#是否校验密钥</span></span></span><br><span class="line"></span><br><span class="line">[privilege_escalation]</span><br><span class="line">become = True   #是否需要切换用户</span><br><span class="line">become_method = sudo   #如何切换用户</span><br><span class="line">become_user = root   #切换成什么用户</span><br><span class="line">become_ask_pass = False   #sudo是否需要输入密码</span><br></pre></td></tr></table></figure>



<ul>
<li>使用alice远程被管理主机，需要提前配置SSH密钥</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ~]# for i in node1 node2 node3 node4 node5</span><br><span class="line">do</span><br><span class="line">ssh-copy-id alice@$i</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">[root@control~]#</span><span class="bash"> ansible all -m <span class="built_in">command</span> -a <span class="string">&quot;who&quot;</span>   <span class="comment">#测试效果</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>inventory配置</p>
<p>修改主机清单文件，添加变量（多个变量空格分割）</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[root@control~]#</span><span class="bash"> cat ~lansible/hosts</span></span><br><span class="line">[test]</span><br><span class="line">node1 ansible_ssh_port=220 #自定义远程SSH端口</span><br><span class="line">[proxy]</span><br><span class="line">node2 ansible_ssh_user=alice #自定义远程连接的账户名</span><br><span class="line">[webserver]</span><br><span class="line">node[3:4] ansible_ssh_pass=密码 #自定义远程连接的密码</span><br><span class="line">[database]</span><br><span class="line">node5 ansible_ssh_private_key_file=密钥文件 #自定义远程连接的密钥</span><br><span class="line">[cluster:children]</span><br><span class="line">webserver</span><br><span class="line">database</span><br></pre></td></tr></table></figure>





<h1 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>Ansible ad-hoc可以通过命令行形式远程管理其他主机</p>
<ul>
<li>适合执行一些临时性简单任务</li>
</ul>
</li>
<li><p>Ansible playbook中文名称叫剧本</p>
<ul>
<li>将经常需要执行的任务写入一个文件(剧本)</li>
<li>剧本中可以包含多个任务</li>
<li>剧本写后，我们随时调用剧本，执行相关的任务命令</li>
<li>playbook剧本要求按照YAML格式编写</li>
<li>适合执行周期性经常执行的复杂任务</li>
</ul>
</li>
</ul>
<h2 id="YAML格式"><a href="#YAML格式" class="headerlink" title="YAML格式"></a>YAML格式</h2><ul>
<li><p>“#”代表注释,一般第一行为三个横杠</p>
</li>
<li><p>键值对使用“∵”表示，数组使用”-“表示</p>
</li>
<li><p>缩进必须由两个或以上空格组成</p>
</li>
<li><p>相同层级的缩进必须对齐</p>
</li>
<li><p>全文不可以使用tab键</p>
</li>
<li><p>区分大小写、扩展名为yml或者yaml</p>
</li>
<li><p>跨行数据需要使用&gt;或者|(|会保留换行符)</p>
</li>
<li><p>YAML格式的键值对数据</p>
<ul>
<li>key和value之间使用“：”分割</li>
<li>“：”后面必须有空格</li>
<li>缩进代表层级关系</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 例子</span><br><span class="line">&quot;诗仙&quot;: &quot;李白&quot;</span><br><span class="line">或者</span><br><span class="line">&quot;诗仙&quot;: </span><br><span class="line">	&quot;李白&quot;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>YAML格式的数组数据</p>
<p>使用短横杠和空格表示，一行表示数据格式[值，值，值……]</p>
</li>
</ul>
<p><img src="/ansible-base/Learning/PersonalBlog\CodeChenBlog\source_posts\ansible-base\Snipaste_2022-03-20_16-26-00.jpg"></p>
<p>综合示例</p>
<p><img src="/ansible-base/Learning/PersonalBlog\CodeChenBlog\source_posts\ansible-base\Snipaste_2022-03-20_16-26-33.jpg"></p>
<p><img src="/ansible-base/Learning/PersonalBlog\CodeChenBlog\source_posts\ansible-base\Snipaste_2022-03-20_16-27-47.jpg"></p>
<p><strong>|会保留换行符</strong></p>
<p><img src="/ansible-base/Learning/PersonalBlog\CodeChenBlog\source_posts\ansible-base\Snipaste_2022-03-20_16-29-08.jpg"></p>
<p><strong>-和：后面必须有空格</strong></p>
<p><img src="/ansible-base/Learning/PersonalBlog\CodeChenBlog\source_posts\ansible-base\Snipaste_2022-03-20_16-30-00.jpg"></p>
<h2 id="playbook语法格式"><a href="#playbook语法格式" class="headerlink" title="playbook语法格式"></a>playbook语法格式</h2><ul>
<li><p>playbook采用YAML格式编写</p>
</li>
<li><p>playbook文件中由一个或多个play组成</p>
</li>
<li><p>每个play中可以包含:</p>
<ul>
<li><p>hosts(主机)、tasks(任务)</p>
</li>
<li><p>variables(变量)、roles(角色)、handlers等元素组成</p>
</li>
</ul>
</li>
<li><p>使用ansible-playbook命令运行playbook剧本</p>
</li>
</ul>
<p><strong>测试第一个playbook</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# vim ~/ansible/test.yml</span><br><span class="line">---</span><br><span class="line">- hosts: all</span><br><span class="line">  tasks:</span><br><span class="line">	- name: This is my first playbook</span><br><span class="line">	ping:</span><br><span class="line">	</span><br><span class="line">[root@control ansible]# ansible-playbook ~/ansible/test.yml</span><br></pre></td></tr></table></figure>





<ul>
<li><p>hosts由一个或多个组或主机组成，逗号分隔</p>
</li>
<li><p>tasks由一个或多个任务组成，多个任务按顺序执行</p>
</li>
<li><p>可以使用-f选项自定义并发量</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# vim ~/ansible/test.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test,webserver</span><br><span class="line">tasks:</span><br><span class="line">	- name: This is my first playbook</span><br><span class="line">	  ping:</span><br><span class="line">	- name: Run a shell command</span><br><span class="line">	  shell: touch ~/shell.txt</span><br><span class="line">[root@control ansible]# ansible-playbook ~lansible/test.yml -f 5</span><br></pre></td></tr></table></figure>



<ul>
<li>一个playbook中可以有多个play</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# vim ~/ansible/test.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: This is first play</span><br><span class="line">	  ping:</span><br><span class="line">- hosts: webserver</span><br><span class="line">  tasks:</span><br><span class="line">	- name: This is second play</span><br><span class="line">	  ping:</span><br></pre></td></tr></table></figure>



<p><strong>修改VIM配置</strong></p>
<ul>
<li><p>使用2个空格自动替换tab键</p>
<p>tabstop=2、expandtab</p>
</li>
<li><p>开启自动缩进对其，缩进宽度为2个空格</p>
<p>shiftwidth=2</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/.vimrc</span><br><span class="line">autocmd FileType yaml setlocal ai ts=2 sw=2 et</span><br></pre></td></tr></table></figure>



<h2 id="playbook应用案例之用户"><a href="#playbook应用案例之用户" class="headerlink" title="playbook应用案例之用户"></a>playbook应用案例之用户</h2><ul>
<li>编写playbook创建系统账户、账户属性、设置密码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/test_john.yml</span><br><span class="line">---</span><br><span class="line">- hosts: webserver</span><br><span class="line">  tasks:</span><br><span class="line">- name: Add the user &#x27;johnd&#x27;</span><br><span class="line">  user:</span><br><span class="line">	name: johnd</span><br><span class="line">	uid: 1040</span><br><span class="line">	group: daemon</span><br><span class="line">	password: &quot;&#123;&#123; &#x27;123&#x27; | password_hash(&#x27;sha512&#x27;) &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>花括号外面必须有双引号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/user_james.yml</span><br><span class="line">---</span><br><span class="line">- hosts: webserver</span><br><span class="line">  tasks:</span><br><span class="line">	- name: Add &#x27;james&#x27; with a bash shell, set &#x27;bin&#x27; and &#x27;adm&#x27; to the user&#x27;s groups</span><br><span class="line">      user:</span><br><span class="line">		name: james</span><br><span class="line">		shell: /bin/bash</span><br><span class="line">		groups: bin,adm</span><br><span class="line">		password: &quot;&#123;&#123; &#x27;123&#x27;| password_hash(&#x27;sha512&#x27;) &#125;&#125;”</span><br></pre></td></tr></table></figure>

<ul>
<li>编写playbook删除系统账户johnd</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/user_johnd.yml</span><br><span class="line">---</span><br><span class="line">- hosts: webserver</span><br><span class="line">  tasks:</span><br><span class="line">	- name: Remove the user &#x27;johnd&#x27;</span><br><span class="line">	  user:</span><br><span class="line">		name: johnd</span><br><span class="line">		state: absent</span><br></pre></td></tr></table></figure>

<ul>
<li>使用vdb创建卷组合逻辑卷（手动添加虚拟磁盘）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/lvm.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: Create a new primary partition with a size of 1GiB</span><br><span class="line">	  parted:</span><br><span class="line">		device: /dev/sdb</span><br><span class="line">		number: 1</span><br><span class="line">		state: present</span><br><span class="line">		part_end: 1GiB</span><br><span class="line">	- name: Create a new primary partition with a size of 2GiB</span><br><span class="line">	  parted:</span><br><span class="line">		device: /dev/sdbnumber: 2</span><br><span class="line">		state: present</span><br><span class="line">		part_start: 1GiB</span><br><span class="line">		part_end: 3GiB</span><br><span class="line">	- name: Create a volume group on top of /dev/sdb1</span><br><span class="line">	  lvg:</span><br><span class="line">		vg: my_vg</span><br><span class="line">		pvs: /dev/sdb1</span><br><span class="line">	- name: Create a logical volume of 512m</span><br><span class="line">	  lvol:</span><br><span class="line">		vg: my_vg</span><br><span class="line">		lv: my_lv</span><br><span class="line">		size: 512m</span><br></pre></td></tr></table></figure>



<h2 id="playbook应用案例之软件管理"><a href="#playbook应用案例之软件管理" class="headerlink" title="playbook应用案例之软件管理"></a>playbook应用案例之软件管理</h2><ul>
<li>安装软件、升级软件、安装组包</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/pacakge.yml</span><br><span class="line">---</span><br><span class="line">- hosts: webserver</span><br><span class="line">  tasks:</span><br><span class="line">	- name: Install a list of packages</span><br><span class="line">	  yum:</span><br><span class="line">		name:</span><br><span class="line">		  - httpd</span><br><span class="line">		  - mariadb</span><br><span class="line">		  - mariadb-server</span><br><span class="line">	- name: install the &#x27;Development tools&#x27; package group</span><br><span class="line">	  yum:</span><br><span class="line">		name: &quot;@Development tools&quot;</span><br><span class="line">	- name: update software</span><br><span class="line">	  yum:</span><br><span class="line">		name: &#x27;*&#x27;</span><br><span class="line">		state: latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="setup模块"><a href="#setup模块" class="headerlink" title="setup模块"></a>setup模块</h2><ul>
<li><p>ansible_facts用于采集被管理设备的系统信息</p>
</li>
<li><p>所有收集的信息都被保存在变量中</p>
</li>
<li><p>每次执行playbook默认第一个任务就是Gathering Facts</p>
</li>
<li><p>使用setup模块可以查看收集到的facts信息</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# ansible test -m setup</span><br><span class="line">192.168.4.10 |SUCCESS =&gt; &#123;</span><br><span class="line">  &quot;ansible_facts&quot;: &#123;</span><br><span class="line">	&quot;ansible_all_ipv4_addresses&quot;: [</span><br><span class="line">	  &quot;192.168.4.10&quot;</span><br><span class="line">…省略部分内容…</span><br></pre></td></tr></table></figure>



<h2 id="debug模块"><a href="#debug模块" class="headerlink" title="debug模块"></a>debug模块</h2><ul>
<li>debug模块可以显示变量的值，可以辅助排除<ul>
<li>debug模块有两个参数，var和msg（引用变量需要两个大括号括起来）</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/debug.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- debug:</span><br><span class="line">		var: ansible all_ipv4_addresses</span><br><span class="line">	- debug:</span><br><span class="line">		msg: &quot;主机名是:&#123;&#123; iansible_hostname &#125;&#125;&quot;</span><br><span class="line">	- debug:</span><br><span class="line">		var: ansible devices.vda.partitions.vda1.size</span><br><span class="line">	- debug:</span><br><span class="line">		msg: &quot;总内存大小:&#123;&#123; ansible_memtotal_mb &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>





<h1 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h1><ul>
<li>ansible支持十几种定义变量的方式</li>
<li>这里我们仅介绍其中一部分变量，根据优先级排序<ul>
<li>inventory变量</li>
<li>host facts变量</li>
<li>register变量</li>
<li>playbook变量</li>
<li>playbook提示变量</li>
<li>变量文件</li>
<li>命令行变量</li>
</ul>
</li>
</ul>
<h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><ul>
<li>inventory变量（在主机清单配置文件中定义变量）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/hosts</span><br><span class="line">[test]</span><br><span class="line">node1 myvar1=&quot;hello the world&quot; myvar2=&quot;content&quot;</span><br><span class="line">[proxy]</span><br><span class="line">node2</span><br><span class="line">[webserver]</span><br><span class="line">node[3:4]</span><br><span class="line">[webserver:vars]</span><br><span class="line">yourname=&quot;jacob&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/linventory_var.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: create a file with var.</span><br><span class="line">	  shell: echo i&#123; myvar1 &gt; /tmp/&#123;&#123;myvar2&#125;&#125;</span><br><span class="line">- hosts: webserver</span><br><span class="line">  tasks:</span><br><span class="line">	- name: create a user with var.</span><br><span class="line">	  user:</span><br><span class="line">	    name: &quot;&#123;&#123; yourname &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>



<ul>
<li>host facts变量（可以直接调用ansible手机的系统信息）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/facts_var.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: Use facts info.</span><br><span class="line">	  copy:</span><br><span class="line">		content: &quot;&#123;&#123;ansible_hostname&#125;&#125;:&#123;&#123;ansible_bios_version&#125;&#125;&quot;</span><br><span class="line">		dest: /tmp/facts.txt</span><br></pre></td></tr></table></figure>



<ul>
<li>register语句可以将某个命令的执行结果保存到变量中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/register.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: save shell result to a variable.</span><br><span class="line">	  shell: hostname</span><br><span class="line">	  register: myvar</span><br><span class="line">	- name: print the variable&#x27;s value through debug</span><br><span class="line">	  debug:</span><br><span class="line">		msg: &quot;&#123;&#123; myvar &#125;&#125;&quot;</span><br><span class="line">		</span><br><span class="line"># 通过&quot;.&quot;我们还可以仅提取部分数据</span><br><span class="line">		msg: &quot;&#123;&#123;myvar.stdout&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>



<ul>
<li>playbook变量（使用vars关键词可以在playbook内定义变量）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/playbook_var.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  vars:</span><br><span class="line">	iname: heal</span><br><span class="line">	ipass: &#x27;123456&#x27;   # 注意密码必须是字符串,需安引号</span><br><span class="line">tasks:</span><br><span class="line">  - name: Use variables create user.</span><br><span class="line">    user:</span><br><span class="line">	  name: &quot;&#123;&#123; iname &#125;&#125;&quot;</span><br><span class="line">	  password: &quot;&#123;&#123; ipass | password_hash(&#x27;sha512&#x27;) &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>



<ul>
<li>playbook提示变量（根据提示输入变量的值）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/prompt_var.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  vars_prompt:</span><br><span class="line">	- name: iname</span><br><span class="line">	  prompt:&quot;请输入用户名&quot;</span><br><span class="line">	  private: no   #回显用户名</span><br><span class="line">	- name: ipasswd</span><br><span class="line">	  prompt: &quot;请输入密码&quot;</span><br><span class="line">	  private: yes   #不显示密码</span><br><span class="line">  tasks:</span><br><span class="line">	- name: Create a user.</span><br><span class="line">	  user:</span><br><span class="line">	    name: &quot;&#123;&#123; iname &#125;&#125;&quot;</span><br><span class="line">		password: &quot;&#123;&#123; ipasswd | password_hash(&#x27;sha512&#x27;)&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>



<ul>
<li>单独定义个变了文件，在playbook中用var_files调用该文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/variables.yml</span><br><span class="line">---</span><br><span class="line">iname: cloud</span><br><span class="line">ipass: &#x27;123456&#x27;</span><br><span class="line"></span><br><span class="line">[root@control ansible]# cat ~lansible/file_var.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  vars_files: variables.yml</span><br><span class="line">  tasks:</span><br><span class="line">	- name: create user.</span><br><span class="line">	user:</span><br><span class="line">	  name: &quot;f&#123;i iname &#125;&#125;”</span><br><span class="line">	  password: &quot;&#123;&#123; ipass | password_hash(&#x27;sha512&#x27;)&#125;&#125;”</span><br></pre></td></tr></table></figure>



<ul>
<li>执行ansible-playbook命令时使用-e参数定义变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~lansible/command_var.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: create user</span><br><span class="line">	  user:</span><br><span class="line">		name: &quot;&#123;&#123; iname &#125;&#125;&quot;</span><br><span class="line">		password: &quot;&#123;&#123; ipass | password_hash(&#x27;sha512&#x27;)&#125;&#125;&quot;</span><br><span class="line">		</span><br><span class="line">[root@control ansible]# ansible-playbook command_var.yml -e iname=&quot;beth&quot; -e ipass=&quot;123456&quot;</span><br></pre></td></tr></table></figure>



<h1 id="ansible模块应用"><a href="#ansible模块应用" class="headerlink" title="ansible模块应用"></a>ansible模块应用</h1><h2 id="firewalld模块"><a href="#firewalld模块" class="headerlink" title="firewalld模块"></a>firewalld模块</h2><ul>
<li>使用firewalld模块可以配置防火墙策略</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ~]#cat ~/ansible/firewall.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: install firewalld.</span><br><span class="line">	  yum:</span><br><span class="line">		name: firewalld</span><br><span class="line">		state: present</span><br><span class="line">	- name: run firewalld.</span><br><span class="line">	  service:</span><br><span class="line">		name: firewalld</span><br><span class="line">		state: started</span><br><span class="line">		enabled: yes</span><br><span class="line">	- name: set firewalld rule.</span><br><span class="line">	  firewalld:</span><br><span class="line">		port:80/tcp</span><br><span class="line">		permanent: yes</span><br><span class="line">		state: enabled</span><br></pre></td></tr></table></figure>



<h2 id="template模块"><a href="#template模块" class="headerlink" title="template模块"></a>template模块</h2><ul>
<li><p>copy模块可以将一个文件拷贝给远程主机</p>
</li>
<li><p>但是如果希望每个拷贝的文件内容都不一样呢?</p>
</li>
<li><p>如何给所有web主机拷贝index.html内容是各自的IP地址?</p>
</li>
<li><p>Ansible可以利用Jinja2模板引擎读取变量</p>
<ul>
<li><p>之前在playbook中调用变量，也是Jinja2的功能</p>
</li>
<li><p>Jinja2模块的表达式包含在分隔符<code>&#123;&#123; &#125;&#125;</code>内</p>
</li>
</ul>
</li>
</ul>
<p>案例：</p>
<ul>
<li>给webserver主机拷贝首页，每个主机内容不同</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# mkdir ~/ansible/template</span><br><span class="line">[root@control ansible]# cat ~/ansible/template/index.html</span><br><span class="line">Welcom to &#123;&#123;ansible_hostname&#125;&#125; on &#123;&#123; ansible_eth0.ipv4.address &#125;&#125;.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">模板文件中调用变量不需要双引号</span></span><br><span class="line">[root@control ansible]# cat ~/ansible/template.yml</span><br><span class="line">---</span><br><span class="line">- hosts: webserver</span><br><span class="line">  tasks:</span><br><span class="line">	- name: use template copy index.html to webserver.</span><br><span class="line">	  template:</span><br><span class="line">		src: ~/ansible/templatelindex.html</span><br><span class="line">		dest: /var/www/html/index.html</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~lansible/template/source.j2</span><br><span class="line">&#123;&#123; welcome &#125;&#125; &#123;&#123; iname &#125;&#125; ...</span><br><span class="line">[root@control ansible]# cat ~/ansible/template_2.yml</span><br><span class="line">---</span><br><span class="line">- hosts: webserver</span><br><span class="line">  vars:</span><br><span class="line">	welcome: &#x27;hello&#x27;</span><br><span class="line">	iname: &#x27;jack&#x27;</span><br><span class="line">  tasks:</span><br><span class="line">	- name: use template copy a file to remote host.</span><br><span class="line">	  template:</span><br><span class="line">		src: ~lansible/templatelsource.j2</span><br><span class="line">		dest: /tmpl</span><br></pre></td></tr></table></figure>



<h1 id="ansible高级语法"><a href="#ansible高级语法" class="headerlink" title="ansible高级语法"></a>ansible高级语法</h1><h2 id="error处理机制"><a href="#error处理机制" class="headerlink" title="error处理机制"></a>error处理机制</h2><ul>
<li>默认ansible在遇到error会立即停止playbook</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~lansible/error.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: start a service that does not exist.</span><br><span class="line">	  service:</span><br><span class="line">		name: hehe   #没有这个服务</span><br><span class="line">		state: started</span><br><span class="line">	- name: touch a file.</span><br><span class="line">	  file:</span><br><span class="line">		path: /tmplservice.txt</span><br><span class="line">		state: touch</span><br></pre></td></tr></table></figure>

<ul>
<li>使用ignore_errors可以忽略错误，继续后续的任务</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~lansible/error.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: start a service that does not exist.</span><br><span class="line">	  service:</span><br><span class="line">		name: hehe</span><br><span class="line">		state: started</span><br><span class="line">	  ignore_errors: true   # 针对某一个任务忽略错误</span><br><span class="line">	- name: touch a file.</span><br><span class="line"> 	  file:</span><br><span class="line">		path: /tmp/service.txt</span><br><span class="line">		state: touch</span><br></pre></td></tr></table></figure>



<h2 id="handlers"><a href="#handlers" class="headerlink" title="handlers"></a>handlers</h2><ul>
<li>当某个任务需要依赖其他任务怎么办？<ul>
<li>可以通过handlers定义一组任务</li>
<li>仅当某个任务触发（notify）handlers时才执行相应的任务</li>
<li>如果有多个notify触发执行handlers任务，也仅执行一次</li>
<li>仅当任务的执行状态为changed时handlers任务才执行</li>
<li>handlers任务在所有其他任务都执行后才执行</li>
</ul>
</li>
</ul>
<p>案例：</p>
<ul>
<li>通过notify触发执行handlers任务</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/handlers.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: create directory.   # 多次执行playbook该任务状态不再是changed</span><br><span class="line">	  file:</span><br><span class="line">		path: /tmp/parents/subdir/</span><br><span class="line">		state: directory</span><br><span class="line">	  notify: touch file   # notify后面名称必须和handlers中的任务名称一致</span><br><span class="line">  handlers:</span><br><span class="line">	- name: touch file</span><br><span class="line">	  file:</span><br><span class="line">		path: /tmp/parents/subdir/new.txt</span><br><span class="line">		state: touch</span><br></pre></td></tr></table></figure>



<h2 id="when条件判断"><a href="#when条件判断" class="headerlink" title="when条件判断"></a>when条件判断</h2><ul>
<li><p>when可以定义判断条件，条件为真时才执行某个任务</p>
</li>
<li><p>常见条件操作符如下:</p>
<ul>
<li>==、!=、&gt;、&gt;=、&lt;、&lt;=</li>
</ul>
</li>
<li><p>多个条件可以使用and或or分割</p>
</li>
<li><p>when表达式中调用变量不要使用<code>&#123;&#123; &#125;&#125;</code></p>
</li>
</ul>
<p>案例：</p>
<ul>
<li>远程主机剩余内存不足700M则关闭NetworkManager服务</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/when_1.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: check memory size.</span><br><span class="line">	  service:</span><br><span class="line">		name: NetworkManager</span><br><span class="line">		state: stopped</span><br><span class="line">	  when: ansible_memfree_mb &lt; 700</span><br></pre></td></tr></table></figure>

<ul>
<li><p>判断操作系统是Centos7则创建测试文件</p>
<ul>
<li>&gt;支持多行输入，不保留换行符</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/when_2.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: touch a file</span><br><span class="line">	  file:</span><br><span class="line">		path: /tmp/when.txt</span><br><span class="line">		state: touch</span><br><span class="line">	  when: &gt;</span><br><span class="line">		ansible_distribution == &quot;Centos&quot;</span><br><span class="line">			and</span><br><span class="line">		ansible_distribution_major_version == &quot;7&quot;</span><br></pre></td></tr></table></figure>



<h2 id="block任务块"><a href="#block任务块" class="headerlink" title="block任务块"></a>block任务块</h2><ul>
<li>使用block可以将多个任务合并为一个组</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~lansible/block_1.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: define a group of tasks.</span><br><span class="line">	  block:</span><br><span class="line">		- name: install httpd</span><br><span class="line">		  yum:</span><br><span class="line">			name: httpd</span><br><span class="line">			state: present</span><br><span class="line">		- name: start httpd</span><br><span class="line">		  service:</span><br><span class="line">			name: httpd</span><br><span class="line">			state: started</span><br><span class="line">	  when: ansible_distribution == &quot;Centos&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>rescue定义block任务执行失败时要执行的其他任务</p>
</li>
<li><p>always定义无论block任务是否成功，都要执行的任务</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~lansible/block_2.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- block:</span><br><span class="line">		- name: touch a file test1.txt</span><br><span class="line">		  file:</span><br><span class="line">			path: /tmp/test1.txt   #如果改为/tmplxyz/test1.txt就无法创建成功</span><br><span class="line">			state: touch</span><br><span class="line">	  rescue:</span><br><span class="line">		- name: touch a file test2.txt</span><br><span class="line">		  file:</span><br><span class="line">			path: /tmp/test2.txt</span><br><span class="line">			state: touch</span><br><span class="line">	  always:</span><br><span class="line">		- name: touch a file test3.txt</span><br><span class="line">		  file:</span><br><span class="line">			path: /tmp/test3.txt</span><br><span class="line">			state: touich</span><br></pre></td></tr></table></figure>



<h2 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h2><ul>
<li>很多任务都在用相同的模块?使用loop循环避免重复</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/simple_loop.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: mkdir multi directory.</span><br><span class="line">	  file:</span><br><span class="line">		path: /tmpl&#123;&#123;item&#125;&#125;   #注意,item是关键字</span><br><span class="line">		state: directory</span><br><span class="line">	  loop:</span><br><span class="line">		- School</span><br><span class="line">		- Legend</span><br><span class="line">		- Life</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/complex_loop.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  tasks:</span><br><span class="line">	- name: create multi user.</span><br><span class="line">	  user:</span><br><span class="line">		name: &quot;&#123;&#123;item.iname&#125;&#125;&quot;</span><br><span class="line">		password: &quot;&#123;&#123;item.ipass | password_hash(&#x27;sha512&#x27;)&#125;&#125;&quot;</span><br><span class="line">	  loop:</span><br><span class="line">		- &#123; iname: &#x27;term&#x27;, ipass: &#x27;123456&#x27;&#125;</span><br><span class="line">		- &#123; iname: &#x27;amy&#x27; , ipass: &#x27;654321&#x27;&#125;</span><br></pre></td></tr></table></figure>



<h1 id="ansible-vault"><a href="#ansible-vault" class="headerlink" title="ansible vault"></a>ansible vault</h1><h2 id="加密文件"><a href="#加密文件" class="headerlink" title="加密文件"></a>加密文件</h2><ul>
<li>ansible有时需要访问一些敏感数据，如密码、key等</li>
<li>使用ansible-vault可以加密和 解密数据<ul>
<li>encrypt（加密）、decrypt（解密）、view（查看）</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# echo 123456 &gt; data.txt   #新建测试文件</span><br><span class="line">[root@control ansible]# ansible-vault encrypt data.txt   #加密文件</span><br><span class="line">[root@control ansible]# cat data.txt</span><br><span class="line">[root@control ansible]# ansible-vault view data.txt   #查看加密文件</span><br></pre></td></tr></table></figure>

<ul>
<li>ansible-vault rekey可以修改加密的密码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# ansible-vault encrypt data.txt   #加密文件，密码111</span><br><span class="line">New Vault password: 111</span><br><span class="line">Confirm New Vault password:111</span><br><span class="line">[root@control ansible]# ansible-vault rekey data.txt   #修改密码</span><br><span class="line">Vault password:&lt;旧密码&gt;</span><br><span class="line">New Vault password:&lt;新密码&gt;</span><br><span class="line">Confirm New Vault password:&lt;确认新密码&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>加密、解密每次都输入密码很麻烦，可以将密码写入文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# echo &quot;&#x27;m secret data&quot; &gt; data.txt   #需要加密的敏感数据</span><br><span class="line">[root@control ansible]# echo 123456 &gt; pass.txt   #加密的密码</span><br><span class="line">[root@control ansible]# ansible-vault encrypt --vault-id=pass.txt data.txt</span><br><span class="line">[root@control ansible]# cat data.txt</span><br><span class="line">[root@control ansible]# ansible-vault decrypt --vault-id=pass.txt data.txt</span><br><span class="line">[root@control ansible]# cat data.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>传输敏感数据到远程数据</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# echo &quot;I&#x27;m secret data&quot; &gt; data.txt   #需要加密的敏感数据</span><br><span class="line">[root@control ansible]# echo 123456 &gt; pass.txt   #加密的密码</span><br><span class="line">[root@control ansible]# ansible-vault encrypt --vault-id=pass.txt data.txt</span><br><span class="line">[root@control ansible]# ansible test -m copy --vault-id=pass.txt -a &quot;src=data.txt dest=/tmpl mode=0600&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>playbook调用敏感数据（账户名、密码等）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/variables.yml</span><br><span class="line">iname: cloud</span><br><span class="line">ipass: &#x27;123456&#x27;</span><br><span class="line">[root@control ansible]# ansible-vault encrypt variables.yml</span><br><span class="line">[root@control ansiblej# cat ~/ansible/vault.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  vars_files: variables.yml</span><br><span class="line">  tasks:</span><br><span class="line">	- name: include vault data, create user.</span><br><span class="line">	  user:</span><br><span class="line">		name: &quot;&#123;&#123;iname&#125;&#125;&quot;</span><br><span class="line">		password: &quot;&#123;&#123;ipasslpassword_hash(&#x27;sha512&#x27;)&#125;&#125;”</span><br><span class="line">[root@control ansibilej# ansible-playbook --ask-vault-pass vault.yml</span><br></pre></td></tr></table></figure>



<h1 id="ansible-roles"><a href="#ansible-roles" class="headerlink" title="ansible roles"></a>ansible roles</h1><h2 id="什么是roles"><a href="#什么是roles" class="headerlink" title="什么是roles"></a>什么是roles</h2><ul>
<li><p>在实际生产环境中，为了实现不同的功能,我们会编写大量的playbook文件</p>
</li>
<li><p>而且，每个playbook还可能会调用其他文件（如变量文件)</p>
</li>
<li><p>对于海量的、无规律的文件，管理起来非常痛苦!</p>
</li>
<li><p>Ansible从1.2版本开始支持Roles</p>
</li>
<li><p>Roles是管理ansible文件的一种规范(目录结构)</p>
<ul>
<li>Roles会按照标准的规范，自动到特定的目录和文件中读取数据</li>
</ul>
</li>
</ul>
<h2 id="roles规范的目录结构"><a href="#roles规范的目录结构" class="headerlink" title="roles规范的目录结构"></a>roles规范的目录结构</h2><ul>
<li>如果我们创建了一个名称为user.example的role<ul>
<li>其标准的目录结构如下所示</li>
</ul>
</li>
</ul>
<p><img src="/ansible-base/Learning/PersonalBlog\CodeChenBlog\source_posts\ansible-base\Snipaste_2022-03-23_15-22-51.jpg"></p>
<ul>
<li><p>defualts/main.yml:定义变量的缺省值，优先级较低</p>
</li>
<li><p>files目录:存储静态文件的目录</p>
</li>
<li><p>handlers/main.yml:定义handlers</p>
</li>
<li><p>meta/main.yml:写作者、版本等描述信息</p>
</li>
<li><p>README.md:整个角色(role)的描述信息</p>
</li>
<li><p>tasks/main.yml:定义任务的地方</p>
</li>
<li><p>templates目录:存放动态数据文件的地方(模板文件)</p>
</li>
<li><p>vars/main.yml:定义变量,优先级高</p>
</li>
</ul>
<p>小结：roles就是一组规范的目录结构</p>
<h2 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h2><ul>
<li>ansible-galaxy命令可以创建、管理自己的roles</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# mkdir ~/ansible/roles</span><br><span class="line"></span><br><span class="line">[root@control ansible]# ansible-galaxy init ~/ansible/roles/issue</span><br><span class="line"><span class="meta">#</span><span class="bash">创建一个Role，该Role的目的是使用模板修改远程主机的/etc/issue文件</span></span><br><span class="line"></span><br><span class="line">[root@control ansible]# tree ~/ansible/roles/issuel</span><br><span class="line"><span class="meta">#</span><span class="bash">查看目录结构，如果没有tree命令则需要使用yum安装该软件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义issue文件的模板文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~lansible/roles/issue/templates/issue.j2</span><br><span class="line">This is the system &#123;&#123;fansible_hostname&#125;&#125;</span><br><span class="line">Today&#x27;s date is:&#123;fansible_date_time.date&#125;&#125;</span><br><span class="line">Contact to &#123;&#123; admin &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义变量文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~lansible/roles/issue/vars/main.yml</span><br><span class="line">---</span><br><span class="line"><span class="meta">#</span><span class="bash"> vars file <span class="keyword">for</span> /root/ansible/roles/issue</span></span><br><span class="line">admin: yoyo@tedu.cn</span><br></pre></td></tr></table></figure>

<ul>
<li>修改任务文件，任务文件中不需要tasks关键字<ul>
<li>role的各个文件之间相互调用不需要写路径</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~lansible/roleslissue/tasks/main.yml</span><br><span class="line">---</span><br><span class="line"><span class="meta">#</span><span class="bash"> tasks file <span class="keyword">for</span> /root/ansible/roles/issue</span></span><br><span class="line">- name: delever issue file</span><br><span class="line">  template:</span><br><span class="line">    src: issue.j2</span><br><span class="line">    dest:/etc/issue</span><br></pre></td></tr></table></figure>



<h2 id="在playbook中调用role"><a href="#在playbook中调用role" class="headerlink" title="在playbook中调用role"></a>在playbook中调用role</h2><ul>
<li>方法一：在role相同目录下创建一个playbook调用</li>
<li>方法二：在ansible.cfg设置roles_path=路径</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansiblelansible.cfg</span><br><span class="line">[defaults]</span><br><span class="line">remote_user = root</span><br><span class="line">inventory = ./inventory</span><br><span class="line">roles_path = ./roles</span><br><span class="line">[privilege_escalation]</span><br><span class="line">become=True</span><br><span class="line">become_method=sudo</span><br><span class="line">become_user=root</span><br><span class="line">become_ask_pass=False</span><br></pre></td></tr></table></figure>

<ul>
<li>编写playbook文件，通过roles关键词调用role</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~/ansible/issue.yml</span><br><span class="line">---</span><br><span class="line">- hosts: test</span><br><span class="line">  roles:</span><br><span class="line">	- issue</span><br><span class="line"><span class="meta">   #</span><span class="bash">-role2   <span class="comment">#支持加载多个role</span></span></span><br></pre></td></tr></table></figure>



<h2 id="ansible-galaxy"><a href="#ansible-galaxy" class="headerlink" title="ansible-galaxy"></a>ansible-galaxy</h2><ul>
<li>ansible galaxy是官方提供的一个共享roles的平台<ul>
<li>公共roles仓库（<a href="http://galaxy.ansible.com)/">http://galaxy.ansible.com）</a></li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# ansible-galaxy search &#x27;httpd&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">联网搜索roles</span></span><br><span class="line"></span><br><span class="line">[root@control ansible]# ansible-galaxy info acandid.httpd</span><br><span class="line"><span class="meta">#</span><span class="bash">查看roles基本信息</span></span><br><span class="line"></span><br><span class="line">[root@control ansible]# ansible-galaxy install acandid.httpd -p ~/ansible/roles/</span><br><span class="line"><span class="meta">#</span><span class="bash">下载roles到特定的目录</span></span><br><span class="line"></span><br><span class="line">[root@control ansible]# ansible-galaxy list -p roles/</span><br><span class="line"><span class="meta">#</span><span class="bash">列出本地有哪些roles</span></span><br></pre></td></tr></table></figure>

<ul>
<li>下载roles的方法：<ul>
<li>使用ansible-galaxy install或者编写requirements.yml文件</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ansible]# cat ~lansible/roles/requirements.yml</span><br><span class="line"><span class="meta">#</span><span class="bash">格式一:直接从Ansible Galaxy官网下载</span></span><br><span class="line">- src: acandid.httpd</span><br><span class="line"><span class="meta">#</span><span class="bash">格式二:从某个git服务器下载</span></span><br><span class="line">- src: http://gitlab.com/xxx/xxx.git</span><br><span class="line">  scm: git</span><br><span class="line">  version: 56e00a54</span><br><span class="line">  name: nginx-acme</span><br><span class="line"><span class="meta">#</span><span class="bash">格式三:下载tar包，支持http、https、file</span></span><br><span class="line">- src: http://example.com/myrole.tar</span><br><span class="line">  name: myrole</span><br><span class="line">[root@control ansible]# ansible-galaxy install -r roles/requirements.yml -p roles</span><br></pre></td></tr></table></figure>



<h1 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h1><h2 id="自动化部署web集群"><a href="#自动化部署web集群" class="headerlink" title="自动化部署web集群"></a>自动化部署web集群</h2><ul>
<li>创建role，通过role完成项目（可能需要多个role）</li>
<li>部署Nginx调度器</li>
<li>部署2台LNMP服务器</li>
<li>部署MariaDB数据库</li>
</ul>
<p>创建role部署后端LNMP平台环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible-galaxy init ~/ansible/roles/lnmp</span><br><span class="line">- Role /root/ansible/roles/lnmp was created successfully</span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ls roles</span><br><span class="line">lnmp</span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ls roles/lnmp/</span><br><span class="line">defaults  files  handlers  meta  README.md  tasks  templates  tests  vars</span><br></pre></td></tr></table></figure>

<p>在控制端中files文件中放入Nginx安装包</p>
<p><img src="/ansible-base/Learning/PersonalBlog\CodeChenBlog\source_posts\ansible-base\Snipaste_2022-03-23_16-17-29.jpg"></p>
<p>编写脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv lnmp]# vim ~/ansible/roles/lnmp/files/install_nginx.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">conf=&quot;/usr/local/nginx/conf/nginx.conf&quot;</span><br><span class="line">yum -y install gcc pcre-devel openssl-devel make</span><br><span class="line">cd /tmp/</span><br><span class="line">tar -xf nginx-1.20.2.tar.gz</span><br><span class="line">cd nginx-1.20.2</span><br><span class="line">./configure --with-http_ssl_module</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">sed -i &#x27;65,71s/#//&#x27; $conf   # 删除65-71行的#</span><br><span class="line">sed -i &#x27;/SCRIPT_FILENAME/d&#x27; $conf   # 删除此行</span><br><span class="line">sed -i &#x27;s/fastcgi_params/fastcgi.conf/&#x27; $conf</span><br></pre></td></tr></table></figure>

<p>编写网页</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv lnmp]# vim ~/ansible/roles/lnmp/templates/index.html</span><br><span class="line">welcome to &#123;&#123; ansible_hostname &#125;&#125; on &#123;&#123; ansible_all_ipv4_addresses &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在task中编写任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv lnmp]# vim ~/ansible/roles/lnmp/tasks/main.yml</span><br><span class="line">---</span><br><span class="line"><span class="meta">#</span><span class="bash"> tasks file <span class="keyword">for</span> /root/ansible/roles/lnmp</span></span><br><span class="line">- name: copy nginx-1.20.2.tar.gz to webserver.</span><br><span class="line">  copy:</span><br><span class="line">    src: nginx-1.20.2.tar.gz</span><br><span class="line">    dest: /tmp/</span><br><span class="line">- name: install nginx through shell script.</span><br><span class="line">  script: install_nginx.sh</span><br><span class="line">  args:</span><br><span class="line">    creates: /usr/local/nginx/sbin/nginx</span><br><span class="line">- name: copy index.html to webserver.</span><br><span class="line">  template:</span><br><span class="line">    src: index.html</span><br><span class="line">    dest: /usr/local/nginx/html/index.html</span><br><span class="line">- name: install php</span><br><span class="line">  yum:</span><br><span class="line">    name: </span><br><span class="line">      - php</span><br><span class="line">      - php-fpm</span><br><span class="line">      - php-mysqlnd</span><br><span class="line">      - mariadb-devel</span><br><span class="line">- name: run all service</span><br><span class="line">  block:</span><br><span class="line">    - service:</span><br><span class="line">        name: php-fpm</span><br><span class="line">        state: started</span><br><span class="line">    - shell: /usr/local/nginx/sbin/nginx</span><br><span class="line">      args:</span><br><span class="line">        creates: /usr/local/nginx/logs/nginx.pid</span><br></pre></td></tr></table></figure>

<p>编写自动化部署剧本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv lnmp]# vim ~/ansible/lnmp.yml</span><br><span class="line">[root@MiWiFi-R1CL-srv lnmp]# cat ~/ansible/lnmp.yml</span><br><span class="line">---</span><br><span class="line">- hosts: webserver</span><br><span class="line">  roles:</span><br><span class="line">    - lnmp</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible-playbook lnmp.yml </span><br><span class="line"></span><br><span class="line">PLAY [webserver] ******************************************************************</span><br><span class="line"></span><br><span class="line">TASK [Gathering Facts] ************************************************************</span><br><span class="line">ok: [node4]</span><br><span class="line">ok: [node3]</span><br><span class="line"></span><br><span class="line">TASK [lnmp : copy nginx-1.20.2.tar.gz to webserver.] ******************************</span><br><span class="line">changed: [node4]</span><br><span class="line">changed: [node3]</span><br><span class="line"></span><br><span class="line">TASK [lnmp : install nginx through shell script.] *********************************</span><br><span class="line">changed: [node4]</span><br><span class="line">changed: [node3]</span><br><span class="line"></span><br><span class="line">TASK [lnmp : copy index.html to webserver.] ***************************************</span><br><span class="line">changed: [node3]</span><br><span class="line">changed: [node4]</span><br><span class="line"></span><br><span class="line">TASK [lnmp : install php] *********************************************************</span><br><span class="line">changed: [node4]</span><br><span class="line">changed: [node3]</span><br><span class="line"></span><br><span class="line">TASK [lnmp : service] *************************************************************</span><br><span class="line">changed: [node4]</span><br><span class="line">fatal: [node3]: FAILED! =&gt; &#123;&quot;changed&quot;: false, &quot;msg&quot;: &quot;Unable to start service php-fpm: Job for php-fpm.service failed because the control process exited with error code. See \&quot;systemctl status php-fpm.service\&quot; and \&quot;journalctl -xe\&quot; for details.\n&quot;&#125;</span><br><span class="line"></span><br><span class="line">TASK [lnmp : shell] ***************************************************************</span><br><span class="line">changed: [node4]</span><br><span class="line"></span><br><span class="line">PLAY RECAP ************************************************************************</span><br><span class="line">node3                      : ok=5    changed=4    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   </span><br><span class="line">node4                      : ok=7    changed=6    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现问题，查看对应主机的日志</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ~]# tail -20 /var/log/messages</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次执行，成功</span></span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible-playbook lnmp.yml </span><br><span class="line"></span><br><span class="line">PLAY [webserver] ******************************************************************</span><br><span class="line"></span><br><span class="line">TASK [Gathering Facts] ************************************************************</span><br><span class="line">ok: [node4]</span><br><span class="line">ok: [node3]</span><br><span class="line"></span><br><span class="line">TASK [lnmp : copy nginx-1.20.2.tar.gz to webserver.] ******************************</span><br><span class="line">ok: [node4]</span><br><span class="line">ok: [node3]</span><br><span class="line"></span><br><span class="line">TASK [lnmp : install nginx through shell script.] *********************************</span><br><span class="line">skipping: [node3]</span><br><span class="line">skipping: [node4]</span><br><span class="line"></span><br><span class="line">TASK [lnmp : copy index.html to webserver.] ***************************************</span><br><span class="line">ok: [node4]</span><br><span class="line">ok: [node3]</span><br><span class="line"></span><br><span class="line">TASK [lnmp : install php] *********************************************************</span><br><span class="line">ok: [node4]</span><br><span class="line">ok: [node3]</span><br><span class="line"></span><br><span class="line">TASK [lnmp : service] *************************************************************</span><br><span class="line">ok: [node4]</span><br><span class="line">changed: [node3]</span><br><span class="line"></span><br><span class="line">TASK [lnmp : shell] ***************************************************************</span><br><span class="line">ok: [node4]</span><br><span class="line">changed: [node3]</span><br><span class="line"></span><br><span class="line">PLAY RECAP ************************************************************************</span><br><span class="line">node3                      : ok=6    changed=2    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   </span><br><span class="line">node4                      : ok=6    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0 </span><br></pre></td></tr></table></figure>

<p>在node3和node4主机确认一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Nginx已安装</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls /usr/<span class="built_in">local</span>/nginx/</span></span><br><span class="line">client_body_temp  fastcgi_temp  logs        sbin       uwsgi_temp</span><br><span class="line">conf              html          proxy_temp  scgi_temp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Nginx已启动</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ss -nutlp | grep :80</span></span><br><span class="line">tcp    LISTEN     0      128       *:80                    *:*                   users:((&quot;nginx&quot;,pid=4689,fd=6),(&quot;nginx&quot;,pid=4688,fd=6))</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PHP已安装</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rpm -q php</span></span><br><span class="line">php-5.4.16-48.el7.x86_64</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> php-fpm已安装</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rpm -q php-fpm</span></span><br><span class="line">php-fpm-5.4.16-48.el7.x86_64</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /usr/<span class="built_in">local</span>/nginx/html/index.html</span></span><br><span class="line">welcome to MiWiFi-R1CL-srv on [u&#x27;192.168.122.1&#x27;, u&#x27;192.168.31.248&#x27;]</span><br></pre></td></tr></table></figure>

<p>创建role部署代理服务环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible-galaxy init ~/ansible/roles/proxy</span><br><span class="line">- Role /root/ansible/roles/proxy was created successfully</span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# ls ~/ansible/roles/proxy/</span><br><span class="line">defaults  files  handlers  meta  README.md  tasks  templates  tests  vars</span><br><span class="line">[root@MiWiFi-R1CL-srv ansible]# cp ~/ansible/roles/lnmp/files/* ~/ansible/roles/proxy/files/</span><br></pre></td></tr></table></figure>

<p>配置代理服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv files]# cat ~/ansible/roles/proxy/files/install_nginx.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">conf=&quot;/usr/local/nginx/conf/nginx.conf&quot;</span><br><span class="line">yum -y install gcc pcre-devel openssl-devel make</span><br><span class="line">cd /tmp/</span><br><span class="line">tar -xf nginx-1.20.2.tar.gz</span><br><span class="line">cd nginx-1.20.2</span><br><span class="line">./configure --with-http_ssl_module</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">sed -i &#x27;/^http/a upstream webs &#123; \n server 192.168.31.248;\n server 192.168.31.217;\n &#125;\n&#x27; $conf</span><br><span class="line">sed -i &#x27;49i proxy_pass http://webs;&#x27; $conf</span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>

<p>编写任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv proxy]# vim ~/ansible/roles/proxy/tasks/main.yml</span><br><span class="line">---</span><br><span class="line"><span class="meta">#</span><span class="bash"> tasks file <span class="keyword">for</span> /root/ansible/roles/proxy</span></span><br><span class="line">- name: copy source file to node2</span><br><span class="line">  copy:</span><br><span class="line">    src: nginx-1.20.2.tar.gz</span><br><span class="line">    dest: /tmp/</span><br><span class="line">- name: install nginx.</span><br><span class="line">  script: install_nginx.sh</span><br><span class="line">  args:</span><br><span class="line">    creates: /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>

<p>编写剧本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ansible]# vim ~/ansible/proxy.yml</span><br><span class="line">---</span><br><span class="line">- hosts: node2</span><br><span class="line">  roles:</span><br><span class="line">    - proxy</span><br><span class="line">    </span><br><span class="line">- hosts: node5</span><br><span class="line">  tasks:</span><br><span class="line">    - name: install mariadb server</span><br><span class="line">      yum:</span><br><span class="line">        name:</span><br><span class="line">          - mariadb</span><br><span class="line">          - mariadb-server</span><br><span class="line">          - mariadb-devel</span><br><span class="line">    - name: run mariadb server</span><br><span class="line">      service:</span><br><span class="line">        name: mariadb</span><br><span class="line">        state: started</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ansible]# ansible-playbook proxy.yml </span><br><span class="line"></span><br><span class="line">PLAY [node2] **********************************************************************</span><br><span class="line"></span><br><span class="line">TASK [Gathering Facts] ************************************************************</span><br><span class="line">Warning: the ECDSA host key for &#x27;node2&#x27; differs from the key for the IP address &#x27;192.168.31.208&#x27;</span><br><span class="line">Offending key for IP in /root/.ssh/known_hosts:2</span><br><span class="line">Matching host key in /root/.ssh/known_hosts:6</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">ok: [node2]</span><br><span class="line"></span><br><span class="line">TASK [proxy : copy source file to node2] ******************************************</span><br><span class="line">changed: [node2]</span><br><span class="line"></span><br><span class="line">TASK [proxy : install nginx.] *****************************************************</span><br><span class="line">changed: [node2]</span><br><span class="line"></span><br><span class="line">PLAY [node1] **********************************************************************</span><br><span class="line"></span><br><span class="line">TASK [Gathering Facts] ************************************************************</span><br><span class="line">ok: [node1]</span><br><span class="line"></span><br><span class="line">TASK [install mariadb server] *****************************************************</span><br><span class="line">changed: [node1]</span><br><span class="line"></span><br><span class="line">TASK [run mariadb server] *********************************************************</span><br><span class="line">changed: [node1]</span><br><span class="line"></span><br><span class="line">PLAY RECAP ************************************************************************</span><br><span class="line">node1                      : ok=3    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   </span><br><span class="line">node2                      : ok=3    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure>

<p>在node2关闭http</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CL-srv ~]# firewall-cmd --add-service=http</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins-base</title>
    <url>/jenkins-base/</url>
    <content><![CDATA[<p>Jenkins中三大重要概念：</p>
<blockquote>
<p>1、job（任务/工程）</p>
</blockquote>
<p>在Jenkins平台中，都是以job（任务/工程）为单位去完成一件事情的。</p>
<p>在使用Jenkins时，都是会在Jenkins管理界面当中创建一个job/item。在job/item中来组织任务。</p>
<span id="more"></span>

<blockquote>
<p>2、plugin（插件）</p>
</blockquote>
<p>Jenkins提供平台，集成各种插件来完成一个job。想用Jenkins来做什么，先找找有没有相应的插件。</p>
<p>比如：Windows命令、Linux命令的支持、SVN和Git代码获取、邮件发送，测试报告集成等都需要安装相应的插件才能够在Jenkins当中使用这些功能。</p>
<blockquote>
<p>3、workspace（工作空间）</p>
</blockquote>
<p>Jenkins是通过文件形式来存储和管理数据的。</p>
<ul>
<li><p>所以，在安装Jenkins，要指定一个Jenkins_Home目录。所有Jenkins相关的数据都存放在此目录下。</p>
</li>
<li><p>workspace即给Jenkins指定一个专门的目录来存储其所有的配置和数据。Jenkins的workspace是根目录，其下每个job都有属于自己的workspace。</p>
</li>
<li><p>每个job的workspace当中用来存放本任务涉及到的数据/文件，以及任务执行完成后生成的数据/文件。</p>
</li>
<li><p>相当于，给每个job开辟了一个独立的文件夹。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>基于docker实现mysql主从复制、读写分离</title>
    <url>/docker-mysql-master-slave/</url>
    <content><![CDATA[<blockquote>
<p><strong>SQL查询慢怎么办？</strong></p>
<ol>
<li>从数据库设计方面<ul>
<li>加索引</li>
<li>尽量多考虑使用数值型</li>
<li>尽量多考虑使用定长而非变长</li>
</ul>
</li>
<li>从SQL优化入手<ul>
<li>exist和in</li>
<li>in和not in</li>
<li>like的使用从数据库设计方面加索引尽量多考虑使用数值型尽量多考虑使用定长而非变长从SQL优化入手exist和inin和not inlike的使用</li>
</ul>
</li>
</ol>
</blockquote>
<span id="more"></span>

<blockquote>
<p><strong>随着数据增长将会遇到什么问题？</strong></p>
<ul>
<li>一台服务器的资源是有限的</li>
<li>数据库中的数据量不可控</li>
<li>库中的表会越来越多</li>
<li>表中的数据量也会越来越大</li>
<li>增删改查的开销会越来越大</li>
</ul>
</blockquote>
<p>用架构进行优化！</p>
<h1 id="为什么MySQL要做主从复制（读写分离）？"><a href="#为什么MySQL要做主从复制（读写分离）？" class="headerlink" title="为什么MySQL要做主从复制（读写分离）？"></a>为什么MySQL要做主从复制（读写分离）？</h1><p>主从复制（读写分离）的目的：分散压力</p>
<p>原因：如果对数据库的读和写都在同一个数据库服务中操作，业务系统性能会降低</p>
<h1 id="配置主从数据库"><a href="#配置主从数据库" class="headerlink" title="配置主从数据库"></a>配置主从数据库</h1><ol>
<li>在宿主机中创建一个conf文件夹，存放主从数据库的配置文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos /]# mkdir /conf</span><br><span class="line">[root@VM-24-12-centos /]# cd /conf/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">######################################################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 主数据库配置文件</span></span><br><span class="line">[root@VM-24-12-centos conf]# vim master.cnf</span><br><span class="line">[root@VM-24-12-centos conf]# cat master.cnf </span><br><span class="line">[mysqld]</span><br><span class="line">pid-file = /var/run/mysqld/mysqld.pid</span><br><span class="line">socket = /var/run/mysqld/mysqld.sock</span><br><span class="line">datadir = /var/lib/mysql</span><br><span class="line">symbolic-links=0</span><br><span class="line">character-set-server = utf8 </span><br><span class="line"><span class="meta">#</span><span class="bash">skip-networking</span> </span><br><span class="line">innodb_print_all_deadlocks = 1</span><br><span class="line">max_connections = 2000 </span><br><span class="line">max_connect_errors = 6000 </span><br><span class="line">open_files_limit = 65535 </span><br><span class="line">table_open_cache = 128 </span><br><span class="line">max_allowed_packet = 4M </span><br><span class="line">binlog_cache_size = 1M </span><br><span class="line">max_heap_table_size = 8M </span><br><span class="line">tmp_table_size = 16M </span><br><span class="line">read_buffer_size = 2M </span><br><span class="line">read_rnd_buffer_size = 8M </span><br><span class="line">sort_buffer_size = 8M </span><br><span class="line">join_buffer_size = 28M </span><br><span class="line">key_buffer_size = 4M </span><br><span class="line">thread_cache_size = 8 </span><br><span class="line">query_cache_type = 1 </span><br><span class="line">query_cache_size = 8M </span><br><span class="line">query_cache_limit = 2M </span><br><span class="line">ft_min_word_len = 4 </span><br><span class="line">log-bin = mysql-bin</span><br><span class="line">server-id = 1</span><br><span class="line">binlog_format = mixed </span><br><span class="line">performance_schema = 0 </span><br><span class="line">explicit_defaults_for_timestamp </span><br><span class="line"><span class="meta">#</span><span class="bash">lower_case_table_names = 1</span> </span><br><span class="line">interactive_timeout = 28800 </span><br><span class="line">wait_timeout = 28800 </span><br><span class="line"><span class="meta">#</span><span class="bash"> Recommended <span class="keyword">in</span> standard MySQL setup</span> </span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,NO_AUTO_CREATE_USER,STRICT_TRANS_TABLES </span><br><span class="line">[mysqldump] </span><br><span class="line">quick </span><br><span class="line">max_allowed_packet = 16M </span><br><span class="line">[myisamchk]</span><br><span class="line">key_buffer_size = 8M</span><br><span class="line">sort_buffer_size = 8M</span><br><span class="line">read_buffer = 4M</span><br><span class="line">write_buffer = 4M</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###########################################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从数据库1配置文件</span></span><br><span class="line">[root@VM-24-12-centos conf]# vim slave.cnf</span><br><span class="line">[root@VM-24-12-centos conf]# cat slave.cnf </span><br><span class="line">[mysqld]</span><br><span class="line">pid-file = /var/run/mysqld/mysqld.pid</span><br><span class="line">socket = /var/run/mysqld/mysqld.sock</span><br><span class="line">datadir = /var/lib/mysql</span><br><span class="line">symbolic-links=0</span><br><span class="line">character-set-server = utf8 </span><br><span class="line"><span class="meta">#</span><span class="bash">skip-networking</span> </span><br><span class="line">innodb_print_all_deadlocks = 1</span><br><span class="line">max_connections = 2000 </span><br><span class="line">max_connect_errors = 6000 </span><br><span class="line">open_files_limit = 65535 </span><br><span class="line">table_open_cache = 128 </span><br><span class="line">max_allowed_packet = 4M </span><br><span class="line">binlog_cache_size = 1M </span><br><span class="line">max_heap_table_size = 8M </span><br><span class="line">tmp_table_size = 16M </span><br><span class="line">read_buffer_size = 2M </span><br><span class="line">read_rnd_buffer_size = 8M </span><br><span class="line">sort_buffer_size = 8M </span><br><span class="line">join_buffer_size = 28M </span><br><span class="line">key_buffer_size = 4M </span><br><span class="line">thread_cache_size = 8 </span><br><span class="line">query_cache_type = 1 </span><br><span class="line">query_cache_size = 8M </span><br><span class="line">query_cache_limit = 2M </span><br><span class="line">ft_min_word_len = 4 </span><br><span class="line">log-bin = mysql-bin</span><br><span class="line">server-id = 2</span><br><span class="line">binlog_format = mixed </span><br><span class="line">performance_schema = 0 </span><br><span class="line">explicit_defaults_for_timestamp </span><br><span class="line"><span class="meta">#</span><span class="bash">lower_case_table_names = 1</span> </span><br><span class="line">interactive_timeout = 28800 </span><br><span class="line">wait_timeout = 28800 </span><br><span class="line"><span class="meta">#</span><span class="bash"> Recommended <span class="keyword">in</span> standard MySQL setup</span> </span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,NO_AUTO_CREATE_USER,STRICT_TRANS_TABLES </span><br><span class="line">[mysqldump] </span><br><span class="line">quick </span><br><span class="line">max_allowed_packet = 16M </span><br><span class="line">[myisamchk]</span><br><span class="line">key_buffer_size = 8M</span><br><span class="line">sort_buffer_size = 8M</span><br><span class="line">read_buffer = 4M</span><br><span class="line">write_buffer = 4M</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从数据库2配置文件</span></span><br><span class="line">[root@VM-24-12-centos conf]# vim slave.cnf</span><br><span class="line">[root@VM-24-12-centos conf]# cat slave.cnf </span><br><span class="line">[mysqld]</span><br><span class="line">pid-file = /var/run/mysqld/mysqld.pid</span><br><span class="line">socket = /var/run/mysqld/mysqld.sock</span><br><span class="line">datadir = /var/lib/mysql</span><br><span class="line">symbolic-links=0</span><br><span class="line">character-set-server = utf8 </span><br><span class="line"><span class="meta">#</span><span class="bash">skip-networking</span> </span><br><span class="line">innodb_print_all_deadlocks = 1</span><br><span class="line">max_connections = 2000 </span><br><span class="line">max_connect_errors = 6000 </span><br><span class="line">open_files_limit = 65535 </span><br><span class="line">table_open_cache = 128 </span><br><span class="line">max_allowed_packet = 4M </span><br><span class="line">binlog_cache_size = 1M </span><br><span class="line">max_heap_table_size = 8M </span><br><span class="line">tmp_table_size = 16M </span><br><span class="line">read_buffer_size = 2M </span><br><span class="line">read_rnd_buffer_size = 8M </span><br><span class="line">sort_buffer_size = 8M </span><br><span class="line">join_buffer_size = 28M </span><br><span class="line">key_buffer_size = 4M </span><br><span class="line">thread_cache_size = 8 </span><br><span class="line">query_cache_type = 1 </span><br><span class="line">query_cache_size = 8M </span><br><span class="line">query_cache_limit = 2M </span><br><span class="line">ft_min_word_len = 4 </span><br><span class="line">log-bin = mysql-bin</span><br><span class="line">server-id = 3</span><br><span class="line">binlog_format = mixed </span><br><span class="line">performance_schema = 0 </span><br><span class="line">explicit_defaults_for_timestamp </span><br><span class="line"><span class="meta">#</span><span class="bash">lower_case_table_names = 1</span> </span><br><span class="line">interactive_timeout = 28800 </span><br><span class="line">wait_timeout = 28800 </span><br><span class="line"><span class="meta">#</span><span class="bash"> Recommended <span class="keyword">in</span> standard MySQL setup</span> </span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,NO_AUTO_CREATE_USER,STRICT_TRANS_TABLES </span><br><span class="line">[mysqldump] </span><br><span class="line">quick </span><br><span class="line">max_allowed_packet = 16M </span><br><span class="line">[myisamchk]</span><br><span class="line">key_buffer_size = 8M</span><br><span class="line">sort_buffer_size = 8M</span><br><span class="line">read_buffer = 4M</span><br><span class="line">write_buffer = 4M</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动主从数据库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos conf]# docker run --privileged=true -p 3311:3306 --name mysql-master -v /conf/master.cnf:/etc/mysql/conf.d/master.cnf -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line">2eed8da7114dba469b85f6f0a5bb087de7fa7ad49fd5c5e56ff2b4ffc91c9e3b</span><br><span class="line">[root@VM-24-12-centos conf]# docker run --privileged=true -p 3312:3306 --name mysql-slave01 -v /conf/slave.cnf:/etc/mysql/conf.d/slave.cnf -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line">cfa3e8c1062c69ad14a9c5c6eabf415a44c6398efb32a6acd99b087ba6ba441c</span><br><span class="line">[root@VM-24-12-centos conf]# docker run --privileged=true -p 3313:3306 --name mysql-slave02 -v /conf/slave02.cnf:/etc/mysql/conf.d/slave.cnf -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line">370af2a651d5d983b99eb6d916a0885fb835c04ba3c225bc6b8dc05f20004fe6</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>分别进入容器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos conf]# docker exec -it mysql-master /bin/bash</span><br><span class="line">root@20a63bf1a35a:/# mysql -uroot -p</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show master status;</span></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000003 |      154 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建用户</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create user codechen;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 授予权限</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT ALL PRIVILEGES ON *.* TO codechen@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>; FLUSH PRIVILEGES;</span></span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 主数据库原始数据</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show databases;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| song               |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看二进制文件，配置slave数据库时需要</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show master logs;</span></span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 |       177 |</span><br><span class="line">| mysql-bin.000002 |   5889540 |</span><br><span class="line">| mysql-bin.000003 |      2123 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启从数据库（两个从数据库相同）</span></span><br><span class="line">[root@VM-24-12-centos conf]# docker exec -it mysql-slave01 /bin/bash</span><br><span class="line">root@07abacc7cfa4:/# mysql -uroot -p</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 原始的数据库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show databases;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在slave数据库中配置主从关联<span class="string">&#x27;152.136.154.107&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> master_host=<span class="string">&#x27;172.17.0.2&#x27;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> master_port=3311,</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> change master to</span> </span><br><span class="line">master_host=&#x27;172.17.0.2&#x27;,</span><br><span class="line">master_port=3306,</span><br><span class="line">master_user=&#x27;codechen&#x27;,</span><br><span class="line">master_password=&#x27;123456&#x27;,</span><br><span class="line">master_log_file=&#x27;mysql-bin.000003&#x27;, #Master服务器产生的日志要和Master服务器所配置的相互对应如下如所示的file对应</span><br><span class="line">master_log_pos=0; #要和Master服务器所配置的相互对应如下如所示的Position对应（经过测试发现如果是一样的只能同步一次，所以这里修正成0，0是可以每次都同步成功的）</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.04 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">开启服务并查看启动状态</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> start slave;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show slave status\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 152.136.154.107</span><br><span class="line">                  Master_User: codechen</span><br><span class="line">                  Master_Port: 3311</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000003</span><br><span class="line">          Read_Master_Log_Pos: 100440</span><br><span class="line">               Relay_Log_File: 07abacc7cfa4-relay-bin.000003</span><br><span class="line">                Relay_Log_Pos: 100653</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000003</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 100440</span><br><span class="line">              Relay_Log_Space: 5990443</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: a269da86-b350-11ec-b5cc-0242ac110002</span><br><span class="line">             Master_Info_File: /var/lib/mysql/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: </span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置成功后数据库就可以同步数据库了</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show databases;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| song               |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 内网ip地址</span></span><br><span class="line">172.17.0.2   # master</span><br><span class="line">172.17.0.3   # slave01</span><br><span class="line">172.17.0.4   # slave02</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>git-base</title>
    <url>/git-base/</url>
    <content><![CDATA[<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制( Revision control )是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p>
<ul>
<li><p>实现跨区域多人协同开发</p>
</li>
<li><p>追踪和记载一个或者多个文件的历史记录</p>
</li>
<li><p>组织和保护你的源代码和文档</p>
</li>
<li><p>统计工作量</p>
</li>
<li><p>并行开发、提高开发效率</p>
</li>
<li><p>跟踪记录整个软件的开发过程</p>
</li>
<li><p>减轻开发人员的负担，节省时间，同时降低人为错误</p>
</li>
</ul>
<p>简单说就是用于管理多人协同开发项目的技术</p>
<p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p>
<span id="more"></span>

<p>常见的版本控制器如下所示：</p>
<ul>
<li><p>Git</p>
</li>
<li><p>SVN ( Subversion )</p>
</li>
<li><p>CVS ( concurrent Versions System )</p>
</li>
<li><p>VSS ( Micorosoft Visual SourceSafe )</p>
</li>
<li><p>TFS ( Team Foundation Server )</p>
</li>
<li><p>Visual Studio Online</p>
</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>1、本地版本控制</strong></p>
<p>记录键每次的更新，可以对版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p>
<p><img src="/./git-base/Snipaste_2022-03-23_22-28-41.jpg"></p>
<p><strong>2、集中版本控制</strong></p>
<p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p>
<p><img src="/./git-base/Snipaste_2022-03-23_22-30-16.jpg"></p>
<p>所有的版本数据都存在服务器上，用户的本地只有提左戌存在单一的服务器上，有很大的风险这个很务龄会报师，这或铣会表开版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损害，这样就会丢失所有的数据，当然可以定期备份。代表品:SVN、CVS、VSS</p>
<p><strong>3、分布式版本控制</strong></p>
<p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p>
<p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p>
<p>每个人都有全部的代码，存在安全隐患！</p>
<p><img src="/./git-base/Snipaste_2022-03-24_21-58-33.jpg"></p>
<h2 id="Git和SVN最主要的区别"><a href="#Git和SVN最主要的区别" class="headerlink" title="Git和SVN最主要的区别"></a>Git和SVN最主要的区别</h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p>
<p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的∶比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>Git是目前世界上最先进的分布式版本控制系统。</p>
<h1 id="Git基本理论（核心）"><a href="#Git基本理论（核心）" class="headerlink" title="Git基本理论（核心）"></a>Git基本理论（核心）</h1><blockquote>
<p>工作区域</p>
</blockquote>
<p>Git本地有三个工作区域∶工作目录(Working Directory )、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>
<p><img src="/./git-base/Snipaste_2022-03-24_22-22-24.jpg"></p>
<ul>
<li><p>Workspace :工作区，就是你平时存放项目代码的地方</p>
</li>
<li><p>Index / Stage:暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</p>
</li>
<li><p>Repository:仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</p>
</li>
<li><p>Remote:远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p>
</li>
</ul>
<blockquote>
<p>工作流程</p>
</blockquote>
<p>git的工作流程一般是这样的:</p>
<ol>
<li><p>在工作目录中添加、修改文件；</p>
</li>
<li><p>将需要进行版本管理的文件放入暂存区域；</p>
</li>
<li><p>将暂存区域的文件提交到git仓库。</p>
</li>
</ol>
<p>因此，git管理的文件有三种状态︰已修改( modified ) ,已暂存( staged ) ,已提交(committed)</p>
<h1 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h1><blockquote>
<p>创建工作目录与常用指令</p>
</blockquote>
<p>工作目录(WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。日常使用只要记住下图6个命令∶</p>
<p><img src="/./git-base/Snipaste_2022-03-24_22-31-01.jpg"></p>
<blockquote>
<p>本地仓库搭建</p>
</blockquote>
<p>创建本地仓库的方法有两种︰一种是创建全新的仓库，另一种是克隆远程仓库。</p>
<p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行︰</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码块</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure>

<p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p>
<blockquote>
<p>克隆远程仓库</p>
</blockquote>
<p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git c1one [ur1]</span></span><br></pre></td></tr></table></figure>

<p>2、去gitee或者github 上克隆一个测试！</p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><blockquote>
<p>文件四种状态</p>
</blockquote>
<p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不<br>想提交的文件，或者要提交的文件没提交上。</p>
<ul>
<li><p><strong>Untracked：</strong>未跟踪,此文件在文件夹中，但并没有加入到git库,不参与版本控制.通过git add状态变为staged</p>
</li>
<li><p><strong>Unmodify：</strong>文件已经入库,未修改,即版本库中的文件快照内容与文件夹中完全一致.这种类型的文件有两种去处,如果它被修改,而变为Modified.如果使用git rm移出版本库,则成为untracked文件</p>
</li>
<li><p><strong>Modified：</strong>文件已修改,仅仅是修改,并没有进行其他的操作.这个文件也有两个去处,通过git add可进入暂存staged状态,使用git checkout则丢弃修改过,返回到_unmodify状态,这个git checkout即从库中取出文件,覆盖当前修改!</p>
</li>
<li><p><strong>Staged：</strong>暂存状态.执行git commit则将修改同步到库中,这时库中的文件和本地文件又变为一致,文件为unmodify状态.执行git reset HEAD filename取消暂存,文件状态为Modified</p>
</li>
</ul>
<blockquote>
<p>查看文件状态</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看指定文件状态</span></span><br><span class="line">git status [filename]</span><br><span class="line"><span class="comment">#查看所有文件状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># git add .   | 添加所有文件到暂存区</span></span><br><span class="line"><span class="comment"># git commit -m &quot;消息内容（注释）&quot;   提交暂存区中的内容到本地仓库 -m 提交信息</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>忽略文件</p>
</blockquote>
<p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p>
<p>在主目录下建立”.gitignore”文件，此文件有如下规则:</p>
<ol>
<li><p>忽略文件中的空行或以井号（#）开始的行将会被忽略。</p>
</li>
<li><p>可以使用Linux通配符。例如:星号(*)代表任意多个字符，问号（？)代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,..}）代表可选的字符串等。</p>
</li>
<li><p>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</p>
</li>
<li><p>如果名称的最前面是一个路径分隔符（/ ），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</p>
</li>
<li><p>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#为注释</span></span><br><span class="line">*.txt          <span class="comment">#忽略所有.txt结尾的文件,这样的话上传就不会被选中!</span></span><br><span class="line">!lib.txt       <span class="comment">#但7ib.txt除外</span></span><br><span class="line">/temp          <span class="comment">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span></span><br><span class="line">build/         <span class="comment">#忽略bui1d/目录下的所有文件</span></span><br><span class="line">doc/*.txt      <span class="comment">#会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>查看修改的内容</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff readme.txt</span><br></pre></td></tr></table></figure>



<blockquote>
<p>版本回退</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line"></span><br><span class="line">git reset --head 版本号</span><br></pre></td></tr></table></figure>



<blockquote>
<p>撤销修改</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把readme.txt文件在工作区做的修改全部撤销</span><br><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure>





<h1 id="GIT分支"><a href="#GIT分支" class="headerlink" title="GIT分支"></a>GIT分支</h1><p><img src="/./git-base/Snipaste_2022-03-28_22-54-34.jpg"></p>
<p>git分支中常用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除分支</span></span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除远程分支</span></span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>

<p>如果同一个文件在合并分支时都被修改了则会引起冲突︰解决的办法是我们可以修改冲突文件后重新提交!</p>
<p>可以选择要保留谁的代码!</p>
<p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><blockquote>
<p>绑定仓库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin 仓库地址</span><br></pre></td></tr></table></figure>



<blockquote>
<p>推送至远程仓库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin master   # 第一次提交加-u，直接推送至master分支</span><br><span class="line"></span><br><span class="line"># 之后就可以使用</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka-base</title>
    <url>/kafka-base/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Kafka是一个<strong>分布式</strong>的基于<strong>发布/订阅模式</strong>的<strong>消息队列</strong>（Message Queue），主要应用于大数据实时处理领域。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2>]]></content>
  </entry>
  <entry>
    <title>LVS（DR模式）+Keepalived+Nginx+web高可用集群</title>
    <url>/keepalived-lvs-nginx/</url>
    <content><![CDATA[<p>keepalived+lvs+nginx</p>
<p>在微服务项目中前段的负载均衡的稳定性是一个非常大的考验，这里我们使用keepalived+lvs+nginx完成我们前段的负载均衡</p>
<span id="more"></span>

<h1 id="什么是高可用？"><a href="#什么是高可用？" class="headerlink" title="什么是高可用？"></a>什么是高可用？</h1><p>nginx做负载均衡，能达到分发请求的目的，但是不能很好的避免单点故障。</p>
<p>1、Nginx集群单点问题</p>
<ul>
<li><p>分发器宕机</p>
<p>假如nginx服务器挂掉了，那么所有的服务也会跟着瘫痪 。<br>一种方法是人为监控，发现主分发器宕机后，立马登录备分发器，并给它分配虚ip。<br>另一种办法是用软件来替代人来监控，自动登录备分发器，分配虚ip。</p>
</li>
<li><p>数据服务器宕机</p>
<p>分发器可以自动判断数据服务器的存活状态，不对宕机服务器要数据。</p>
</li>
</ul>
<p>2、keepalived介绍</p>
<p>Keepalived的作用是检测服务器的状态，如果有一台web服务器宕机，或工作出现故障，Keepalived将检测到，并将有故障的服务器从系统中剔除，同时使 其他服务器代替该服务器的工作，当服务器工作正常后Keepalived自动将服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的服务器。<br>总结来说：Keepalived软件是一个监控+自愈的软件。<br>运行协议是VRRP，主分发器的keepalived会向网络中发组播，宣告自己还活着，组播地址：224.0.0.18。</p>
<p>3、LVS</p>
<p>在keepalived+nginx的主备容灾高可用的架构中，nginx是作为外部访问系统的唯一入口，理论上一台nginx的最大并发量可以高达50000，但是当并发量更大的时候，keepalived+nginx的高可用机制是没办法满足需求的，因为keepalived+nginx的架构中确确实实是一台nginx在工作，只有当master宕机或异常的时候，备份机才会上位。那么如何解决更大的高并发问题呢，也许你会问能不能搭建nginx集群，直接对外提供访问？很显然这是欠妥当的，因为当nginx作为外部的唯一访问入口，没办法直接以集群的形式对外提供服务，没有那么多的公网ip资源可用，既太浪费也不友好。但是在内网环境下，是可以用nginx集群（nginx横向扩展服务集合）的，当然总得有一个对外入口，所以需要在nginx集群之上，在加一层负载均衡器LVS，作为系统的唯一入口。</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><table>
<thead>
<tr>
<th>主机名</th>
<th>IP</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>node1</td>
<td>192.168.31.145</td>
<td>虚拟IP（VIP）</td>
</tr>
<tr>
<td>node2（lvskeepalived1）</td>
<td>192.168.31.93</td>
<td>LVS+ Keepalived Master（LVS将请求负载至nginx1 或者 nginx2）</td>
</tr>
<tr>
<td>node3（lvskeepalived2）</td>
<td>192.168.31.91</td>
<td>LVS+ Keepalived Backup （lvskeepalived1的备机）</td>
</tr>
<tr>
<td>node4（nginx1）</td>
<td>192.168.31.165</td>
<td>Nginx1（将请求负载至后端web1 或者 web2）</td>
</tr>
<tr>
<td>node5（nginx2）</td>
<td>192.168.31.179</td>
<td>Nginx2（将请求负载至后端web1 或者 web2）</td>
</tr>
<tr>
<td>node6（web1）</td>
<td>192.168.31.97</td>
<td>Web1（静态web服务器）</td>
</tr>
<tr>
<td>node7（web2）</td>
<td>192.168.31.86</td>
<td>Web2（静态web服务器）</td>
</tr>
</tbody></table>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p><strong>1、在lvskeepalived1 和 lvskeepalived2 机器上面安装 ipvsadm 和 keepalived：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# yum -y install ipvsadm keepalived</span><br></pre></td></tr></table></figure>

<p>查看两台负载均衡机器是否支持lvs</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# lsmod |grep ip_vs</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令没有任何反应，执行下面命令打开ipvs即可</span></span><br><span class="line">[root@node1 ~]# ipvsadm</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> RemoteAddress:Port           Forward Weight ActiveConn InActConn</span></span><br><span class="line">[root@node1 ~]# lsmod |grep ip_vs</span><br><span class="line">ip_vs                 145458  0 </span><br><span class="line">nf_conntrack          139264  1 ip_vs</span><br><span class="line">libcrc32c              12644  3 xfs,ip_vs,nf_conntrack</span><br></pre></td></tr></table></figure>



<p><strong>2、在Nginx1和Nginx2机器上安装Nginx</strong></p>
<p>自行安装Nginx</p>
<p><strong>3、在web1和web2上面安装Apache</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install httpd</span><br></pre></td></tr></table></figure>

<p>配置网页：</p>
<p>实际配置网页内容应该一样，但是为了演示nginx负载均衡效果，我们将网页内容一个配置成web1, 一个配置成web2。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在web1配置如下：</span></span><br><span class="line">cd /var/www/html</span><br><span class="line">echo &quot;web1&quot; &gt; index.html</span><br><span class="line">systemctl restart httpd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">在web2配置如下：</span></span><br><span class="line">cd /var/www/html</span><br><span class="line">echo &quot;web2&quot; &gt; index.html</span><br><span class="line">systemctl restart httpd</span><br></pre></td></tr></table></figure>



<p><strong>4、配置keepalived</strong></p>
<ul>
<li>在lvskeepalived1（master）上配置：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# vim /etc/keepalived/keepalived.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Global Configuration</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">  lvs_id director1  # 指定lvs的id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance LVS &#123;</span><br><span class="line">  state MASTER  # 指定当前节点为master节点</span><br><span class="line">  interface ens33       # 这里的ens33是网卡的名称，通过ifconfig或者ip addr可以查看  </span><br><span class="line">  virtual_router_id 51   # 这里指定的是虚拟路由id，master节点和backup节点需要指定一样的</span><br><span class="line">  priority 151   # 指定了当前节点的优先级，数值越大优先级越高，master节点要高于backup节点</span><br><span class="line">  advert_int 1  # 指定发送VRRP通告的间隔，单位是秒  </span><br><span class="line">  authentication &#123;</span><br><span class="line">    auth_type PASS      # 鉴权，默认通过</span><br><span class="line">    auth_pass 123456    # 鉴权访问密码</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    192.168.31.145      # 指定了虚拟ip</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Virtual Server Configuration - <span class="keyword">for</span> www server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台真实主机的配置</span></span><br><span class="line">virtual_server 192.168.31.145 80 &#123;</span><br><span class="line">  delay_loop 1  # 健康检查的时间间隔</span><br><span class="line">  lb_algo rr    # 负载均衡策略，这里是轮询</span><br><span class="line">  lb_kind DR    # 调度器类型，这里是DR</span><br><span class="line">  persistence_time 1    # 指定了持续将请求打到同一台真实主机的时间长度</span><br><span class="line">  protocol TCP  # 指定了访问后台真实主机的协议类型</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> Real Server 1 configuration</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 指定了真实主机1的ip和端口</span></span><br><span class="line">  real_server 192.168.31.165 80 &#123;</span><br><span class="line">    weight 1    # 指定了当前主机的权重</span><br><span class="line">    TCP_CHECK &#123;</span><br><span class="line">      connection_timeout 10     # 指定了进行心跳检查的超时时间</span><br><span class="line">      nb_get_retry 3    # 指定了心跳超时之后的重复次数</span><br><span class="line">      delay_before_retry 3      # 指定了在尝试之前延迟多长时间</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> Real Server 2 Configuration</span></span><br><span class="line">  real_server 192.168.31.179 80 &#123;</span><br><span class="line">    weight 1    # 指定了当前主机的权重</span><br><span class="line">    TCP_CHECK &#123;</span><br><span class="line">      connection_timeout 10     # 指定了进行心跳检查的超时时间</span><br><span class="line">      nb_get_retry 3    # 指定了心跳超时之后的重复次数</span><br><span class="line">      delay_before_retry 3      # 指定了在尝试之前延迟多长时间</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在lvskeepalived2（backup）上配置：</p>
<p>lvs_id director1 改成 lvs_id director2<br>state MASTER 改成 state BACKUP<br>priority 151 改成 priority 101</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node3 ~]# vim /etc/keepalived/keepalived.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Global Configuration</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">  lvs_id director2  # 指定lvs的id</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> VRRP Configuration</span></span><br><span class="line">vrrp_instance LVS &#123;</span><br><span class="line">  state BACKUP  # 指定当前节点为backup节点</span><br><span class="line">  interface ens33       # 这里的ens33是网卡的名称，通过ifconfig或者ip addr可以查看  </span><br><span class="line">  virtual_router_id 101   # 这里指定的是虚拟路由id，master节点和backup节点需要指定一样的</span><br><span class="line">  priority 101   # 指定了当前节点的优先级，数值越大优先级越高，master节点要高于backup节点</span><br><span class="line">  advert_int 1  # 指定发送VRRP通告的间隔，单位是秒  </span><br><span class="line">  authentication &#123;</span><br><span class="line">    auth_type PASS      # 鉴权，默认通过</span><br><span class="line">    auth_pass 123456    # 鉴权访问密码</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    192.168.31.145      # 指定了虚拟ip</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Virtual Server Configuration - <span class="keyword">for</span> www server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台真实主机的配置</span></span><br><span class="line">virtual_server 192.168.31.145 80 &#123;</span><br><span class="line">  delay_loop 1  # 健康检查的时间间隔</span><br><span class="line">  lb_algo rr    # 负载均衡策略，这里是轮询</span><br><span class="line">  lb_kind DR    # 调度器类型，这里是DR</span><br><span class="line">  persistence_time 1    # 指定了持续将请求打到同一台真实主机的时间长度</span><br><span class="line">  protocol TCP  # 指定了访问后台真实主机的协议类型</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> Real Server 1 configuration</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 指定了真实主机1的ip和端口</span></span><br><span class="line">  real_server 192.168.31.165 80 &#123;</span><br><span class="line">    weight 1    # 指定了当前主机的权重</span><br><span class="line">    TCP_CHECK &#123;</span><br><span class="line">      connection_timeout 10     # 指定了进行心跳检查的超时时间</span><br><span class="line">      nb_get_retry 3    # 指定了心跳超时之后的重复次数</span><br><span class="line">      delay_before_retry 3      # 指定了在尝试之前延迟多长时间</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> Real Server 2 Configuration</span></span><br><span class="line">  real_server 192.168.31.179 80 &#123;</span><br><span class="line">    weight 1    # 指定了当前主机的权重</span><br><span class="line">    TCP_CHECK &#123;</span><br><span class="line">      connection_timeout 10     # 指定了进行心跳检查的超时时间</span><br><span class="line">      nb_get_retry 3    # 指定了心跳超时之后的重复次数</span><br><span class="line">      delay_before_retry 3      # 指定了在尝试之前延迟多长时间</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>5、配置Nginx</strong></p>
<ul>
<li><p>在nginx1 和 nginx2 机器上面配置负载均衡：（两台机器一模一样的配置）</p>
<p>实现将访问本机80端口的请求轮询定向到后端的两台apache服务器：</p>
<p>我们这里只演示两台apache web 服务器， 你也可以配置多台。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node5 conf]# vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">user  nobody;</span></span><br><span class="line">worker_processes  auto;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  info;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    upstream serverList &#123;</span><br><span class="line">	server 192.168.31.97:80;  #web server1,后端真实服务器</span><br><span class="line">	server 192.168.31.86:80;  #web server2,后端真实服务器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        #server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            # root   html;</span><br><span class="line">            # index  index.html index.htm;</span><br><span class="line">            proxy_pass  http://serverList; # 指向负载的列表的模块，如serverList</span><br><span class="line">	    	proxy_redirect     off;</span><br><span class="line">	    	proxy_set_header   Host             $host;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在nginx1 和 nginx2 机器上面配置虚拟IP: (两台nginx机器， 一模一样的配置)</p>
<p>因为我们使用的lvs调度器是DR模式，前面我们讲到过，这种模式下，对客户端的响应是真实服务器直接返回给客户端的，而真实服务器需要将响应报文中的源ip修改为虚拟ip，这里配置的虚拟ip就是起这个作用的。我们编辑/etc/init.d/lvsrs文件，写入如下内容：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node4 conf]# vim /etc/init.d/lvsrs</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">虚拟的vip 根据自己的实际情况定义</span></span><br><span class="line">SNS_VIP=192.168.31.145</span><br><span class="line">/etc/rc.d/init.d/functions</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">       ifconfig lo:0 $SNS_VIP netmask 255.255.255.255 broadcast $SNS_VIP</span><br><span class="line">       /sbin/route add -host $SNS_VIP dev lo:0</span><br><span class="line">       echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">       echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">       echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">       echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">       sysctl -p &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">       echo &quot;RealServer Start OK&quot;</span><br><span class="line">       ;;</span><br><span class="line">stop)</span><br><span class="line">       ifconfig lo:0 down</span><br><span class="line">       route del $SNS_VIP &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">       echo &quot;RealServer Stoped&quot;</span><br><span class="line">       ;;</span><br><span class="line">*)</span><br><span class="line">       echo &quot;Usage: $0 &#123;start|stop&#125;&quot;</span><br><span class="line">       exit 1</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p>然后执行脚本：（两台Nginx）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node4 init.d]# chmod 755 lvsrs</span><br><span class="line"></span><br><span class="line">[root@node4 init.d]# ./lvsrs start</span><br><span class="line">./lvsrs:行4: /etc/rc.d/init.d/functions: 权限不够</span><br><span class="line">SIOCADDRT: 文件已存在</span><br><span class="line">RealServer Start OK</span><br></pre></td></tr></table></figure>

<p><img src="/./keepalived-lvs-nginx/Snipaste_2022-04-09_21-16-38.jpg"></p>
<p>查看ip lo:0 和路由是否添加成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node4 init.d]# ip a | grep -i lo:0</span><br><span class="line">    inet 192.168.31.145/32 brd 192.168.31.145 scope global lo:0</span><br><span class="line">    </span><br><span class="line">[root@node4 init.d]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.31.1    0.0.0.0         UG    100    0        0 ens33</span><br><span class="line">192.168.31.0    0.0.0.0         255.255.255.0   U     100    0        0 ens33</span><br><span class="line">192.168.31.145  0.0.0.0         255.255.255.255 UH    0      0        0 lo</span><br></pre></td></tr></table></figure>

<p><img src="/./keepalived-lvs-nginx/Snipaste_2022-04-09_21-19-21.jpg"></p>
<p><img src="/./keepalived-lvs-nginx/Snipaste_2022-04-09_21-37-46.jpg"></p>
<p>如果可以看到上述结果，证明 lo:0和路由都已经配置成功。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><strong>1、启动Nginx服务，验证Nginx负载功能</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node4 init.d]# /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>

<p>测试分别访问nginx1和nginx2的网页， 可以看到请求轮询定向到后端的两台web服务器上， 所以Nginx 负载功能验证成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# while [ TRUR ]; do curl http://192.168.31.165:80; sleep 2 ; done</span><br><span class="line">web2</span><br><span class="line">web2</span><br><span class="line">web1</span><br><span class="line">web2</span><br><span class="line">web1</span><br><span class="line">web2</span><br></pre></td></tr></table></figure>

<p><img src="/./keepalived-lvs-nginx/Snipaste_2022-04-09_22-39-28.jpg"></p>
<p><strong>2、启动keepalived</strong></p>
<p>在lvskeepalived1 和 lvskeepalived2 服务器上启动keepalived.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start keepalived</span><br><span class="line">systemctl enable keepalived</span><br></pre></td></tr></table></figure>

<p>过几秒就可以看到VIP在master和backup机器上面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# ip a | grep -i ens33</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    inet 192.168.31.93/24 brd 192.168.31.255 scope global noprefixroute dynamic ens33</span><br><span class="line">    inet 192.168.31.145/32 scope global ens33</span><br></pre></td></tr></table></figure>

<p><img src="/./keepalived-lvs-nginx/Snipaste_2022-04-09_22-45-24.jpg"></p>
<p>通过VIP访问网页：</p>
<p><img src="/./keepalived-lvs-nginx/Snipaste_2022-04-09_22-47-24.jpg"></p>
<p><img src="/./keepalived-lvs-nginx/Snipaste_2022-04-09_22-48-09.jpg"></p>
<p>访问成功， 可见LVS 成功将请求转发到了后端web server 上。</p>
<p><strong>3、keepalived高可用测试</strong></p>
<ul>
<li>停掉主keepalived，备份keepalived还是可以运行的</li>
</ul>
<p><strong>4、LVS监控真实服务测试</strong></p>
<ul>
<li>查看最新的虚拟ip对应的RealServer的情况<br>VIP：192.168.31.145<br>Realserver1 IP: 192.168.31.165<br>Realserver2 IP: 192.168.31.179</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# ipvsadm -Ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> RemoteAddress:Port           Forward Weight ActiveConn InActConn</span></span><br><span class="line">TCP  192.168.31.145:80 rr</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 192.168.31.165:80            Route   1      0          0</span>         </span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 192.168.31.179:80            Route   1      0          0</span></span><br></pre></td></tr></table></figure>

<p><img src="/./keepalived-lvs-nginx/Snipaste_2022-04-09_23-17-24.jpg"></p>
<p>停掉其中一个Nginx也可以正常运行</p>
<p>注意：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启端口</span></span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者关闭防火墙</span></span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>





<h1 id="docker方式"><a href="#docker方式" class="headerlink" title="docker方式"></a>docker方式</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos ~]# docker run -itd --name lvsKeepalived1 --privileged=true -p 101:22 centos:7</span><br><span class="line">[root@VM-24-12-centos ~]# docker run -itd --name lvsKeepalived2 --privileged=true -p 102:22 centos:7</span><br><span class="line"></span><br><span class="line">[root@VM-24-12-centos ~]# docker run --name nginx1 --privileged=true -d -p 201:80 nginx</span><br><span class="line">[root@VM-24-12-centos ~]# docker run --name nginx2 --privileged=true -d -p 202:80 nginx</span><br><span class="line"></span><br><span class="line">[root@VM-24-12-centos ~]# docker run -itd --name web1 --privileged=true -p 301:22 centos:7</span><br><span class="line">[root@VM-24-12-centos ~]# docker run -itd --name web2 --privileged=true -p 302:22 centos:7</span><br></pre></td></tr></table></figure>



<p>全部容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS          PORTS                                                  NAMES</span><br><span class="line">e34c86bb0435   centos:7    &quot;/bin/bash&quot;              7 seconds ago    Up 6 seconds    0.0.0.0:302-&gt;22/tcp, :::302-&gt;22/tcp                    web2</span><br><span class="line">08c818debfec   centos:7    &quot;/bin/bash&quot;              17 seconds ago   Up 16 seconds   0.0.0.0:301-&gt;22/tcp, :::301-&gt;22/tcp                    web1</span><br><span class="line">719c03f59c58   nginx       &quot;/docker-entrypoint.…&quot;   48 seconds ago   Up 47 seconds   0.0.0.0:202-&gt;80/tcp, :::202-&gt;80/tcp                    nginx2</span><br><span class="line">4411e0e5d7cb   nginx       &quot;/docker-entrypoint.…&quot;   58 seconds ago   Up 57 seconds   0.0.0.0:201-&gt;80/tcp, :::201-&gt;80/tcp                    nginx1</span><br><span class="line">495ee8a27741   centos:7    &quot;/bin/bash&quot;              13 minutes ago   Up 13 minutes   0.0.0.0:102-&gt;22/tcp, :::102-&gt;22/tcp                    lvsKeepalived2</span><br><span class="line">5c45ad280824   centos:7    &quot;/bin/bash&quot;              13 minutes ago   Up 13 minutes   0.0.0.0:101-&gt;22/tcp, :::101-&gt;22/tcp                    lvsKeepalived1</span><br><span class="line">9d54fbdb7e5f   redis       &quot;docker-entrypoint.s…&quot;   2 days ago       Up 2 days       0.0.0.0:6379-&gt;6379/tcp, :::6379-&gt;6379/tcp              myredis</span><br><span class="line">8f474f903dc2   mysql:5.7   &quot;docker-entrypoint.s…&quot;   6 days ago       Up 6 days       33060/tcp, 0.0.0.0:3313-&gt;3306/tcp, :::3313-&gt;3306/tcp   slave02</span><br><span class="line">07abacc7cfa4   mysql:5.7   &quot;docker-entrypoint.s…&quot;   6 days ago       Up 6 days       33060/tcp, 0.0.0.0:3312-&gt;3306/tcp, :::3312-&gt;3306/tcp   slave</span><br><span class="line">20a63bf1a35a   mysql:5.7   &quot;docker-entrypoint.s…&quot;   6 days ago       Up 6 days       33060/tcp, 0.0.0.0:3311-&gt;3306/tcp, :::3311-&gt;3306/tcp   master</span><br></pre></td></tr></table></figure>



<p>ip地址情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">172.17.0.5   # nginx1</span><br><span class="line">172.17.0.6   # nginx2</span><br><span class="line">172.17.0.7  # web1</span><br><span class="line">172.17.0.8  # web1</span><br><span class="line">172.17.0.9   # lvsKeepalived1</span><br><span class="line">172.17.0.10  # lvsKeepalived2</span><br></pre></td></tr></table></figure>



<p>配置lvskeepalived时，宿主机要开启ipvsadm，否则容器内会报错</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>集群</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql优化</title>
    <url>/mysql-advanced/</url>
    <content><![CDATA[<h1 id="mysql体系结构"><a href="#mysql体系结构" class="headerlink" title="mysql体系结构"></a>mysql体系结构</h1><p><img src="/./mysql-advanced/Snipaste_2022-03-14_22-59-50.jpg"></p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><blockquote>
<p>简介：</p>
</blockquote>
<p><strong>常用引擎对比</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>MylSAM</th>
<th>MEMORY</th>
<th>InnoDB</th>
<th>Archive</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>256TB</td>
<td>RAM</td>
<td>64TB</td>
<td>None</td>
</tr>
<tr>
<td>支持事务</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持全文索引</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>支持树索引</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持哈希索引</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>支持数据缓存</td>
<td>No</td>
<td>N/A</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持外键</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody></table>
<p>可以根据以下的原则来选择 MySQL 存储引擎：</p>
<ul>
<li>如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。</li>
<li>如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。</li>
<li>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。</li>
<li>如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><blockquote>
<p>简介：索引是帮助mysql高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护这满足特定查找的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>
</blockquote>
<p><img src="/./mysql-advanced/Snipaste_2022-03-14_23-10-20.jpg"></p>
<p>优点：</p>
<ul>
<li>提高数据检索的效率，降低数据库的IO成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引列也是要占用空间的</li>
<li>索引大大提高了查询效率，同时却也降低更新表的速度</li>
</ul>
<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B+Tree索引</strong></td>
<td><strong>最常见的索引类型，大部分引擎都支持B+树索引</strong></td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</td>
</tr>
<tr>
<td>R-tree（空间索引）</td>
<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-text（全文索引）</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式。类似于Licene，Solr，ES</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B+tree索引</strong></td>
<td><strong>支持</strong></td>
<td><strong>支持</strong></td>
<td><strong>支持</strong></td>
</tr>
<tr>
<td>Hash索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p><img src="/./mysql-advanced/Snipaste_2022-03-15_21-19-40.jpg"></p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-15_21-24-05.jpg"></p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-15_21-30-23.jpg"></p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-15_21-31-52.jpg"></p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-15_21-34-42.jpg"></p>
<p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的连表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-15_21-38-01.jpg"></p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-15_21-42-31.jpg"></p>
<p><strong>思考题：</strong></p>
<p>为什么InnoDB存储引擎选择使用B+Tree索引结构？</p>
<ul>
<li>相对于二叉树，层级更少，搜索效率高；</li>
<li>对于B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</li>
<li>相对Hash索引，B+Tree支持范围匹配以及排序操作；</li>
</ul>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是本文中的关键字，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引</td>
<td>将数据存储与索引放在一块，索引结构的叶子节点保存了行数据</td>
<td>必须有，而且只有一个</td>
</tr>
<tr>
<td>二级索引</td>
<td>将数据与索引分开存储，索引结构叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><ul>
<li><p>索引列运算</p>
<p>不要在索引列上进行运算操作，否则索引将失效</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-16_21-54-10.jpg"></p>
</li>
<li><p>字符串不加引号</p>
<p>字符串类型字段使用时，不加引号，索引将失效。</p>
</li>
<li><p>模糊查询</p>
<p>如果仅仅是在尾部模糊匹配，索引不会失效。如果头部模糊匹配，索引失效。</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-16_21-57-22.jpg"></p>
</li>
<li><p>or连接的条件</p>
<p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p>
</li>
</ul>
<h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><ul>
<li><p>创建索引</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-16_21-13-29.jpg"></p>
</li>
<li><p>查看索引</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-16_21-14-01.jpg"></p>
</li>
<li><p>删除索引</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-16_21-14-24.jpg"></p>
</li>
</ul>
<h2 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h2><ol>
<li><p>针对于数据量较大，且查询比较频繁的表建立索引。</p>
</li>
<li><p>针对于常作为查询条件（where)、排序（order by)、分组(group by)操作的字段建立索引。</p>
</li>
<li><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p>
</li>
<li><p>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p>
</li>
<li><p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p>
</li>
<li><p>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p>
</li>
<li><p>如果索引列不能存储NULL值，请在创建表时使用NOTNULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个<br>索引最有效地用于查询。</p>
</li>
</ol>
<h1 id="sql性能分析"><a href="#sql性能分析" class="headerlink" title="sql性能分析"></a>sql性能分析</h1><ul>
<li><p>sql执行频率</p>
<p>mysql客户端连接成功后，通过show[session|global]status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的insert、update、delete、select的访问频次：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>   # 七个下划线</span><br></pre></td></tr></table></figure></li>
<li><p>慢查询日志</p>
<p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有sql语句的日志。</p>
<p>mysql的慢查询日志默认没有开启，需要在mysql的配置文件（/etc/my.cnf）中配置如下信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 开启mysql慢日志查询开关</span><br><span class="line">slow_query_log=1</span><br><span class="line">#设置慢日志的时间为2秒，sql语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure>

<p>配置完毕之后，通过以下指令重新启动mysql服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/localhost-slow.log</p>
</li>
<li><p>profile详情</p>
<p>show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have</span>_profiling;</span><br></pre></td></tr></table></figure>

<p>默认profiling是关闭的，可以通过set语句在session/global级别开启profiling：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看每一条<span class="keyword">sql</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"># 查看指定query_id的<span class="keyword">sql</span>语句每个阶段的耗时情况</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"># 查看指定query_id的申请了语句CPU的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure></li>
<li><p>explain执行计划</p>
<p>EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 直接在<span class="keyword">select</span>语句之前加上关键字explain<span class="operator">/</span><span class="keyword">desc</span></span><br><span class="line">explain <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><ul>
<li><p>insert优化</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;jerry&#x27;</span>);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"># 优化方法</span><br><span class="line"># 批量</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;jerry&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 手动提交事务</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;tom&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;cat&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;tom&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;cat&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 主键顺序插入</span><br><span class="line">主键乱序插入：<span class="number">8</span> <span class="number">1</span> <span class="number">9</span> <span class="number">21</span> <span class="number">88</span> <span class="number">2</span> <span class="number">4</span> <span class="number">15</span> <span class="number">89</span> <span class="number">5</span> <span class="number">7</span> <span class="number">3</span></span><br><span class="line">主键顺序插入：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span> <span class="number">21</span> <span class="number">88</span> <span class="number">89</span></span><br></pre></td></tr></table></figure></li>
<li><p>大批量插入数据</p>
<p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。操作如下：</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-17_20-37-58.jpg"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数<span class="comment">--local-infile</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p</span></span><br><span class="line"># 设置全局参数<span class="keyword">local</span>——infile为<span class="number">1</span>，开启从本地加载文件导入数据的开关</span><br><span class="line"># 查看<span class="keyword">select</span> @<span class="variable">@local</span>_infile</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;root/sql.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">&#x27;tb_user&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines teminated <span class="keyword">by</span> <span class="string">&#x27;/n&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><ul>
<li><p>数据组织方式</p>
<p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table IOT）。</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-17_20-57-34.jpg"></p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-17_20-58-22.jpg"></p>
</li>
<li><p>页分裂</p>
<p>也可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据（如果一行数据多大，会行溢出），根据主键排列。</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-17_21-00-46.jpg"></p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-17_21-03-31.jpg"></p>
</li>
</ul>
<ul>
<li><p>页合并</p>
<p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p>
<p>当页中删除的记录达到MERGE THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-17_21-09-06.jpg"></p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-17_21-09-40.jpg"></p>
</li>
</ul>
<ul>
<li>主键设计原则<ul>
<li>满足业务需求的情况下，尽量降低主键的长度。</li>
<li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键</li>
<li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li>
<li>业务操作时，避免对主键的修改。</li>
</ul>
</li>
</ul>
<h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><ol>
<li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</li>
<li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 没有创建索引时，根据age, phone进行排序</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age, phone;</span><br><span class="line"># 创建索引</span><br><span class="line"><span class="keyword">create</span> index idx_user_age_phone_aa <span class="keyword">on</span> tb_user(age,phsne);</span><br><span class="line"># 创建索引后，根据age, phone进行升序排序</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age, phone;</span><br><span class="line"># 创建索引后，根据age, phone进行降序排序</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>, phone <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 根据age, phone进行降序一个升序，一个降序</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , phone <span class="keyword">desc</span>;</span><br><span class="line"># 创建索引</span><br><span class="line"><span class="keyword">create</span> index idx_user_age _phone_ad <span class="keyword">on</span> tb_user(age <span class="keyword">asc</span> ,phone <span class="keyword">desc</span>);</span><br><span class="line"># 根据age, phone进行降序一个升序，一个降序公</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , phone <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/./mysql-advanced/Snipaste_2022-03-17_21-28-52.jpg"></p>
<ul>
<li><p>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p>
</li>
<li><p>尽量使用覆盖索引。</p>
</li>
<li><p>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC/DESC)。</p>
</li>
<li><p>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</p>
</li>
</ul>
<h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#删除掉目前的联合索引 idx_user_pro_age_sta</span><br><span class="line"><span class="keyword">drop</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user;</span><br><span class="line">#执行分组操作，根据profession字段分组</span><br><span class="line">explain <span class="keyword">select</span> profession , <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession ;</span><br><span class="line">#创建索引</span><br><span class="line"><span class="keyword">Create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession , age , status);</span><br><span class="line">#执行分组操作，根据profession字段分组</span><br><span class="line">explain <span class="keyword">select</span> profession , <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession;</span><br><span class="line">#执行分组操作，根据profession字段分组</span><br><span class="line">explain <span class="keyword">select</span> profession , <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession, age;</span><br></pre></td></tr></table></figure>

<ul>
<li>在分组操作时，可以通过索引来提高效率</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的</li>
</ul>
<h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>一个常见又非常头疼的问题就是limit 2000000,10，此时需要MySQL排序前2000010记录，仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。</p>
<p>优化思路：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> tb_sku t , (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> tid <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure>



<h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><ul>
<li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li>
<li>InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>
<p>优化思路：自己计数。</p>
<ul>
<li>count的几种用法<ul>
<li>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加，最后返回累计值。</li>
<li>用法:count (*) 、count(主键)、count(字段)、count ( 1)<ul>
<li>count （主键)<br>InnoDB引擎会遍历整张表，把每一行的主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)。</li>
<li>count（字段)<br>没有not null约束: InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。有not null约束: InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</li>
<li>count ( 1)<br>InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。</li>
<li>count (*)<br>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1) s count(*)。</p>
<p>所以尽量使用count(*)</p>
<h2 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update student <span class="keyword">set</span> <span class="keyword">no</span><span class="operator">=</span><span class="string">&#x27;2000100100&#x27;</span><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">update student <span class="keyword">set</span> <span class="keyword">no</span> <span class="operator">=</span><span class="string">&#x27;2000100105&#x27;</span><span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;韦一笑&quot;;</span></span><br></pre></td></tr></table></figure>

<p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁,并且该索引不能失效，否则会从行锁升级为表锁。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>插入数据<br>insert:批量插入、手动控制事务、主键顺序插入</p>
<p>大批量插入: load data local infile</p>
</li>
<li><p>主键优化<br>主键长度尽量短、顺序插入<br>AUTO_INCREMENT UUID</p>
</li>
<li><p>order by优化<br>using index:直接通过索引返回数据，性能高</p>
<p>using filesort:需要将返回的结果在排序缓冲区排序</p>
</li>
<li><p>group by优化</p>
<p>索引，多字段分组满足最左前缀法则</p>
</li>
<li><p>limit优化<br>覆盖索引＋子查询</p>
</li>
<li><p>count优化<br>性能: count(字段)&lt;count(主键id)&lt;count(1) s count(*)</p>
</li>
<li><p>update优化<br>尽量根据主键/索引字段进行数据更新</p>
</li>
</ol>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p>错误日志是MySQL中最重要的日志之一，它记录了当mysqld启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</p>
<p>该日志是默认开启的，默认存放目录/var/log/，默认的日志文件名为mysqld.log。查看日志位置:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><p>二进制日志（BINLOG)记录了所有的DDL(数据定义语言）语句和DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW)语句。</p>
<p>作用：①.灾难时的数据恢复;</p>
<p>​            ②.MySQL的主从复制。在MySQL8版本中，默认二进制日志是开启着的，涉及到的参数如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>日志格式</p>
<p>MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下：</p>
<table>
<thead>
<tr>
<th>日志格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>STATEMENT</td>
<td>基于SQL语句的日志记录，记录的是sQL语句，对数据进行修改的sQL都会记录在日志文件中。</td>
</tr>
<tr>
<td>ROW</td>
<td>基于行的日志记录，记录的是每一行的数据变更。（默认</td>
</tr>
<tr>
<td>MIXED</td>
<td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>日志查看</p>
<p>由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具mysqlbinlog 来查看，具体语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog[参数选项] logfilename</span><br><span class="line">参数选项:</span><br><span class="line">-d   指定数据库名称，只列出指定的数据库相关操作。</span><br><span class="line">-o   忽略掉日志中的前n行命令。</span><br><span class="line">-v   将行事件(数据变更)重构为SQL语句</span><br><span class="line">-w   将行事件(数据变更)重构为5QL语句，并输出注释信息</span><br></pre></td></tr></table></figure></li>
<li><p>日志删除</p>
<p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>reset master</td>
<td>删除全部binlog日志，删除之后,日志编号，将从binlog.000001重新开始</td>
</tr>
<tr>
<td>purge master loas to ‘binlnn.*********</td>
<td>删除*****编号之前的所有日志</td>
</tr>
<tr>
<td>purge master logs before ‘yyyy-mm-dd hh24:mi:ss’</td>
<td>删除日志为”yyyy-mm-dd hh24:mi:ss”之前产生的所有日志</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h2><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的。如果需要开启查询日志，可以设置以下配置︰</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>修改mysql的配置文件/etc/my.cnf文件，添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">该选项用来开启查询日志,可选值:0或者1;0代表关闭，1代表开启</span></span><br><span class="line">general_log=1</span><br><span class="line"><span class="meta">#</span><span class="bash">f设置日志的文件名,如果没有指定，默认的文件名为host_name.log</span></span><br><span class="line">general_log_file=mysql_query.log</span><br></pre></td></tr></table></figure>



<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>慢查询日志记录了所有执行时间超过参数long_query_time 设置值并且扫描记录数不小于min_examined_row_limit的所有的SQL语句的日志，默认未开启。long_query_time默认为10秒，最小为0，精度可以到微秒。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">慢查询日志</span></span><br><span class="line">slow query log=1</span><br><span class="line"><span class="meta">#</span><span class="bash">执行时间参数</span></span><br><span class="line">long query time=2</span><br></pre></td></tr></table></figure>



<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><blockquote>
<p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p>
<p>MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。</p>
</blockquote>
<p>MySQL复制的有点主要包含以下三个方面:</p>
<ul>
<li><p>主库出现问题，可以快速切换到从库提供服务。</p>
</li>
<li><p>实现读写分离，降低主库的访问压力。</p>
</li>
<li><p>可以在从库中执行备份，以避免备份期间影响主库服务。</p>
</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>mysql主从复制原理如下。</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-18_20-15-27.jpg"></p>
<p>从上图来看，复制分成三步:</p>
<ol>
<li>Master主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li>
<li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log 。</li>
<li>slave重做中继日志中的事件，将改变反映它自己的数据。</li>
</ol>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><ul>
<li>问题分析</li>
</ul>
<p><img src="/./mysql-advanced/Snipaste_2022-03-18_20-36-42.jpg"></p>
<p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈:</p>
<ol>
<li>IO瓶颈:热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。请求数据太多带宽不够，网络IO瓶颈。</li>
<li>CPU瓶颈:排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多CPU出现瓶颈。</li>
</ol>
<p><img src="/./mysql-advanced/Snipaste_2022-03-18_20-37-40.jpg"></p>
<p>分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。</p>
<h2 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h2><p><img src="/./mysql-advanced/Snipaste_2022-03-18_20-39-35.jpg"></p>
<ul>
<li><p>垂直拆分</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-18_20-41-02.jpg"></p>
<p>垂直分库:</p>
<p>以表为依据，根据业务将不同表拆分到不同库中。特点:</p>
<p>1.每个库的表结构都不一样。</p>
<p>2.每个库的数据也不一样。</p>
<p>3.所有库的并集是全量数据。</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-18_20-43-28.jpg"></p>
<p>垂直分表:</p>
<p>以字段为依据，根据字段属性将不同字段拆分到不同表中。特点:</p>
<p>1.每个表的结构都不一样。</p>
<p>2.每个表的数据也不一样，一般通过一列（主键/外键）关联。3．所有表的并集是全量数据。</p>
</li>
</ul>
<ul>
<li><p>水平拆分</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-18_20-45-04.jpg"></p>
<p>水平分库:</p>
<p>以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。<br>特点:<br>1.每个库的表结构都一样。</p>
<p>2.每个库的数据都不一样。</p>
<p>3.所有库的并集是全量数据。</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-18_20-45-46.jpg"></p>
<p>水平分表:</p>
<p>以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。<br>特点:<br>1.每个表的表结构都一样。</p>
<p>2.每个表的数据都不一样。</p>
<p>3．所有表的并集是全量数据。</p>
</li>
</ul>
<ul>
<li><p>实现技术</p>
<p>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及shardingJDBC。</p>
</li>
</ul>
<h2 id="mycat分片"><a href="#mycat分片" class="headerlink" title="mycat分片"></a>mycat分片</h2><ul>
<li><p>垂直分片</p>
<p>场景：</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-19_20-11-19.jpg"></p>
<p>准备：</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-19_20-11-54.jpg"></p>
<p>分别再三台mysql中创建数据库shopping</p>
<p>配置：</p>
<p><img src="/./mysql-advanced/Snipaste_2022-03-19_20-13-58.jpg"></p>
</li>
</ul>
<h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><blockquote>
<p>读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。</p>
<p>通过MyCat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。</p>
</blockquote>
<p><img src="/./mysql-advanced/Snipaste_2022-03-20_20-23-51.jpg"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s-base</title>
    <url>/k8s-base/</url>
    <content><![CDATA[<p>文档来自：<a href="https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/9EX8Cp45">📚 Kubenetes（K8S）简介 - K8S 教程 - 易文档 (easydoc.net)</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>它是一个为 <strong>容器化</strong> 应用提供集群部署和管理的开源工具，由 Google 开发。<br>kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。它的目的就是是实现资源管理的自动化，主要提供了如下的主要功能：</p>
<ul>
<li><p>自我修复：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器</p>
</li>
<li><p>弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整</p>
</li>
<li><p>服务发现：服务可以通过自动发现的形式找到它所依赖的服务</p>
</li>
<li><p>负载均衡：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</p>
</li>
<li><p>版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</p>
</li>
<li><p>存储编排:可以根据容器自身的需求自动创建存储卷</p>
</li>
</ul>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-11_20-53-03.jpg"></p>
<p><strong>不同的应用部署方案</strong></p>
<p>在部署应用程序的方式上，主要经历了三个时代：</p>
<ul>
<li><p>传统部署：互联网早期，会直接将应用程序部署在物理机上</p>
<blockquote>
<p>优点：简单，不需要其它技术的参与</p>
<p>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</p>
</blockquote>
</li>
<li><p>虚拟化部署：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p>
<blockquote>
<p>优点：程序环境不会相互影响，提供一定程度的安全性</p>
<p>缺点：增加了操作系统，浪费了部分资源</p>
</blockquote>
</li>
<li><p>容器化部署：与虚拟化类似，但是共享了操作系统</p>
<blockquote>
<p>优点：</p>
<p>​        可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</p>
<p>​        运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</p>
<p>​        容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p>
</blockquote>
</li>
</ul>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\kwmxgxwp.svg"></p>
<p>容器化部署方式带来了很多的遍历，但是也会出现一些问题，比如说“</p>
<ul>
<li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li>
<li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li>
</ul>
<p>这些容器管理的问题统称为容器编排问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：</p>
<ul>
<li>Swarm：Docker自己的容器编排工具</li>
<li>Mesos：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li>
<li>Kubernetes：Google开源的容器编排工具</li>
</ul>
<h2 id="什么时候需要k8s？"><a href="#什么时候需要k8s？" class="headerlink" title="什么时候需要k8s？"></a>什么时候需要k8s？</h2><p>当你的应用只是跑在一台机器，直接一个 docker + docker-compose 就够了，方便轻松；<br>当你的应用需要跑在 3，4 台机器上，你依旧可以每台机器单独配置运行环境 + 负载均衡器；<br>当你应用访问数不断增加，机器逐渐增加到十几台、上百台、上千台时，每次加机器、软件更新、版本回滚，都会变得非常麻烦、痛不欲生，再也不能好好的摸鱼了，人生浪费在那些没技术含量的重复性工作上。</p>
<p>这时候，Kubernetes 就可以一展身手了，让你轻松管理百万千万台机器的集群。“谈笑间，樯橹灰飞烟灭”，享受着一手掌控所有，年薪百万指日可待。</p>
<p>Kubernates 可以为你提供集中式的管理集群机器和应用，加机器、版本升级、版本回滚，那都是一个命令就搞定的事，不停机的灰度更新，确保高可用、高性能、高扩展。</p>
<h2 id="Kubernetes组件"><a href="#Kubernetes组件" class="headerlink" title="Kubernetes组件"></a>Kubernetes组件</h2><p>一个Kubernetes集群主要是由**控制节点(master)、工作节点(node)**构成，每个节点上都会安装不同的组件。</p>
<p>master：集群的控制平面，负责集群的决策</p>
<blockquote>
<p>ApiServer：资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制</p>
<p>Scheduler：负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上</p>
<p>ControllerManager：负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等</p>
<p>Etcd：负责存储集群中各种资源对象的信息</p>
</blockquote>
<p>node：集群的数据平面，负责为容器提供运行环境</p>
<blockquote>
<p>Kubelet:负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器</p>
<p>KubeProxy:负责提供集群内部的服务发现和负载均衡</p>
<p>Docker:负责节点上容器的各种操作</p>
</blockquote>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-11_21-04-25.jpg"></p>
<p>下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系:</p>
<ol>
<li><p>首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中</p>
</li>
<li><p>一个nginx服务的安装请求会首先被发送到master节点的apiServer组件</p>
</li>
<li><p>apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上<br>在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer</p>
</li>
<li><p>apiServer调用controller-manager去调度Node节点安装nginx服务</p>
</li>
<li><p>kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod<br>pod是kubernetes的最小操作单元，容器必须跑在pod中至此</p>
</li>
<li><p>一个Nginx服务就运行了，如果需要访问Nginx，就需要通过kube-proxy来对pod产生访问代理</p>
<p>这样，外界用户就可以访问集群中的Nginx服务了</p>
</li>
</ol>
<h5 id="Kubernetes-组件"><a href="#Kubernetes-组件" class="headerlink" title="Kubernetes 组件"></a>Kubernetes 组件</h5><p><code>kube-apiserver</code> API 服务器，公开了 Kubernetes API<br><code>etcd</code> 键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库<br><code>kube-scheduler</code> 调度 Pod 到哪个节点运行<br><code>kube-controller</code> 集群控制器<br><code>cloud-controller</code> 与云服务商交互</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\kwonmx7e.png"></p>
<h2 id="k8s集群架构"><a href="#k8s集群架构" class="headerlink" title="k8s集群架构"></a>k8s集群架构</h2><p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\kwob90mh.png"></p>
<h5 id="master"><a href="#master" class="headerlink" title="master"></a>master</h5><p>主节点，控制平台，不需要很高性能，不跑任务，通常一个就行了，也可以开多个主节点来提高集群可用度。</p>
<h5 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h5><p>工作节点，可以是虚拟机或物理计算机，任务都在这里跑，机器性能需要好点；通常都有很多个，可以不断加机器扩大集群；每个工作节点由主节点管理</p>
<h5 id="重要概念-Pod"><a href="#重要概念-Pod" class="headerlink" title="重要概念 Pod"></a>重要概念 Pod</h5><p>豆荚，K8S 调度、管理的最小单位，一个 Pod 可以包含一个或多个容器，每个 Pod 有自己的虚拟IP。一个工作节点可以有多个 pod，主节点会考量负载自动调度 pod 到哪个节点运行。</p>
<p><strong>Controller</strong></p>
<p>控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数是等等</p>
<p><strong>Service</strong></p>
<p>pod对外服务的统一入口，下面可以维护者同一类的多个pod</p>
<p><strong>Label</strong></p>
<p>标签，用于对pod进行分类，同一类pod会拥有相同的标签</p>
<p><strong>NameSpace</strong></p>
<p>命名空间，用来隔离pod的运行环境</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\kwoccq7d.jpg"></p>
<p><strong>k8s架构</strong></p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-11_15-51-49.jpg"></p>
<p>APISERVER：所有服务访问统一入口</p>
<p>CrontrollerManager：维持副本期望数目</p>
<p>Scheduler：负责介绍任务…选择合适的节点进行分配任务.</p>
<p>ETCD：键值对数据库储存K8s集群所有重要信息（持久化）</p>
<p>Kubelet：真接跟容器弘警交互实现容器的生命周期管理</p>
<p>Kube-poxy：负责写入规则至IPTABLES、IPVS实现服务映射访问的</p>
<p>COREDNS：可以为集群中的SVC创建一个域名IP的对应关系解析</p>
<p>DASHBOARD：给K8S 集群提供一个B/S结构访点体系</p>
<p>INGRESS CONTROLLER：官方只能实现四层代理，INGRESS 可以实现七层代理</p>
<p>FEDERATION：提供一个可以跨集群中心多K8S统一管官理功能</p>
<p>PROMETHEUS：提供K8S集群的监控能力</p>
<p>ELK：提供K8s集群巳志统一分析介入平台</p>
<h2 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h2><p><strong>pod类型：</strong></p>
<ul>
<li>自助式pod</li>
<li>控制器管理的pod</li>
</ul>
<p><strong>pod控制器类型</strong></p>
<ul>
<li><p>ReplicationController &amp; ReplicaSet &amp; Deployment</p>
<ul>
<li>HPA (HorizontalPodAutoScale)</li>
</ul>
</li>
<li><p>StatefullSet</p>
</li>
<li><p>DaemonSet</p>
</li>
<li><p>Job，Cronjob</p>
</li>
</ul>
<blockquote>
<p>ReplicationController用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的 Pod 来替代;而如果异常多出来的容器也会自动回收。在新版本的Kubernetes中建议使用ReplicaSet来取代 ReplicationControlle</p>
<p>ReplicaSet 跟ReplicationController没有本质的不同，只是名字不一样，并且ReplicaSet支持集合式的 selector</p>
<p>虽然ReplicaSet可以独立使用，但一般还是建议使用Deployment来自动管理ReplicaSet ，这样就无需担心跟其他机制的不兼容问题（比如 ReplicaSet 不支持rolling-update但 Deployment支持)</p>
</blockquote>
<blockquote>
<p><strong>StatefulSet</strong> 是为了解决有状态服务的问题(对应Deployments和ReplicaSets是为无状态服务而设计），其应用场景包括:</p>
<ul>
<li>稳定的持久化存储，即 Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li>
<li>稳定的网络标志，即 Pod重新调度后其 PodName和 HostName不变，基于Headless Service(即没有Cluster IP的 Service )来实现</li>
</ul>
<ul>
<li>有序部署，有序扩展，即 Pod 是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行(即从О到N-1，在下一个Pod运行之前所有之前的 Pod必须都是Running 和 Ready状态），基于init containers 来实现</li>
<li>有序收缩，有序删除（即从 N-1到0)</li>
</ul>
</blockquote>
<blockquote>
<p><strong>DaemonSet</strong>确保全部(或者一些)Node 上运行一个Pod 的副本。当有 Node 加入集群时，也会为他们新增一个Pod 。当有 Node 从集群移除时，这些 Pod 也会被回收。删除DaemonSet 将会删除它创建的所有Pod</p>
<p>使用DaemonSet 的一些典型用法:</p>
<ul>
<li><p>运行集群存储daemon，例如在每个Node上运行glusterd、cepho</p>
</li>
<li><p>在每个Node 上运行日志收集daemon，例如fluentd、logstash</p>
</li>
<li><p>在每个Node 上运行监控daemon，例如Prometheus Node Exporter</p>
</li>
</ul>
</blockquote>
<h2 id="网络通讯方式"><a href="#网络通讯方式" class="headerlink" title="网络通讯方式"></a>网络通讯方式</h2><p>Kubernetes 的网络模型假定了所有Pod都在一个可以直接连通的扁平的网络空间中，这在GCE (Google Compute Engine）里面是现成的网络模型，Kubernetes假定这个网络已经存在。而在私有云里搭建Kubernetes集群，就不能假定这个网络已经存在了。我们需要自己实现这个网络假设，将不同节点上的 Docker容器之间的互相访问先打通，然后运行Kubernetes</p>
<p>同一个Pod内的多个容器之间:lo</p>
<p>Pod 之间的通讯：Overlay Network</p>
<p>Pod 与 Service之间的通讯：各节点的 Iptables规则</p>
<p>Flannel是CoreOS团队针对Kubernetes 设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的Docker容器都具有全集群唯一的虚拟IP地址。而且它还能在这些IP地址之间建立一个覆盖网络（Overlay Network)，通过这个覆盖网络，将数据包原封<br>不动地传递到目标容器内</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-11_16-28-30.jpg"></p>
<p>ETCD之Flannel 提供说明：</p>
<ul>
<li><p>存储管理Flannel 可分配的IP地址段资源</p>
</li>
<li><p>监控ETCD中每个Pod 的实际地址，并在内存中建立维护Pod节点路由表</p>
</li>
</ul>
<p>同一个Pod 内部通讯：同一个Pod共享同一个网络命名空间，共享同一个Linux 协议栈</p>
<p>Pod1至Pod2</p>
<ul>
<li><p>Pod1与 Pod2不在同一台主机，Pod的地址是与docker0在同一个网段的，但dockerO网段与宿主机网卡是两个完全不同的IP网段，并且不同Node之间的通信只能通过宿主机的物理网卡进行。将Pod的IP和所在Node的IP关联起来，通过这个关联让Pod可以互相访问</p>
</li>
<li><p>Pod1 与 Pod2在同一台机器，由Docker0网桥直接转发请求至 Pod2，不需要经过 Flannel 演示</p>
</li>
</ul>
<p>Pod 至Service 的网络:目前基于性能考虑，全部为iptables（这个比较老了，现在用LVS）维护和转发</p>
<p>Pod到外网: Pod向外网发送请求，查找路由表，转发数据包到宿主机的网卡，宿主网卡完成路由选择后，iptables执行Masquerade，把源IP更改为宿主网卡的IP，然后向外网服务器发送请求</p>
<p>外网访问Pod：Service</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-11_16-36-24.jpg"></p>
<h1 id="集群环境搭建"><a href="#集群环境搭建" class="headerlink" title="集群环境搭建"></a>集群环境搭建</h1><h2 id="环境规划"><a href="#环境规划" class="headerlink" title="环境规划"></a>环境规划</h2><h3 id="集群类型"><a href="#集群类型" class="headerlink" title="集群类型"></a>集群类型</h3><p>kubernetes集群大体上分为两类：<strong>一主多从</strong>和<strong>多主多从</strong></p>
<ul>
<li>一主多从：一台Master节点和多台Node节点，搭建简单，但是单机故障风险，适合用于测试环境</li>
<li>多主多从：多台Master节点和多台Node节点，搭建麻烦，安全性高，适合用于生产环境</li>
</ul>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-11_21-25-31.jpg"></p>
<h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><p>kubernetes有多种部署方式，目前主流的方式有kubeadm、minikube、二进制包</p>
<ul>
<li>minikube：一个用于快速搭建单节点kubernetes的工具</li>
<li>kubeadm：一个用于快速搭建kubernetes集群的工具</li>
<li>二进制包：从官网下载每个组件的二进制包，依次去安装，此方式对于理解kubernetes组件更加有效</li>
</ul>
<h3 id="主机规划"><a href="#主机规划" class="headerlink" title="主机规划"></a>主机规划</h3><table>
<thead>
<tr>
<th>作用</th>
<th>IP地址</th>
<th>操作系统</th>
<th>配置</th>
</tr>
</thead>
<tbody><tr>
<td>Master</td>
<td>192.168.31.100</td>
<td>centos7  基础设施服务器</td>
<td>2颗CPU  2G内存  50G硬盘</td>
</tr>
<tr>
<td>Node1</td>
<td>192.168.31.101</td>
<td>centos7  基础设施服务器</td>
<td>2颗CPU  2G内存  50G硬盘</td>
</tr>
<tr>
<td>Node2</td>
<td>192.168.31.102</td>
<td>centos7  基础设施服务器</td>
<td>2颗CPU  2G内存  50G硬盘</td>
</tr>
</tbody></table>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>本次环境搭建需要安装三台Centos服务器(一主二从)，然后在每台服务器中分别安装docker (18.06.3)，kubeadm (1.17.4) , kubelet (1.17.4) , kubectl (1.17.4）程序。</p>
<h3 id="主机安装"><a href="#主机安装" class="headerlink" title="主机安装"></a>主机安装</h3><p>本次环境搭建需要安装三台Centos服务器（一主二从)，然后在每台服务器中分别安装docker (18.06.3)，kubeadm (1.17.4) . kubelet (1.17.4) , kubectl (1.17.4）程序。</p>
<h3 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h3><p>1、检查操作系统的版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此方式安装kubernetes集群要求centos版本要在7.5或之上</span></span><br><span class="line">[root@master ~]# cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.5.1804 (Core)</span><br></pre></td></tr></table></figure>



<p>2、主机名解析</p>
<p>为了方便后面集群节点间的直接调用，在这配置一下主机名解析，企业中推荐使用内部DNS服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 主机名解析 编辑三台服务器的/etc/hosts文件，添加下面内容</span></span><br><span class="line">192.168.59.100 master</span><br><span class="line">192.168.59.101 node1</span><br><span class="line">192.168.59.102 node2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证，可以互相ping</span></span><br><span class="line">[root@master ~]# ping node1</span><br><span class="line">PING node1 (192.168.59.101) 56(84) bytes of data.</span><br><span class="line">64 bytes from node1 (192.168.59.101): icmp_seq=1 ttl=64 time=11.1 ms</span><br><span class="line">64 bytes from node1 (192.168.59.101): icmp_seq=2 ttl=64 time=0.282 ms</span><br><span class="line">64 bytes from node1 (192.168.59.101): icmp_seq=3 ttl=64 time=0.308 ms</span><br></pre></td></tr></table></figure>



<p>3、时间同步</p>
<p>kubernetes要求集群中的节点时间必须精确一致，这里直接使用chronyd服务从网络同步时间</p>
<p>企业中建议配置内部的时间同步服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动chronyd服务</span></span><br><span class="line">[root@master ~]# systemctl start chronyd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置chronyd服务开启自启</span></span><br><span class="line">[root@master ~]# systemctl enable chronyd</span><br><span class="line"><span class="meta">#</span><span class="bash"> chronyd服务启动稍等几秒钟，就可以使用date命令验证时间了</span></span><br><span class="line">[root@master ~]# date</span><br></pre></td></tr></table></figure>



<p>4、禁用iptables和firewalld服务</p>
<p>kubernetes和docker在运行中会产生大量的iptables规则，为了不让系统规则跟它们混淆，直接关闭系统的规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭firewalld服务</span></span><br><span class="line">[root@master ~]# systemctl stop firewalld</span><br><span class="line">[root@master ~]# systemctl disable firewalld</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭iptables服务</span></span><br><span class="line">[root@master ~]# systemctl stop iptables</span><br><span class="line">[root@master ~]# systemctl disable iptables</span><br></pre></td></tr></table></figure>



<p>5、禁用selinux</p>
<p>selinux是Linux系统下的一个安全服务，如果不关闭它，在安装集群中会产生各种各样的奇葩问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编辑/etc/selinux/config 文件，修改SELINUX的值为disabled</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意修改完毕之后需要重启Linux服务</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>



<p>6、禁用swap分区</p>
<p>swap分区指的是虚拟内存分区，它的作用是在物理内存使用完之后，将磁盘空间虚拟成内存来使用</p>
<p>启用swap设备会对系统的性能产生非常负面的影响，因此kubernetes要求每个节点都要禁用swap设备</p>
<p>但是如果因为某些原因确实不能关闭swap分区，就需要在集群安装过程中通过明确的参数进行配置说明</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编辑分区配置文件/etc/fstab，注释swap分区一行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意修改完毕之后需要重启Linux服务</span></span><br><span class="line">UUID=455c753-7a60-4c17-a424-7741728c44a1 /boot   xfs   defaults   0 0</span><br><span class="line">/dev/mappar/centos-home /home                    xfs   defaults   0 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> /dev/mapper/centos-swap swap                   swap  defaults   0 0</span></span><br></pre></td></tr></table></figure>



<p>7、修改Linux的内核参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改Linux的内核参数，添加网桥过滤和地址转发功能</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑/etc/sysctl.d/kubernetes.conf，添加如下配置：</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载配置</span></span><br><span class="line">[root@master ~]# sysctl -p</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载网桥过滤模块</span></span><br><span class="line">[root@master ~]# modprobe br_netfilter</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网桥过滤模块是否加载成功</span></span><br><span class="line">[root@master ~]# lsmod | grep br_netfilter</span><br></pre></td></tr></table></figure>

<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-12_16-00-29.jpg"></p>
<p>8、配置ipvs功能</p>
<p>在kubernetes中service有两种代理模式，一种是基于iptables的，一种是基于ipvs的</p>
<p>两者比较的话，ipvs的性能明显要高一些，但是如果要使用它，需要手动加载ipvs模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1 安装ipset和ipvsadm</span></span><br><span class="line">[root@master ~]# yum install ipset ipvsadmin -y</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 添加需要加载的模块写入脚本文件</span></span><br><span class="line">[root@master ~]# cat &lt;&lt;EOF &gt; /etc/sysconfig/modules/ipvs.modules</span><br><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3 为脚本文件添加执行权限</span></span><br><span class="line">[root@master ~]# chmod +x /etc/sysconfig/modules/ipvs.modules</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 执行脚本文件</span></span><br><span class="line">[root@master ~]# /bin/bash /etc/sysconfig/modules/ipvs.modules</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5 查看对应的模块是否加载成功</span></span><br><span class="line">[root@master ~]# lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>

<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-12_16-41-43.jpg"></p>
<p>9、重启服务器</p>
<p>上面步骤完成之后，需要重新启动Linux系统</p>
<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1 切换镜像源</span></span><br><span class="line">[root@master ~]# wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 查看当前镜像源中支持的docker版本</span></span><br><span class="line">[root@master ~]# yum list docker-ce --showduplicates</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3 安装特定版本的docker-ce</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 必须指定--<span class="built_in">setopt</span>=obsoletes=0，否则yum会自动安装更高版本</span></span><br><span class="line">[root@master ~]# yum install --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7 -y</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 添加一个配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Docker在默认情况下使用的Cgroup Driver为cgroupfs，而kubernetes推荐使用systemd来代替cgroupfs</span></span><br><span class="line">[root@master ~]# mkdir /etc/docker</span><br><span class="line">[root@master ~]# cat &lt;&lt;EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">	&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">	&quot;registry-mirrors&quot;: [&quot;https://kn0t2bca.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5 启动docker</span></span><br><span class="line">[root@master ~]# systemctl restart docker</span><br><span class="line">[root@master ~]# systemctl enable docker</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6 检查docker状态和版本</span></span><br><span class="line">[root@master ~]# docker version</span><br></pre></td></tr></table></figure>



<h3 id="安装kubernetes组件"><a href="#安装kubernetes组件" class="headerlink" title="安装kubernetes组件"></a>安装kubernetes组件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于kubernetes的镜像源在国外，速度比较慢，这里切换成国内的镜像源</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑/etc/yum.repos.d/kubernetes.repo，添加下面的配置</span></span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">	   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">	   </span><br><span class="line"><span class="meta">#</span><span class="bash">安装kubeadm、kubelet和kubectl</span></span><br><span class="line">[root@master ~]# yum install --setopt=obsoletes=0 kubeadm-1.17.4-0 kubelet-1.17.4-0 kubectl-1.17.4-0 -y</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">配置kubelet的cgroup</span></span><br><span class="line"><span class="meta">#</span><span class="bash">编辑/etc/sysconfig/kubelet，添加下面的配置</span></span><br><span class="line">KUBELET_CGROUP_ARGS=&quot;--cgroup-driver=systemd&quot;</span><br><span class="line">KUBE_PROXY_MODE=&quot;ipvs&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">4设置kubelet开机自启</span></span><br><span class="line">[root@master ~]# systemctl enable kubelet</span><br></pre></td></tr></table></figure>



<h3 id="准备集群镜像"><a href="#准备集群镜像" class="headerlink" title="准备集群镜像"></a>准备集群镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在安装kubernetes集群之前，必须要提前准备好集群需要的镜像，所需镜像可以通过下面命令查看</span></span><br><span class="line">[root@master ~]# kubeadm config images list</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义镜像，直接命令行执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">此镜像在kubernetes的仓库中,由于网络原因,无法连接，下面提供了一种替代方案</span></span><br><span class="line">images=(</span><br><span class="line">	kube-apiserver:v1.17.4</span><br><span class="line">	kube-controller-manager:v1.17.4</span><br><span class="line">	kube-scheduler:v1.17.4</span><br><span class="line">	kube-proxy:v1.17.4</span><br><span class="line">	pause:3.1</span><br><span class="line">	etcd:3.4.3-0</span><br><span class="line">	coredns:1.6.5</span><br><span class="line">)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像，直接命令行执行</span></span><br><span class="line">for imageName in $&#123;images[@]&#125; ; do</span><br><span class="line">	docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName</span><br><span class="line">	docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName</span><br><span class="line">k8s.gcr.io/$imageName</span><br><span class="line">	docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>以上方法我安装有问题，我使用以下脚本方法正确</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim get_images.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">KUBE_VERSION=v1.17.4</span><br><span class="line">KUBE_PAUSE_VERSION=3.1</span><br><span class="line">ETCD_VERSION=3.4.3-0</span><br><span class="line">CORE_DNS_VERSION=1.6.5</span><br><span class="line"></span><br><span class="line">GCR_URL=k8s.gcr.io</span><br><span class="line">ALIYUN_URL=registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line"></span><br><span class="line">images=(kube-proxy:$&#123;KUBE_VERSION&#125;</span><br><span class="line">kube-scheduler:$&#123;KUBE_VERSION&#125;</span><br><span class="line">kube-controller-manager:$&#123;KUBE_VERSION&#125;</span><br><span class="line">kube-apiserver:$&#123;KUBE_VERSION&#125;</span><br><span class="line">pause:$&#123;KUBE_PAUSE_VERSION&#125;</span><br><span class="line">etcd:$&#123;ETCD_VERSION&#125;</span><br><span class="line">coredns:$&#123;CORE_DNS_VERSION&#125;)</span><br><span class="line"></span><br><span class="line">for imageName in $&#123;images[@]&#125; ; do</span><br><span class="line">  docker pull $ALIYUN_URL/$imageName</span><br><span class="line">  docker tag  $ALIYUN_URL/$imageName $GCR_URL/$imageName</span><br><span class="line">  docker rmi $ALIYUN_URL/$imageName</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h3 id="集群初始化"><a href="#集群初始化" class="headerlink" title="集群初始化"></a>集群初始化</h3><p>下面开始对集群进行初始化，并将node节点加入到集群中</p>
<blockquote>
<p>下面操作只需要在master节点上执行即可</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建集群</span></span><br><span class="line">[root@master ~]# kubeadm init \</span><br><span class="line">	--kubernetes-version=v1.17.4 \</span><br><span class="line">	--pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">	--service-cidr=10.96.0.0/12 \</span><br><span class="line">	--apiserver-advertise-address=192.168.59.100</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建必要文件</span></span><br><span class="line">[root@master ~]# mkdir -p $HOME/ .kube</span><br><span class="line">[root@master ~]# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">[root@master ~]# sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>

<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-13_17-05-09.jpg"></p>
<p>按照提示执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>



<p>要想node加入到master中，只需在node1和node2中执行一下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.59.100:6443 --token x7x7ro.kqkvdzicqx8ddc33 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:ce7fece5010f0bd0e11cf163caaeae1ede57daff9486db7f3a16bf3bafe6e52d</span><br></pre></td></tr></table></figure>



<p>这时，在master中就可以看到节点信息了</p>
<figure class="highlight plaintext"><figcaption><span>~]# kubectl get nodes</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get nodes</span><br><span class="line">NAME     STATUS     ROLES    AGE     VERSION</span><br><span class="line">master   NotReady   master   9m11s   v1.17.4</span><br><span class="line">node1    NotReady   &lt;none&gt;   20s     v1.17.4</span><br><span class="line">node2    NotReady   &lt;none&gt;   17s     v1.17.4</span><br></pre></td></tr></table></figure>

<p>但是此处的STATUS是NotReady，因为网络还没有搭建</p>
<h3 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h3><p>kubernetes支持多种网络插件，比如flannel、calico、canal等等，任选一种使用即可，本次选择flannel</p>
<blockquote>
<p>下面操作依旧只在master节点执行即可，插件使用的是DaemonSet的控制器，它会在每个节点上都运行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取fannel的配置文件</span></span><br><span class="line">[root@master ~] # wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改文件中quay.io仓库为quay-mirror.qiniu.com</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">使用配置文件启动fannel</span></span><br><span class="line">[root@master ~]# kubectl apply -f kube-flannel.yml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">稍等片刻,再次查看集群节点的状态</span></span><br><span class="line">[root@master ~]# kubectl get nodes</span><br><span class="line">NAME     STATUS   ROLES    AGE    VERSION</span><br><span class="line">master   Ready    master   128m   v1.17.4</span><br><span class="line">node1    Ready    &lt;none&gt;   119m   v1.17.4</span><br><span class="line">node2    Ready    &lt;none&gt;   119m   v1.17.4</span><br></pre></td></tr></table></figure>

<p>至此kubernetes的集群环境搭建完成</p>
<h2 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h2><p>接下来在kubernetes集群中部署一个Nginx程序，测试下集群是否在正常工作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">部署nginx</span></span><br><span class="line">[root@master ~]# kubectl create deployment nginx --image=nginx:1.14-alpine</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">暴露端口</span></span><br><span class="line">[root@master ~]# kubectl expose deployment nginx --port=80 --type=NodePort</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看服务状态</span></span><br><span class="line">[root@master ~]# kubectl get pods,svc</span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx-6867cdf567-x5wjz   1/1     Running   0          57s</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP        175m</span><br><span class="line">service/nginx        NodePort    10.107.119.189   &lt;none&gt;        80:32160/TCP   19s</span><br></pre></td></tr></table></figure>

<p>此时访问192.168.59.100:32160就可以访问Nginx了</p>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><p>本章节主要介绍YAML语法和kubernetes的资源管理方式</p>
<h2 id="资源管理介绍"><a href="#资源管理介绍" class="headerlink" title="资源管理介绍"></a>资源管理介绍</h2><p>在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes</p>
<blockquote>
<p>kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。</p>
<p>kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在<code>pod</code>中，而kubernetes一般也不会直接管理pod，而是通过<code>pod管理器</code>来管理pod的。</p>
<p>pod可以提供服务之后，就要考虑如何访问pod中服务，kubernetes提供了service资源实现这个功能。</p>
<p>当然，如果pod中程序的数据需要持久化，kubernetes还提供各种存储</p>
</blockquote>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-13_20-14-41.jpg"></p>
<blockquote>
<p>学习kubernetes的核心，就是学习如何对集群上的Pod、Pod控制器、Service、存储等各种资源进行操作</p>
</blockquote>
<h2 id="YAML语言介绍"><a href="#YAML语言介绍" class="headerlink" title="YAML语言介绍"></a>YAML语言介绍</h2><p>YAML是一个类似XML、JSON的标记性语言。它强调以数据为中心，并不是以标识语言为重点。因而YAML本身的定义比较简单，号称“一种人性化的数据格式语言”。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">age</span>&gt;</span>15<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span>Chengdu<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">Chengdu</span></span><br></pre></td></tr></table></figure>



<p>YAML的语言比较简单，主要由下面几个：</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格（低版本限制）</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>‘#’表示注释</li>
</ul>
<p>YAML支持以下几种数据类型：</p>
<ul>
<li>纯量：单个的、不可再分的值</li>
<li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hash） / 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence）/ 列表（list）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 纯量，就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期</span></span><br><span class="line"><span class="comment"># 1 布尔类型</span></span><br><span class="line"><span class="attr">c1:</span> <span class="literal">true</span> <span class="string">(或者True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 整型</span></span><br><span class="line"><span class="attr">c2:</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 浮点型</span></span><br><span class="line"><span class="attr">c3:</span> <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 null类型</span></span><br><span class="line"><span class="attr">c4:</span> <span class="string">~</span>  <span class="comment"># 使用~表示null</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 日期类型</span></span><br><span class="line"><span class="attr">c5:</span> <span class="number">2022-01-01</span>  <span class="comment"># 日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 时间类型</span></span><br><span class="line"><span class="attr">c6:</span> <span class="number">2022-01-01T00:00:00+08:00</span>  <span class="comment"># 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7 字符串类型</span></span><br><span class="line"><span class="attr">c7:</span> <span class="string">codeChen</span>  <span class="comment"># 简单写法，直接写，如果字符串中间有特殊字符，必须使用双引号或者单引号包裹</span></span><br><span class="line"><span class="attr">c8:</span> <span class="string">line1</span></span><br><span class="line">	<span class="string">line2</span>  <span class="comment"># 如果字符串过多的情况可以拆成多行，每一行会转化成一个空格</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="comment"># 形式一（推荐）</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">Chengdu</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 形式二（了解）</span></span><br><span class="line"><span class="attr">person:</span> &#123;<span class="attr">age:</span> <span class="number">15</span>, <span class="attr">address:</span> <span class="string">Chengdu</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="comment"># 形式一（推荐）：</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">成都</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">长沙</span></span><br><span class="line"><span class="comment"># 形式二（了解）</span></span><br><span class="line"><span class="attr">address:</span> [<span class="string">顺义，昌平</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>1 书写YAML切记: 后面要加一个空格</p>
<p>2 如果需要将多段YAML配置放在一个文件中，中间要使用—分割</p>
</blockquote>
<h2 id="资源管理方式"><a href="#资源管理方式" class="headerlink" title="资源管理方式"></a>资源管理方式</h2><ul>
<li>命令式对象管理：直接使用命令去操作kubernetes资源</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl run nginx-pod --image=nginx:1.17.1 --port=80</span><br></pre></td></tr></table></figure>

<ul>
<li>命令式对象配置：通过命令配置和配置文件去操作kubernetes资源</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create/patch -f nginx-pod.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>声明式对象配置：通过apply命令和配置文件去操作kubernetes资源</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-pod.yaml</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>类型</th>
<th>操作对象</th>
<th>适用环境</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>命令式对象管理</td>
<td>对象</td>
<td>测试</td>
<td>简单</td>
<td>只能操作活动对象，无法审计、跟踪</td>
</tr>
<tr>
<td>命令式对象配置</td>
<td>文件</td>
<td>开发</td>
<td>可以审计、跟踪</td>
<td>项目大时，配置文件多，操作麻烦</td>
</tr>
<tr>
<td>声明式对象配置</td>
<td>目录</td>
<td>开发</td>
<td>支持目录操作</td>
<td>意外情况下难以调试</td>
</tr>
</tbody></table>
<h3 id="命令式对象管理"><a href="#命令式对象管理" class="headerlink" title="命令式对象管理"></a>命令式对象管理</h3><p><strong>kubectl命令</strong></p>
<p>kubectl是kubernetes集群的命令行工具，通过宦能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。kubectl命令的语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl [command] [type] [name] [flags]</span><br></pre></td></tr></table></figure>

<p>command：指定要对资源执行的操作，例如create、get、delete</p>
<p>type：指定资源类型，比如deployment、pod、service</p>
<p>name：指定资源的名称，名称大小写敏感</p>
<p>flags：指定额外的可选参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有pod</span></span><br><span class="line">kubectl get pod</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个pod</span></span><br><span class="line">kubectl get pod pod_name </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个pod，以yaml格式展示结果</span></span><br><span class="line">kubectl get pod pod_name -o yaml</span><br></pre></td></tr></table></figure>



<p><strong>资源类型</strong></p>
<p>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl api-resources</span><br></pre></td></tr></table></figure>

<p>经常使用的资源有：</p>
<table>
<thead>
<tr>
<th>资源分类</th>
<th>资源名称</th>
<th>缩写</th>
<th>资源作用</th>
</tr>
</thead>
<tbody><tr>
<td>集群级别资源</td>
<td>nodes</td>
<td>no</td>
<td>集群组成部分</td>
</tr>
<tr>
<td></td>
<td>namespaces</td>
<td>ns</td>
<td>隔离Pod</td>
</tr>
<tr>
<td>pod资源</td>
<td>pods</td>
<td>po</td>
<td>装载容器</td>
</tr>
<tr>
<td>pod资源控制器</td>
<td>replicationcontrollers</td>
<td>rc</td>
<td>控制pod资源</td>
</tr>
<tr>
<td></td>
<td>replicasets</td>
<td>rs</td>
<td>控制pod资源</td>
</tr>
<tr>
<td></td>
<td>deployments</td>
<td>deploy</td>
<td>控制pod资源</td>
</tr>
<tr>
<td></td>
<td>daemonsets</td>
<td>ds</td>
<td>控制pod资源</td>
</tr>
<tr>
<td></td>
<td>jobs</td>
<td></td>
<td>控制pod资源</td>
</tr>
<tr>
<td></td>
<td>cronjobs</td>
<td>cj</td>
<td>控制pod资源</td>
</tr>
<tr>
<td></td>
<td>horizontalpodautoscalers</td>
<td>hpa</td>
<td>控制pod资源</td>
</tr>
<tr>
<td></td>
<td>statefulsets</td>
<td>sts</td>
<td>控制pod资源</td>
</tr>
<tr>
<td>服务发现资源</td>
<td>services</td>
<td>svc</td>
<td>统一pod对外接口</td>
</tr>
<tr>
<td></td>
<td>ingress</td>
<td>ing</td>
<td>统一pod对外接口</td>
</tr>
<tr>
<td>存储资源</td>
<td>volumeattachments</td>
<td></td>
<td>存储</td>
</tr>
<tr>
<td></td>
<td>persistentvolumes</td>
<td>pv</td>
<td>存储</td>
</tr>
<tr>
<td></td>
<td>persistentvolumeclaims</td>
<td>pvc</td>
<td>存储</td>
</tr>
<tr>
<td>配置资源</td>
<td>configmaps</td>
<td>cm</td>
<td>配置</td>
</tr>
<tr>
<td></td>
<td>secrets</td>
<td></td>
<td>配置</td>
</tr>
</tbody></table>
<p><strong>操作</strong></p>
<p>kubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl --help</span><br></pre></td></tr></table></figure>

<p>经常使用的操作有下面这些：</p>
<table>
<thead>
<tr>
<th>命令分类</th>
<th>命令</th>
<th>翻译</th>
<th>命令作用</th>
</tr>
</thead>
<tbody><tr>
<td>基本命令</td>
<td>create</td>
<td>创建</td>
<td>创建一个资源</td>
</tr>
<tr>
<td></td>
<td>edit</td>
<td>编辑</td>
<td>编辑一个资源</td>
</tr>
<tr>
<td></td>
<td>get</td>
<td>获取</td>
<td>获取一个资源</td>
</tr>
<tr>
<td></td>
<td>patch</td>
<td>更新</td>
<td>更新一个资源</td>
</tr>
<tr>
<td></td>
<td>delete</td>
<td>删除</td>
<td>删除一个资源</td>
</tr>
<tr>
<td></td>
<td>explain</td>
<td>解释</td>
<td>展示资源文档</td>
</tr>
<tr>
<td>运行和调试</td>
<td>run</td>
<td>运行</td>
<td>在集群中运行一个指定的镜像</td>
</tr>
<tr>
<td></td>
<td>expose</td>
<td>暴露</td>
<td>暴露资源为Service</td>
</tr>
<tr>
<td></td>
<td>describe</td>
<td>描述</td>
<td>显示资源内部信息</td>
</tr>
<tr>
<td></td>
<td>logs</td>
<td>日志输出容器在 pod 中的日志</td>
<td>输出容器在 pod 中的日志</td>
</tr>
<tr>
<td></td>
<td>attach</td>
<td>缠绕进入运行中的容器</td>
<td>进入运行中的容器</td>
</tr>
<tr>
<td></td>
<td>exec</td>
<td>执行容器中的一个命令</td>
<td>执行容器中的一个命令</td>
</tr>
<tr>
<td></td>
<td>cp</td>
<td>复制</td>
<td>在Pod内外复制文件</td>
</tr>
<tr>
<td></td>
<td>rollout</td>
<td>首次展示</td>
<td>管理资源的发布</td>
</tr>
<tr>
<td></td>
<td>scale</td>
<td>规模</td>
<td>扩(缩)容Pod的数量</td>
</tr>
<tr>
<td></td>
<td>autoscale</td>
<td>自动调整</td>
<td>自动调整Pod的数量</td>
</tr>
<tr>
<td>高级命令</td>
<td>apply</td>
<td>rc</td>
<td>通过文件对资源进行配置</td>
</tr>
<tr>
<td></td>
<td>label</td>
<td>标签</td>
<td>更新资源上的标签</td>
</tr>
<tr>
<td>其他命令</td>
<td>cluster-info</td>
<td>集群信息</td>
<td>显示集群信息</td>
</tr>
<tr>
<td></td>
<td>version</td>
<td>版本</td>
<td>显示当前Server和Client的版本</td>
</tr>
</tbody></table>
<p>下面以一个namespace的创建和删除简单演示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个namespace</span></span><br><span class="line">[root@master ~]# kubectl create namespace dev</span><br><span class="line">namespace/dev created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取namespace</span></span><br><span class="line">[root@master ~]# kubectl get ns</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   4h43m</span><br><span class="line">dev               Active   20s</span><br><span class="line">kube-node-lease   Active   4h43m</span><br><span class="line">kube-public       Active   4h43m</span><br><span class="line">kube-system       Active   4h43m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在此namespace下创建并运行一个Nginx的Pod</span></span><br><span class="line">[root@master ~]# kubectl run pod --image=nginx -n dev</span><br><span class="line">kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/pod created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看新创建的pod</span></span><br><span class="line">[root@master ~]# kubectl get pod -n dev</span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-864f9875b9-gglz8   1/1     Running   0          49s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的pod</span></span><br><span class="line">[root@master ~]# kubectl delete pod pod-864f9875b9-gglz8 -n dev</span><br><span class="line">pod &quot;pod-864f9875b9-gglz8&quot; deleted</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除namespace，里面的东西全部都会删除</span></span><br><span class="line">[root@master ~]# kubectl delete ns dev</span><br><span class="line">namespace &quot;dev&quot; deleted</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">[root@master ~]# kubectl version</span><br><span class="line">Client Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;17&quot;, GitVersion:&quot;v1.17.4&quot;, GitCommit:&quot;8d8aa39598534325ad77120c120a22b3a990b5ea&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2020-03-12T21:03:42Z&quot;, GoVersion:&quot;go1.13.8&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br><span class="line">Server Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;17&quot;, GitVersion:&quot;v1.17.4&quot;, GitCommit:&quot;8d8aa39598534325ad77120c120a22b3a990b5ea&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2020-03-12T20:55:23Z&quot;, GoVersion:&quot;go1.13.8&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群信息</span></span><br><span class="line">[root@master ~]# kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https://192.168.59.100:6443</span><br><span class="line">KubeDNS is running at https://192.168.59.100:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use &#x27;kubectl cluster-info dump&#x27;.</span><br></pre></td></tr></table></figure>



<h3 id="命令式对象配置"><a href="#命令式对象配置" class="headerlink" title="命令式对象配置"></a>命令式对象配置</h3><p>命令式对象配置就是使用命令配合配置文件一起来操作kubernetes资源。</p>
<p>1）创建一个nginxpod.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name :</span> <span class="string">dev</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind :</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginxpod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-containers</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<p>2）执行create命令，创建资源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl create -f nginxpod.yaml</span><br><span class="line">namespace/dev created</span><br><span class="line">pod/nginxpod created</span><br></pre></td></tr></table></figure>

<p>此时发现创建了两个资源对象，分别是namespace和pod</p>
<p>3）执行get命令，查看资源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get -f nginxpod.yaml</span><br><span class="line">NAME            STATUS   AGE</span><br><span class="line">namespace/dev   Active   2m3s</span><br><span class="line"></span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginxpod   1/1     Running   0          2m2s</span><br></pre></td></tr></table></figure>



<p>4）执行delete命令，删除资源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl delete -f nginxpod.yaml</span><br><span class="line">namespace &quot;dev&quot; deleted</span><br><span class="line">pod &quot;nginxpod&quot; deleted</span><br></pre></td></tr></table></figure>

<p>此时发现两个资源对象呗删除了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">	命令式对象配置的方式操作资源，可以简单的认为：命令 + yaml配置文件（里面是命令需要的各种参数）</span><br></pre></td></tr></table></figure>



<h3 id="声明式对象配置"><a href="#声明式对象配置" class="headerlink" title="声明式对象配置"></a>声明式对象配置</h3><p>声明式对象配置跟命令式对象配置很相似，但是它只有一个命令apply。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">首先执行一次kubectl apply -f yaml文件,发现创建了资源</span></span><br><span class="line">[root@master ~]# kubectl apply -f nginxpod.yaml</span><br><span class="line">namespace/dev created</span><br><span class="line">pod/nginxpod created</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get ns dev</span><br><span class="line">NAME   STATUS   AGE</span><br><span class="line">dev    Active   31s</span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME       READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginxpod   1/1     Running   0          41s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次执行一次，发现说资源没有变动</span></span><br><span class="line">[root@master ~]# kubectl apply -f nginxpod.yaml</span><br><span class="line">namespace/dev unchanged</span><br><span class="line">pod/nginxpod unchanged</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总结：</span><br><span class="line">	其实声明式对象配置就是使用apply描述一个资源最终的状态（在yaml中定义状态)</span><br><span class="line">	使用apply操作资源:</span><br><span class="line">		如果资源不存在，就创建，相当于kubectl create</span><br><span class="line">		如果资源已存在，就更新，相当于kubectl patch</span><br></pre></td></tr></table></figure>



<blockquote>
<p>扩展：kubectl可以在node节点上运行吗？</p>
</blockquote>
<p>kubectl的运行是需要进行配置的，它的配置文件是$HOME/.kube，如果想要在node节点运行此命令，需要将master上的.kube文件复制到node节点上，即在master节点上执行下面操作:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r HOME/.kube node1: HOME/</span><br></pre></td></tr></table></figure>



<blockquote>
<p>使用推荐：三种方式如何选择？</p>
</blockquote>
<p>创建/更新资源          使用声明式对象配置kubectl apply -f XXX.yaml</p>
<p>删除资源                   使用命令式对象配置kubectl delete -f XXX.yaml</p>
<p>查询资源                   使用命令式对象管理kubectl get(describe)资源名称</p>
<h1 id="实战入门"><a href="#实战入门" class="headerlink" title="实战入门"></a>实战入门</h1><p>本章节将介绍如何在kubernetes集群中部署一个Nginx服务，并且能够对其进行访问。</p>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现<strong>多套环境的资源隔离</strong>或者<strong>多租户的资源隔离</strong>。</p>
<p>默认情况下，kubernetes集群中的所有的Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行互相的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的”组”，以方便不同的组的资源进行隔离使用和管理。</p>
<p>可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-14_14-33-22.jpg"></p>
<p>kubernetes在集群启动之后，会默认创建几个namespace</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get namespace</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   21h  # 所有未指定Namespace的对象都会被分配在default命名空间</span><br><span class="line">kube-node-lease   Active   21h  # 集群节点之间的心跳维护，v1.13开始引入</span><br><span class="line">kube-public       Active   21h  # 此命名空间下的资源可以被所有人访问（包括未认证用户）</span><br><span class="line">kube-system       Active   21h  # 所有由kubernetes系统创建的资源都处于这个命名空间</span><br></pre></td></tr></table></figure>

<p>下面来看namespace资源的具体操作：</p>
<p><strong>查看</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1 查看所有ns</span></span><br><span class="line">[root@master ~]# kubectl get ns</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   21h</span><br><span class="line">kube-node-lease   Active   21h</span><br><span class="line">kube-public       Active   21h</span><br><span class="line">kube-system       Active   21h</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 查看指定的ns</span></span><br><span class="line">[root@master ~]# kubectl get ns default</span><br><span class="line">NAME      STATUS   AGE</span><br><span class="line">default   Active   21h</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3 指定输出格式 命令：kubectl get ns ns名称 -o 格式参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubernetes支持的格式有很多，比较常见的是wide、json、yaml</span></span><br><span class="line">[root@master ~]# kubectl get ns default -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2022-04-13T09:01:38Z&quot;</span><br><span class="line">  name: default</span><br><span class="line">  resourceVersion: &quot;145&quot;</span><br><span class="line">  selfLink: /api/v1/namespaces/default</span><br><span class="line">  uid: 9c0022a8-ef64-4459-bcb2-2d0aba7c5655</span><br><span class="line">spec:</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line">status:</span><br><span class="line">  phase: Active</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 查看ns详情</span></span><br><span class="line">[root@master ~]# kubectl describe ns default</span><br><span class="line">Name:         default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Active  # Active 命名空间正在使用 Terminating正在删除命名空间</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ResourceQuota 针对namespace做的资源限制</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> LimitRange针对namespace中的每个组件做的资源限制</span></span><br><span class="line">No resource quota.</span><br><span class="line">No LimitRange resource.</span><br></pre></td></tr></table></figure>



<p><strong>创建</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建namespace</span></span><br><span class="line">[root@master ~]# kubectl create ns dev</span><br><span class="line">namspace/dev created</span><br></pre></td></tr></table></figure>



<p><strong>删除</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除namespace</span></span><br><span class="line">[root@master ~]# kubectl delete ns dev</span><br><span class="line">namespace &quot;dev&quot; deleted</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>配置方式</strong></p>
<p>首先准备一个yaml文件：ns-dev.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>​    创建: kubectl create -f ns-dev.yaml</p>
<p>​    删除: kubectl delete -f ns-dev.yaml</p>
<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>经过前面的学习已经知道，程序要运行，必须部署在容器中，而容器必须存在于Pod中。</p>
<p>Pod是kubernetes集群进行管理的最小单元，也是kubernetes中最为重要和基本的概念。</p>
<p>Pod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-14_14-54-11.jpg"></p>
<p>kubernetes在集群启动之后，集群中的各个组件也都是以Pod方式运行的。可以通过以下命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get pod -n kube-system</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-6955765f44-77cj2         1/1     Running   1          21h</span><br><span class="line">coredns-6955765f44-bzwfm         1/1     Running   1          21h</span><br><span class="line">etcd-master                      1/1     Running   2          21h</span><br><span class="line">kube-apiserver-master            1/1     Running   2          21h</span><br><span class="line">kube-controller-manager-master   1/1     Running   3          21h</span><br><span class="line">kube-flannel-ds-dmshk            1/1     Running   1          19h</span><br><span class="line">kube-flannel-ds-dv5p6            1/1     Running   1          19h</span><br><span class="line">kube-flannel-ds-sf9tt            1/1     Running   1          19h</span><br><span class="line">kube-proxy-6lqmk                 1/1     Running   2          21h</span><br><span class="line">kube-proxy-z7z5c                 1/1     Running   2          21h</span><br><span class="line">kube-proxy-zq6zk                 1/1     Running   2          21h</span><br><span class="line">kube-scheduler-master            1/1     Running   3          21h</span><br></pre></td></tr></table></figure>



<p><strong>创建并运行</strong></p>
<p>kubernetes没有提供单独运行Pod的命令，都是通过Pod控制器来实现的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令格式:kubectl run (pod控制器名称)[参数]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --image 指定Pod的镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> —-port 指定端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --namespace 指定namespace</span></span><br><span class="line">[root@master ~]# kubectl run nginx --image=nginx:1.17.1 --port=80 --namespace dev</span><br><span class="line">kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/nginx created</span><br></pre></td></tr></table></figure>



<p><strong>查看pod信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看pod基本信息</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-64777cd554-wl475   1/1     Running   0          79s</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE     IP            NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-64777cd554-wl475   1/1     Running   0          5m59s   10.244.2.10   node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod的详细信息</span></span><br><span class="line">[root@master ~]# kubectl describe pod nginx-64777cd554-wl475 -n dev</span><br><span class="line">Name:         nginx-64777cd554-wl475</span><br><span class="line">Namespace:    dev</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         node2/192.168.59.102</span><br><span class="line">Start Time:   Thu, 14 Apr 2022 15:00:41 +0800</span><br><span class="line">Labels:       pod-template-hash=64777cd554</span><br><span class="line">              run=nginx</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           10.244.2.10</span><br><span class="line">IPs:</span><br><span class="line">  IP:           10.244.2.10</span><br><span class="line">Controlled By:  ReplicaSet/nginx-64777cd554</span><br><span class="line">Containers:</span><br><span class="line">  nginx:</span><br><span class="line">    Container ID:   docker://31c07492577ad1c02e1301e8cda04163310f1a9280ee7bb20034f4fd91a9b195</span><br><span class="line">    Image:          nginx:1.17.1</span><br><span class="line">    Image ID:       docker-pullable://nginx@sha256:b4b9b3eee194703fc2fa8afa5b7510c77ae70cfba567af1376a573a967c03dbb</span><br><span class="line">    Port:           80/TCP</span><br><span class="line">    Host Port:      0/TCP</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Thu, 14 Apr 2022 15:00:42 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-hs4rl (ro)</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True </span><br><span class="line">  Ready             True </span><br><span class="line">  ContainersReady   True </span><br><span class="line">  PodScheduled      True </span><br><span class="line">Volumes:</span><br><span class="line">  default-token-hs4rl:</span><br><span class="line">    Type:        Secret (a volume populated by a Secret)</span><br><span class="line">    SecretName:  default-token-hs4rl</span><br><span class="line">    Optional:    false</span><br><span class="line">QoS Class:       BestEffort</span><br><span class="line">Node-Selectors:  &lt;none&gt;</span><br><span class="line">Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s</span><br><span class="line">                 node.kubernetes.io/unreachable:NoExecute for 300s</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  3m6s  default-scheduler  Successfully assigned dev/nginx-64777cd554-wl475 to node2</span><br><span class="line">  Normal  Pulled     3m5s  kubelet, node2     Container image &quot;nginx:1.17.1&quot; already present on machine</span><br><span class="line">  Normal  Created    3m5s  kubelet, node2     Created container nginx</span><br><span class="line">  Normal  Started    3m5s  kubelet, node2     Started container nginx</span><br></pre></td></tr></table></figure>



<p><strong>访问Pod</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 访问podIP</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-64777cd554-wl475   1/1     Running   0          10m   10.244.2.10   node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问POD</span></span><br><span class="line">[root@master ~]# curl http://10.244.2.10:80</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<p><strong>删除指定Pod</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-64777cd554-wl475   1/1     Running   0          14m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定Pod</span></span><br><span class="line">[root@master ~]# kubectl delete pod nginx-64777cd554-wl475 -n dev</span><br><span class="line">pod &quot;nginx-64777cd554-wl475&quot; deleted</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时，显示删除pod成功，但是再查询，发现又新产生了一个</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME                     READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-64777cd554-8gq9h   0/1     ContainerCreating   0          4s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是因为当前pod是由pod控制器创建的，控制器会监控pod状况，一旦发现pod死亡，会立即重建</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时要想删除pod，必须删除pod控制器</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 先来查询一下当前namespace下的pod控制器</span></span><br><span class="line">[root@master ~]# kubectl get deploy -n dev</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   1/1     1            1           41m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来，删除此pod控制器</span></span><br><span class="line">[root@master ~]# kubectl delete deploy nginx -n dev</span><br><span class="line">deployment.apps &quot;nginx&quot; deleted</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 稍等片刻，再查询pod，发现pod被删除了</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">No resources found in dev namespace.</span><br></pre></td></tr></table></figure>

<p><strong>配置操作</strong></p>
<p>创建一个pod-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion :</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind :</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace :</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec :</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行相应的创建和删除命令了：</p>
<p>​    创建：kubectl create -f pod-nginx.yaml</p>
<p>​    删除：kubectl delete -f pod-nginx.yaml</p>
<h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>Label是kubernetes系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。</p>
<p>Label的特点:</p>
<ul>
<li><p>一个Label会以key/value键值对的形式附加到各种对象上，如Node、Pod、Service等等</p>
</li>
<li><p>一个资源对象可以定义任意数星的Label，同一个Label也可以被添加到任意数量的资源对象上去</p>
</li>
<li><p>Label通常在资源对象定义时确定，当然也可以在对象创建后动态添加或者删除</p>
</li>
</ul>
<p>可以通过Label实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。</p>
<blockquote>
<p>—些常用的Label示例如下:</p>
<ul>
<li><p>版本标签：”version”:”release”, “version”:”stable”…</p>
</li>
<li><p>环境标签：”environment”:”dev”, “environment”:”test”,”environment”:”pro”</p>
</li>
<li><p>架构标签：”tier”:”frontend”, “tier”:”backend”</p>
</li>
</ul>
</blockquote>
<p>标签定义完毕之后，还要考虑到标签的选择，这就要使用到Label Selector，即：</p>
<p>Label用于给某个资源对象定义标识</p>
<p>Label Selector用于查询和筛选拥有某些标签的资源对象</p>
<p>当前有两种Label Selector：</p>
<ul>
<li><p>基于等式的Label Selector</p>
<p>name = slave：选择所有包含Label中key=”name”且value=”slave”的对象</p>
<p>env != production：选择所有包括Label中的key=”env”且value不等于”production”的对象</p>
</li>
<li><p>基于集合的Label Selector</p>
<p>name in (master, slave)：选择所有包含Label中的key=”name”且value=”master”或”slave”的对象</p>
<p>name not in (frontend)：选择所有包含Label中的key=”name”且value不等于”frontend”的对象</p>
</li>
</ul>
<p>标签的选择条件可以使用多个，此时将多个Label Selector进行组合，使用逗号”,”进行分隔即可。例如:</p>
<p>​    name=slave, env!=production</p>
<p>​    name not in (frontend), env!=production</p>
<p><strong>命令方式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 为pod资源打标签</span></span><br><span class="line">[root@master ~]# kubectl label pod nginx version=1.0 -n dev</span><br><span class="line">pod/nginx labeled</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为pod资源更新标签</span></span><br><span class="line">[root@master ~]# kubectl label pod nginx version=2.0 -n dev --overwrite</span><br><span class="line">pod/nginx labeled</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看标签</span></span><br><span class="line">[root@master ~]# kubectl get pod nginx -n dev --show-labels</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE    LABELS</span><br><span class="line">nginx   1/1     Running   0          5m3s   version=2.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 筛选标签</span></span><br><span class="line">[root@master ~]# kubectl get pod -n dev -l version=2.0 --show-labels</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE     LABELS</span><br><span class="line">nginx   1/1     Running   0          5m55s   version=2.0</span><br><span class="line">[root@master ~]# kubectl get pod -n dev -l version!=2.0 --show-labels</span><br><span class="line">No resources found in dev namespace.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除标签</span></span><br><span class="line">[root@master ~]# kubectl label pod nginx version- -n dev</span><br><span class="line">pod/nginx labeled</span><br></pre></td></tr></table></figure>



<p><strong>配置方式</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind :</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name :</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace :</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">	<span class="attr">version:</span> <span class="string">&quot;3.0&quot;</span></span><br><span class="line">	<span class="attr">env :</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后执行对应的更新命令：kubectl apply -f pod-nginx.yaml</p>
<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会尝试进行重启或重建pod。</p>
<p>在kubernetes中Pod控制器的种类有很多，本章节只介绍一种:Deployment。</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-14_16-17-10.jpg"></p>
<p><strong>命令操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令格式: kubectl run deployment名称 [参数]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --image 指定pod的镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --port 指定端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --replicas 指定创建pod数量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --namespace 指定namespace</span></span><br><span class="line">[root@master ~]# kubectl run nginx --image=nginx:1.17.1 --port=80 --replicas=3 -n dev</span><br><span class="line">kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/nginx created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看创建的pod</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx                    1/1     Running   0          15m</span><br><span class="line">nginx-64777cd554-5mljk   1/1     Running   0          38s</span><br><span class="line">nginx-64777cd554-fmv9w   1/1     Running   0          38s</span><br><span class="line">nginx-64777cd554-p7cxh   1/1     Running   0          38s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看deployment的信息</span></span><br><span class="line">[root@master ~]# kubectl get deploy -n dev</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   3/3     3            3           93s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> UP-TO-DATE：成功升级的副本数量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ANAILABLE：可用副本的数量</span></span><br><span class="line">[root@master ~]# kubectl get deploy -n dev -o wide</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES         SELECTOR</span><br><span class="line">nginx   3/3     3            3           8m43s   nginx        nginx:1.17.1   run=nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看deployment的详细信息</span></span><br><span class="line">[root@master ~]# kubectl describe deploy nginx -n dev</span><br><span class="line">Name:                   nginx</span><br><span class="line">Namespace:              dev</span><br><span class="line">CreationTimestamp:      Thu, 14 Apr 2022 16:20:20 +0800</span><br><span class="line">Labels:                 run=nginx</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision: 1</span><br><span class="line">Selector:               run=nginx</span><br><span class="line">Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  run=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:        nginx:1.17.1</span><br><span class="line">    Port:         80/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">  Progressing    True    NewReplicaSetAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   nginx-64777cd554 (3/3 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age    From                   Message</span><br><span class="line">  ----    ------             ----   ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  9m31s  deployment-controller  Scaled up replica set nginx-64777cd554 to 3</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除</span></span><br><span class="line">[root@master ~]# kubectl delete deploy nginx -n dev</span><br><span class="line">deployment.apps &quot;nginx&quot; deleted</span><br></pre></td></tr></table></figure>



<p><strong>配置操作</strong></p>
<p>创建一个deploy-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>执行命令：kubectl  create -f deploy-nginx.yaml </p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>通过上节课的学习，已经能够利用Deployment来创建一组Pod来提供具有高可用性的服务。</p>
<p>虽然每个Pod都会分配一个单独的Pod lP，然而却存在如下两问题:</p>
<ul>
<li><p>Pod IP会随着Pod的重建产生变化</p>
</li>
<li><p>Pod IP仅仅是集群内可见的虚拟IP，外部无法访问</p>
</li>
</ul>
<p>这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。</p>
<p>Service可以看作是一组同类Pod<strong>对外的访问接口</strong>。借助Service，应用可以方便地实现服务发现和负载均衡。</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-14_16-45-06.jpg"></p>
<p><strong>操作一：创建集群内部可访问的Service</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 暴露Service</span></span><br><span class="line">[root@master ~]# kubectl expose deployment nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev</span><br><span class="line">service/svc-nginx1 exposed</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Service</span></span><br><span class="line">[root@master ~]# kubectl get service -n dev</span><br><span class="line">NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">svc-nginx1   ClusterIP   10.109.108.87   &lt;none&gt;        80/TCP    36s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里产生了一个CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过这个IP访问当前service对应的POD</span></span><br><span class="line">[root@master ~]# curl 10.105.233.217:80</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<p><strong>操作二：创建集群外部也可访问的Service</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 上面创建的Service的<span class="built_in">type</span>类型为ClusterIP，这个ip地址只有集群内部可访问</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果需要创建外部也可以访问的Service，需要修改<span class="built_in">type</span>为NodePort</span></span><br><span class="line">[root@master ~]# kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev</span><br><span class="line">service/svc-nginx2 exposed</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时查看，会发现出现NodePort类型的Service，而且有一对Port（80:31874/TCP）</span></span><br><span class="line">[root@master ~]# kubectl get svc -n dev -o wide</span><br><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE   SELECTOR</span><br><span class="line">svc-nginx1   ClusterIP   10.105.233.217   &lt;none&gt;        80/TCP         25m   run=nginx</span><br><span class="line">svc-nginx2   NodePort    10.106.143.53    &lt;none&gt;        80:31874/TCP   51s   run=nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来就可以通过集群外的主机访问 节点IP：31928访问服务了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如在电脑主机上通过浏览器访问、</span></span><br><span class="line">192.168.59.100:32160</span><br></pre></td></tr></table></figure>

<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-14_17-30-32.jpg"></p>
<p><strong>删除Service</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl delete svc svc-nginx1 -n dev </span><br><span class="line">service &quot;svc-nginx1&quot; deleted</span><br></pre></td></tr></table></figure>



<p><strong>配置方式</strong></p>
<p>创建一个svc-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">svc-nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec :</span></span><br><span class="line">  <span class="attr">ClusterIP:</span> <span class="number">10.109</span><span class="number">.179</span><span class="number">.231</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port :</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector :</span></span><br><span class="line">    <span class="attr">run :</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span>  <span class="comment"># 这里指定ClusterIP，上面ClusterIP可写可不写，写了就指定ip</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>​    创建：kubectl create -f svc-nginx.yaml</p>
<p>​    删除：kubectl delete -f svc-nginx.yaml</p>
<h1 id="Pod详解"><a href="#Pod详解" class="headerlink" title="Pod详解"></a>Pod详解</h1><h2 id="Pod介绍"><a href="#Pod介绍" class="headerlink" title="Pod介绍"></a>Pod介绍</h2><h3 id="Pod结构"><a href="#Pod结构" class="headerlink" title="Pod结构"></a>Pod结构</h3><p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\k8s-base\Snipaste_2022-04-14_14-54-11.jpg"></p>
<p>每个Pod中都可以包含一个或者多个容器，这些容易可以分为两类：</p>
<ul>
<li><p>用户程序所在程序，数量可多可少</p>
</li>
<li><p>Pause容器，这是每个Pod都会有的一个根容器，它的作用有两个：</p>
<ul>
<li><p>可以以它为依据，评估整个pod的健康状态</p>
</li>
<li><p>可以在根容器上设置ip地址，其它容器都共享此IP（Pod IP），以实现Pod内部的网络通信</p>
<p>这里是pod内部的通信，pod之间的通信采用虚拟二层网络技术来实现，我们当前环境用的是Flannel</p>
</li>
</ul>
</li>
</ul>
<h3 id="Pod定义"><a href="#Pod定义" class="headerlink" title="Pod定义"></a>Pod定义</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>     <span class="comment">#必选，版本号，例如v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>       　 <span class="comment">#必选，资源类型，例如 Pod</span></span><br><span class="line"><span class="attr">metadata:</span>       　 <span class="comment">#必选，元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span>     <span class="comment">#必选，Pod名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">string</span>  <span class="comment">#Pod所属的命名空间,默认为&quot;default&quot;</span></span><br><span class="line">  <span class="attr">labels:</span>       　　  <span class="comment">#自定义标签列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　          </span><br><span class="line"><span class="attr">spec:</span>  <span class="comment">#必选，Pod中容器的详细定义</span></span><br><span class="line">  <span class="attr">containers:</span>  <span class="comment">#必选，Pod中容器列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>   <span class="comment">#必选，容器名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">string</span>  <span class="comment">#必选，容器的镜像名称</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> [ <span class="string">Always|Never|IfNotPresent</span> ]  <span class="comment">#获取镜像的策略 </span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">string</span>]   <span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">    <span class="attr">args:</span> [<span class="string">string</span>]      <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line">    <span class="attr">workingDir:</span> <span class="string">string</span>  <span class="comment">#容器的工作目录</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>       <span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      <span class="comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">string</span> <span class="comment">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="string">boolean</span> <span class="comment">#是否为只读模式</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>        <span class="comment">#端口的名称</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="string">int</span>  <span class="comment">#容器需要监听的端口号</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="string">int</span>       <span class="comment">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">string</span>    <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line">    <span class="attr">env:</span>   <span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>  <span class="comment">#环境变量名称</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">string</span> <span class="comment">#环境变量的值</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="comment">#资源限制和请求的设置</span></span><br><span class="line">      <span class="attr">limits:</span>  <span class="comment">#资源限制的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>     <span class="comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>  <span class="comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class="line">      <span class="attr">requests:</span> <span class="comment">#资源请求的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>    <span class="comment">#Cpu请求，容器启动的初始可用数量</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span> <span class="comment">#内存请求,容器启动的初始可用数量</span></span><br><span class="line">    <span class="attr">lifecycle:</span> <span class="comment">#生命周期钩子</span></span><br><span class="line">        <span class="attr">postStart:</span> <span class="comment">#容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启</span></span><br><span class="line">        <span class="attr">preStop:</span> <span class="comment">#容器终止前执行此钩子,无论结果如何,容器都会终止</span></span><br><span class="line">    <span class="attr">livenessProbe:</span>  <span class="comment">#对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器</span></span><br><span class="line">      <span class="attr">exec:</span>       　 <span class="comment">#对Pod容器内检查方式设置为exec方式</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">string</span>]  <span class="comment">#exec方式需要制定的命令或脚本</span></span><br><span class="line">      <span class="attr">httpGet:</span>       <span class="comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">HttpHeaders:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">tcpSocket:</span>     <span class="comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class="line">         <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">       <span class="attr">initialDelaySeconds:</span> <span class="number">0</span>       <span class="comment">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class="line">       <span class="attr">timeoutSeconds:</span> <span class="number">0</span>    　　    <span class="comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class="line">       <span class="attr">periodSeconds:</span> <span class="number">0</span>     　　    <span class="comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class="line">       <span class="attr">successThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">failureThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">securityContext:</span></span><br><span class="line">         <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> [<span class="string">Always</span> <span class="string">|</span> <span class="string">Never</span> <span class="string">|</span> <span class="string">OnFailure</span>]  <span class="comment">#Pod的重启策略</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">&lt;string&gt;</span> <span class="comment">#设置NodeName表示将该Pod调度到指定到名称的node节点上</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> <span class="string">obeject</span> <span class="comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span> <span class="comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span>   <span class="comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class="line">  <span class="attr">volumes:</span>   <span class="comment">#在该pod上定义共享存储卷列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>    <span class="comment">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;       <span class="comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class="line">    <span class="attr">hostPath:</span> <span class="string">string</span>   <span class="comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">string</span>      　　        <span class="comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class="line">    <span class="attr">secret:</span>       　　　<span class="comment">#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部</span></span><br><span class="line">      <span class="attr">scretname:</span> <span class="string">string</span>  </span><br><span class="line">      <span class="attr">items:</span>     </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">    <span class="attr">configMap:</span>         <span class="comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">小提示：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   在这里，可通过一个命令来查看每种资源的可配置项</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   kubectl explain 资源类型         查看某种资源可以配置的一级属性</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   kubectl explain 资源类型.属性     查看属性的子属性</span></span><br><span class="line">[root@master ~]# kubectl explain pod</span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">     Pod is a collection of containers that can run on a host. This resource is</span><br><span class="line">     created by clients and scheduled onto hosts.</span><br><span class="line"></span><br><span class="line">FIELDS:</span><br><span class="line">   apiVersion	&lt;string&gt;</span><br><span class="line">     APIVersion defines the versioned schema of this representation of an</span><br><span class="line">     object. Servers should convert recognized schemas to the latest internal</span><br><span class="line">     value, and may reject unrecognized values. More info:</span><br><span class="line">     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</span><br><span class="line"></span><br><span class="line">   kind	&lt;string&gt;</span><br><span class="line">     Kind is a string value representing the REST resource this object</span><br><span class="line">     represents. Servers may infer this from the endpoint the client submits</span><br><span class="line">     requests to. Cannot be updated. In CamelCase. More info:</span><br><span class="line">     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</span><br><span class="line"></span><br><span class="line">   metadata	&lt;Object&gt;</span><br><span class="line">     Standard object&#x27;s metadata. More info:</span><br><span class="line">     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</span><br><span class="line"></span><br><span class="line">   spec	&lt;Object&gt;</span><br><span class="line">     Specification of the desired behavior of the pod. More info:</span><br><span class="line">     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</span><br><span class="line"></span><br><span class="line">   status	&lt;Object&gt;</span><br><span class="line">     Most recently observed status of the pod. This data may not be up to date.</span><br><span class="line">     Populated by the system. Read-only. More info:</span><br><span class="line">     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</span><br></pre></td></tr></table></figure>

<p>在kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：</p>
<ul>
<li>apiVersion 版本，由kubernetes内部定义，版本号必须可以用 kubectl api-versions 查询到</li>
<li>kind 类型，由kubernetes内部定义，版本号必须可以用 kubectl api-resources 查询到</li>
<li>metadata 元数据，主要是资源标识和说明，常用的有name、namespace、labels等</li>
<li>spec 描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述</li>
<li>status 状态信息，里面的内容不需要定义，由kubernetes自动生成</li>
</ul>
<p>在上面的属性中，spec是接下来研究的重点，继续看下它的常见子属性:</p>
<ul>
<li>containers &lt;[]Object&gt; 容器列表，用于定义容器的详细信息</li>
<li>nodeName 根据nodeName的值将pod调度到指定的Node节点上</li>
<li>nodeSelector &lt;map[]&gt; 根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node 上</li>
<li>hostNetwork 是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</li>
<li>volumes &lt;[]Object&gt; 存储卷，用于定义Pod上面挂在的存储信息</li>
<li>restartPolicy 重启策略，表示Pod在遇到故障的时候的处理策略</li>
</ul>
<h2 id="Pod配置"><a href="#Pod配置" class="headerlink" title="Pod配置"></a>Pod配置</h2><p>本小节主要研究pod.spec.containers属性，这也是pod配置中最为关键的一项配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl explain pod.spec.containers</span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: containers &lt;[]Object&gt;   # 数组，代表可以有多个容器</span><br><span class="line">FIELDS:</span><br><span class="line">   name  &lt;string&gt;     # 容器名称</span><br><span class="line">   image &lt;string&gt;     # 容器需要的镜像地址</span><br><span class="line">   imagePullPolicy  &lt;string&gt; # 镜像拉取策略 </span><br><span class="line">   command  &lt;[]string&gt; # 容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br><span class="line">   args     &lt;[]string&gt; # 容器的启动命令需要的参数列表</span><br><span class="line">   env      &lt;[]Object&gt; # 容器环境变量的配置</span><br><span class="line">   ports    &lt;[]Object&gt;     # 容器需要暴露的端口号列表</span><br><span class="line">   resources &lt;Object&gt;      # 资源限制和资源请求的设置</span><br></pre></td></tr></table></figure>



<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>创建pod-base.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-base</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">codeChen</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br></pre></td></tr></table></figure>

<p>上面定义了一个比较简单Pod的配置，里面有两个容器：</p>
<ul>
<li>nginx：用1.17.1版本的nginx镜像创建，（nginx是一个轻量级web容器）</li>
<li>busybox：用1.30版本的busybox镜像创建，（busybox是一个小巧的linux命令集合）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@master pod]# kubectl apply -f pod-base.yaml</span><br><span class="line">pod/pod-base created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod状况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> READY 1/2 : 表示当前Pod中有2个容器，其中1个准备就绪，1个未就绪</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> RESTARTS  : 重启次数，因为有1个容器故障了，Pod一直在重启试图恢复它</span></span><br><span class="line">[root@master pod]# kubectl get pod -n dev</span><br><span class="line">NAME       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-base   1/2     Running   4          95s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过describe查看内部的详情</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时已经运行起来了一个基本的Pod，虽然它暂时有问题</span></span><br><span class="line">[root@master01 pod]# kubectl describe pod pod-base -n dev</span><br></pre></td></tr></table></figure>



<h3 id="镜像拉取"><a href="#镜像拉取" class="headerlink" title="镜像拉取"></a>镜像拉取</h3><p>创建pod.imagepullpolicy.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-imagepullpolicy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Always</span> <span class="comment"># 用于设置镜像拉取策略</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br></pre></td></tr></table></figure>

<p>imagePullPolicy，用于设置镜像拉取策略，kubernetes支持配置三种拉取策略：</p>
<ul>
<li>Always：总是从远程仓库拉取镜像（一直远程下载）</li>
<li>IfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就本地 本地没就远程下载）</li>
<li>Never：只使用本地镜像，从不去远程仓库拉取，本地没有就报错 （一直使用本地）</li>
</ul>
<blockquote>
<p> 默认值说明：</p>
<p>​    如果镜像tag为具体版本号， 默认策略是：IfNotPresent</p>
<p>​    如果镜像tag为：latest（最终版本） ，默认策略是always</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建Pod</span><br><span class="line">[root@master pod]# kubectl create -f pod-imagepullpolicy.yaml</span><br><span class="line">pod/pod-imagepullpolicy created</span><br><span class="line"></span><br><span class="line"># 查看Pod详情</span><br><span class="line"># 此时明显可以看到nginx镜像有一步Pulling image &quot;nginx:1.17.1&quot;的过程</span><br><span class="line">[root@master01 pod]# kubectl describe pod pod-imagepullpolicy -n dev</span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason     Age               From               Message</span><br><span class="line">  ----     ------     ----              ----               -------</span><br><span class="line">  Normal   Scheduled  &lt;unknown&gt;         default-scheduler  Successfully assigned dev/pod-imagePullPolicy to node1</span><br><span class="line">  Normal   Pulling    32s               kubelet, node1     Pulling image &quot;nginx:1.17.1&quot;</span><br><span class="line">  Normal   Pulled     26s               kubelet, node1     Successfully pulled image &quot;nginx:1.17.1&quot;</span><br><span class="line">  Normal   Created    26s               kubelet, node1     Created container nginx</span><br><span class="line">  Normal   Started    25s               kubelet, node1     Started container nginx</span><br><span class="line">  Normal   Pulled     7s (x3 over 25s)  kubelet, node1     Container image &quot;busybox:1.30&quot; already present on machine</span><br><span class="line">  Normal   Created    7s (x3 over 25s)  kubelet, node1     Created container busybox</span><br><span class="line">  Normal   Started    7s (x3 over 25s)  kubelet, node1     Started container busybox</span><br></pre></td></tr></table></figure>

<h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><p>在前面的案例中，一直有一个问题没有解决，就是的busybox容器一直没有成功运行，那么到底是什么原因导致这个容器的故障呢？</p>
<p>原来busybox并不是一个程序，而是类似于一个工具类的集合，kubernetes集群启动管理后，它会自动关闭。解决方法就是让其一直在运行，这就用到了command配置。</p>
<p>创建pod-command.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-command</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done;&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>command，用于在pod中的容器初始化完毕之后运行一个命令。</p>
<blockquote>
<p>稍微解释下上面命令的意思：</p>
<p>“/bin/sh”,”-c”, 使用sh执行命令</p>
<p>touch /tmp/hello.txt; 创建一个/tmp/hello.txt 文件</p>
<p>while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done; 每隔3秒向文件中写入当前时间</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl create -f pod-command.yaml </span><br><span class="line">pod/pod-command created</span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME                  READY   STATUS             RESTARTS   AGE</span><br><span class="line">pod-base              1/2     CrashLoopBackOff   8          19m</span><br><span class="line">pod-command           2/2     Running            0          18s</span><br><span class="line">pod-imagepullpolicy   1/2     CrashLoopBackOff   6          6m10s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入pod中的busybox容器，查看文件内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 补充一个命令: kubectl <span class="built_in">exec</span>  pod名称 -n 命名空间 -it -c 容器名称 /bin/sh  在容器内部执行命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用这个命令就可以进入某个容器的内部，然后进行相关操作了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如，可以查看txt文件的内容</span></span><br><span class="line">[root@master ~]# kubectl exec pod-command -n dev -it -c busybox /bin/sh</span><br><span class="line">/ # tail -f /tmp/hello.txt</span><br><span class="line">14:10:55</span><br><span class="line">14:10:58</span><br><span class="line">14:11:01</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特别说明：</span><br><span class="line">    通过上面发现command已经可以完成启动命令和传递参数的功能，为什么这里还要提供一个args选项，用于传递参数呢?这其实跟docker有点关系，kubernetes中的command、args两项其实是实现覆盖Dockerfile中ENTRYPOINT的功能。</span><br><span class="line"> 1 如果command和args均没有写，那么用Dockerfile的配置。</span><br><span class="line"> 2 如果command写了，但args没有写，那么Dockerfile默认的配置会被忽略，执行输入的command</span><br><span class="line"> 3 如果command没写，但args写了，那么Dockerfile中配置的ENTRYPOINT的命令会被执行，使用当前args的参数</span><br><span class="line"> 4 如果command和args都写了，那么Dockerfile的配置被忽略，执行command并追加上args参数</span><br></pre></td></tr></table></figure>



<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>创建pod-env.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-env</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do /bin/echo $(date +%T);sleep 60; done;&quot;</span>]</span><br><span class="line">    <span class="attr">env:</span> <span class="comment"># 设置环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;username&quot;</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<p>env，环境变量，用于在pod中的容器设置环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@master ~]# kubectl create -f pod-env.yaml</span><br><span class="line">pod/pod-env created</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME                  READY   STATUS             RESTARTS   AGE</span><br><span class="line">pod-base              1/2     CrashLoopBackOff   10         28m</span><br><span class="line">pod-command           2/2     Running            0          9m41s</span><br><span class="line">pod-env               1/1     Running            0          12s</span><br><span class="line">pod-imagepullpolicy   1/2     CrashLoopBackOff   7          15m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器，输出环境变量</span></span><br><span class="line">[root@master ~]# kubectl exec pod-env -n dev -c busybox -it /bin/sh</span><br><span class="line">/ # echo $username</span><br><span class="line">admin</span><br><span class="line">/ # echo $password</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>这种方式不是很推荐，推荐将这些配置单独存储在配置文件中，这种方式将在后面介绍。</p>
<h3 id="端口设置"><a href="#端口设置" class="headerlink" title="端口设置"></a>端口设置</h3><p>本小节来介绍容器的端口设置，也就是containers的ports选项。</p>
<p>首先看下ports支持的子选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl explain pod.spec.containers.ports</span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: ports &lt;[]Object&gt;</span><br><span class="line">FIELDS:</span><br><span class="line">   name         &lt;string&gt;  # 端口名称，如果指定，必须保证name在pod中是唯一的		</span><br><span class="line">   containerPort&lt;integer&gt; # 容器要监听的端口(0&lt;x&lt;65536)</span><br><span class="line">   hostPort     &lt;integer&gt; # 容器要在主机上公开的端口，如果设置，主机上只能运行容器的一个副本(一般省略) </span><br><span class="line">   hostIP       &lt;string&gt;  # 要将外部端口绑定到的主机IP(一般省略)</span><br><span class="line">   protocol     &lt;string&gt;  # 端口协议。必须是UDP、TCP或SCTP。默认为“TCP”。</span><br></pre></td></tr></table></figure>

<p>接下来，编写一个测试案例，创建pod-ports.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-ports</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 设置容器暴露的端口列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@master ~]# kubectl create -f pod-ports.yaml</span><br><span class="line">pod/pod-ports created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在下面可以明显看到配置信息</span></span><br><span class="line">[root@master ~]# kubectl get pod pod-ports -n dev -o yaml</span><br><span class="line">......</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx:1.17.1</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">      name: nginx-port</span><br><span class="line">      protocol: TCP</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>访问容器中的程序需要使用的是<code>Podip:containerPort</code></p>
<h3 id="资源配额"><a href="#资源配额" class="headerlink" title="资源配额"></a>资源配额</h3><p>容器中的程序要运行，肯定是要占用一定资源的，比如cpu和内存等，如果不对某个容器的资源做限制，那么它就可能吃掉大量资源，导致其它容器无法运行。针对这种情况，kubernetes提供了对内存和cpu的资源进行配额的机制，这种机制主要通过resources选项实现，他有两个子选项：</p>
<ul>
<li>limits：用于限制运行时容器的最大占用资源，当容器占用资源超过limits时会被终止，并进行重启</li>
<li>requests ：用于设置容器需要的最小资源，如果环境资源不够，容器将无法启动</li>
</ul>
<p>可以通过上面两个选项设置资源的上下限。</p>
<p>接下来，编写一个测试案例，创建pod-resources.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-resources</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="comment"># 资源配额</span></span><br><span class="line">      <span class="attr">limits:</span>  <span class="comment"># 限制资源（上限）</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span> <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;10Gi&quot;</span> <span class="comment"># 内存限制</span></span><br><span class="line">      <span class="attr">requests:</span> <span class="comment"># 请求资源（下限）</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;10Mi&quot;</span>  <span class="comment"># 内存限制</span></span><br></pre></td></tr></table></figure>

<p>在这对cpu和memory的单位做一个说明：</p>
<ul>
<li>cpu：core数，可以为整数或小数</li>
<li>memory： 内存大小，可以使用Gi、Mi、G、M等形式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 运行Pod</span><br><span class="line">[root@master ~]# kubectl create  -f pod-resources.yaml</span><br><span class="line">pod/pod-resources created</span><br><span class="line"></span><br><span class="line"># 查看发现pod运行正常</span><br><span class="line">[root@master ~]# kubectl get pod pod-resources -n dev</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-resources   1/1     Running   0          14s</span><br><span class="line"></span><br><span class="line"># 接下来，停止Pod</span><br><span class="line">[root@master ~]# kubectl delete -f pod-resources.yaml</span><br><span class="line">pod &quot;pod-resources&quot; deleted</span><br><span class="line"></span><br><span class="line"># 编辑pod，修改resources.requests.memory的值为10Gi</span><br><span class="line">[root@master ~]# vim pod-resources.yaml</span><br><span class="line"></span><br><span class="line"># 再次启动pod</span><br><span class="line">[root@master ~]# kubectl create -f pod-resources.yaml</span><br><span class="line">pod/pod-resources created</span><br><span class="line"></span><br><span class="line"># 查看Pod状态，发现Pod启动失败</span><br><span class="line">[root@master ~]# kubectl get pod pod-resources -n dev -o wide</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE          </span><br><span class="line">pod-resources   0/1     Pending   0          20s    </span><br><span class="line"></span><br><span class="line"># 查看pod详情会发现，如下提示</span><br><span class="line">[root@master ~]# kubectl describe pod pod-resources -n dev</span><br><span class="line">......</span><br><span class="line">Warning  FailedScheduling  35s   default-scheduler  0/3 nodes are available: 1 node(s) had taint &#123;node-role.kubernetes.io/m</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>集群</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql中where、on、having使用场景</title>
    <url>/mysql-where-on-having/</url>
    <content><![CDATA[<h1 id="一、where和having"><a href="#一、where和having" class="headerlink" title="一、where和having"></a>一、where和having</h1><ul>
<li>”where“是在结果返回之前起作用，where后面不能使用”聚合函数“；</li>
<li>“having”是在结果返回之后起作用，having后面可以使用“聚合函数”；</li>
</ul>
<blockquote>
<p>常见的聚合函数如：sum()、max()、min()、avg()</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span>、<span class="keyword">where</span>和<span class="keyword">having</span>都可以用的场景</span><br><span class="line"><span class="keyword">select</span> name, score <span class="keyword">from</span> task <span class="keyword">where</span> score <span class="operator">&gt;</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">select</span> name, score <span class="keyword">from</span> task <span class="keyword">having</span> score <span class="operator">&gt;</span> <span class="number">60</span>;</span><br><span class="line"># <span class="keyword">having</span>是从选择的字段再筛选，而<span class="keyword">where</span>使用数据表中的字段直接筛选，<span class="keyword">select</span>中选择了score，所用使用<span class="keyword">where</span>和<span class="keyword">having</span>效果一样</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、只可以用<span class="keyword">having</span>，不可以用<span class="keyword">where</span>的场景</span><br><span class="line"><span class="keyword">select</span> name, <span class="built_in">avg</span>(score) <span class="keyword">as</span> avgScore <span class="keyword">from</span> task <span class="keyword">group</span> <span class="keyword">by</span> subject <span class="keyword">having</span> <span class="operator">&gt;</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">select</span> name, <span class="built_in">avg</span>(score) <span class="keyword">as</span> avgScore <span class="keyword">from</span> task <span class="keyword">group</span> <span class="keyword">by</span> subject <span class="keyword">where</span> <span class="operator">&gt;</span> <span class="number">60</span>; # 错误，表格中没有average这个字段</span><br><span class="line"># 这里只能使用<span class="keyword">having</span>，因为<span class="keyword">where</span>后面的字段必须是数据表格里存在的字段，换成<span class="built_in">avg</span>(score)也会报错</span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、只可以用<span class="keyword">where</span>，不可以用<span class="keyword">having</span>的场景</span><br><span class="line"><span class="keyword">select</span> name, age <span class="keyword">from</span> task <span class="keyword">where</span> score <span class="operator">&gt;</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">select</span> name, age <span class="keyword">from</span> task <span class="keyword">having</span> score <span class="operator">&gt;</span> <span class="number">60</span>; # 报错，<span class="keyword">select</span>中没有score字段</span><br></pre></td></tr></table></figure>



<h1 id="二、where和on"><a href="#二、where和on" class="headerlink" title="二、where和on"></a>二、where和on</h1><p>数据库在做连接查询的时候，会生成一张临时表。</p>
<ul>
<li>where在临时表生成后，再对临时表进行过滤</li>
<li>on是在生成临时表时使用条件，（例如：在left join时，无论on条件是否成立，都会返回左表记录）</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-base</title>
    <url>/mysql-base/</url>
    <content><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p><strong>修改</strong></p>
<p><img src="/./mysql-base/Snipaste_2022-03-12_20-00-08.jpg"></p>
<p><img src="/./mysql-base/Snipaste_2022-03-12_20-11-15.jpg"></p>
<p><strong>添加</strong></p>
<p>语句：insert into 表名([字段名1,字段2,字段3]) values(‘值1’,’值2’,’值3’,…..)</p>
<p><img src="/./mysql-base/Snipaste_2022-03-12_20-14-22.jpg"></p>
<p><strong>删除</strong></p>
<blockquote>
<p>delete</p>
</blockquote>
<p>语句：delete from 表名 where 条件</p>
<blockquote>
<p>TRUNCATE</p>
</blockquote>
<p>作用：完全清空一个数据库表，表的结构和索引约束不会变</p>
<p>两者区别：</p>
<ul>
<li>相同点：都能删除数据，都不会删除表结构</li>
<li>不同：<ul>
<li>TRUNCATE 重新设置 自增列 计数器会归零</li>
<li>TRUNCATE 不会影响事务</li>
</ul>
</li>
</ul>
<p><strong>update</strong></p>
<p>语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line"><span class="keyword">SET</span> column1<span class="operator">=</span>value1,column2<span class="operator">=</span>value2,...</span><br><span class="line"><span class="keyword">WHERE</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure>





<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h2><p><img src="./mysql-base/src=http___cdn.ancii.com_article_image_v1_sw_wV_kP_PkwwVsGDmjDG9swnOi7SkjVAsMQAarn73E9S3mmSmcArQPHF0A2Py4hyS-AQkJ9roAOtcHqTF_Ab9FQOk3gdIQ.png&refer=http___cdn.ancii.webp"></p>
<h1 id="SQL查询语句（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#SQL查询语句（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="SQL查询语句（where、jion、limit、group by、having等等）执行先后顺序"></a>SQL查询语句（where、jion、limit、group by、having等等）执行先后顺序</h1><p>一个查询语句同时出现了where,group by,having,order by的时候，执行顺序和编写顺序是：</p>
<ol>
<li><p>执行where对全表数据做筛选，返回第1个结果集。</p>
</li>
<li><p>针对第1个结果集使用group by分组，返回第2个结果集。</p>
</li>
<li><p>针对第2个结果集中的每1组数据执行select，有几组就执行几次，返回第3个结果集。</p>
</li>
<li><p>针对第3个结集执行having进行筛选，返回第4个结果集。</p>
</li>
<li><p>针对第4个结果集排序。</p>
</li>
</ol>
<p><strong>通过一个顺口溜总结下顺序：我(W)哥(G)是(SH)偶(O)像</strong>。按照执行顺序的关键词首字母分别是W（where）-&gt;G（Group）-&gt;S（Select）-&gt;H（Having）-&gt;O（Order），对应汉语首字母可以<strong>编成容易记忆的顺口溜：我(W)哥(G)是(SH)偶(O)像</strong></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis入门</title>
    <url>/mybatis-base/</url>
    <content><![CDATA[<h1>1、简介</h1>
<h2 id="1-1、什么是MyBatis">1.1、什么是MyBatis</h2>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210922213701664.png" alt="image-20210922213701664"></p>
<ul>
<li>MyBatis是一款优秀的<strong>持久层框架</strong></li>
<li>它支持定制化SQL、存储过程以及高级映射</li>
<li>MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集</li>
<li>MyBatis可以使用简单的XML或者注解来配置和映射原生类型、接口和Java的POJO（Plain Old Java Objects，普通老式Java对象）为数据库中的记录。</li>
<li>MyBatis 本是apache的一个<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/3406069">开源项目</a>iBatis, 2010年这个<a href="https://baike.baidu.com/item/%E9%A1%B9%E7%9B%AE/477803">项目</a>由apache software foundation 迁移到了[google code](<a href="https://baike.baidu.com/item/google">https://baike.baidu.com/item/google</a> code/2346604)，并且改名为MyBatis</li>
<li>2013年11月迁移到<a href="https://baike.baidu.com/item/Github/10145341">Github</a></li>
</ul>
<p>如何获得MyBatis？</p>
<ul>
<li>
<p>maven仓库</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Gtihub：<a href="https://guthub.com/mybatis/mybatis-3/releases">https://guthub.com/mybatis/mybatis-3/releases</a></p>
</li>
<li>
<p>中文文档：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p>
</li>
</ul>
<h2 id="1-2、持久化">1.2、持久化</h2>
<p>数据持久化</p>
<ul>
<li>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</li>
<li>内存：断电即失</li>
<li>数据库（JDBC），io文件持久化</li>
</ul>
<p><strong>为什么需要持久化？</strong></p>
<ul>
<li>有一些对象，不能让他丢掉</li>
<li>内存太贵了</li>
</ul>
<h2 id="1-3、持久层">1.3、持久层</h2>
<p>Dao层，Service层，Controller层…</p>
<ul>
<li>完成持久化工作的代码块</li>
<li>层界限十分明显</li>
</ul>
<h2 id="1-4、为什么需要MyBatis？">1.4、为什么需要MyBatis？</h2>
<ul>
<li>
<p>帮助程序员将数据存入到数据库中</p>
</li>
<li>
<p>方便</p>
</li>
<li>
<p>传统的JDBC代码太复杂。简化，框架，自动化</p>
</li>
<li>
<p>不用MyBatis也可以，更容易上手。技术没有高低之分</p>
</li>
<li>
<p>优点：</p>
<ul>
<li>简单易学</li>
<li>灵活</li>
<li>sql和代码的分离，提高了可维护性</li>
<li>提供映射标签，支持对象与数据库的orm字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组键维护</li>
<li>提供xml标签，支持编写动态sql</li>
</ul>
</li>
</ul>
<p><strong>最重要的一点：使用的人多！</strong></p>
<p>Spring  SpringMVC  SpringBoot</p>
<h1>2、第一个MyBatis程序</h1>
<p>思路：搭建环境–&gt;导入MyBatis–&gt;编写代码–&gt;测试！</p>
<h2 id="2-1、搭建环境">2.1、搭建环境</h2>
<blockquote>
<p>搭建数据库</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis`;</span><br><span class="line"></span><br><span class="line">USE `mybatis`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`(</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`pwd` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`(`id`,`name`,`pwd`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>新建项目</p>
</blockquote>
<ol>
<li>创建一个普通Maven项目</li>
</ol>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210923151107169.png" alt="image-20210923151107169"></p>
<ol start="2">
<li>
<p>删除src目录</p>
</li>
<li>
<p>导入Maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    导入依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        mysql驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        MyBatis--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        junit--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-2、-创建一个模块">2.2、 创建一个模块</h2>
<ul>
<li>
<p>编写mybatis的核心配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--configuration核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>userUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编写mybatis工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用MyBatis第一步：获取SqlSessionFactory对象</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既然有了SqlSessionFactory，顾名思义，我们就可以从中获取SqlSession的实例了。</span></span><br><span class="line">    <span class="comment">// SqlSession完全包含了面向数据库执行SQL命令所需的所有方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-3、编写代码">2.3、编写代码</h2>
<ul>
<li>
<p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pwd=&#x27;&quot;</span> + pwd + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Dao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接口实现类</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.song.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--select查询语句--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.song.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-4、测试">2.4、测试</h2>
<ul>
<li>
<p>junit测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：获取SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一：getMapper</span></span><br><span class="line">    UserDao userDao = sqlSession.getMapper(UserDao.class);</span><br><span class="line">    List&lt;User&gt; userList = userDao.getUserList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭SQLSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>3、CRUD</h1>
<h2 id="3-1、案例">3.1、案例</h2>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210924203602755.png" alt="image-20210924203602755"></p>
<ol>
<li>
<p>UserMapper类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询全部用户</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据ID查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除有个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>UserMappe.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.song.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.song.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.song.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.song.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.song.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        update mybatis.user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete from mybatis.user where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：获取SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一：getMapper</span></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; userList = mapper.getUserList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二(了解即可，不推荐使用)：</span></span><br><span class="line">    <span class="comment">// List&lt;User&gt; userList = sqlSession.selectList(&quot;com.song.dao.UserDao.getUserList&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭SQLSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    User user = mapper.getUserById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增删改需要提交事务</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = mapper.addUser(<span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">&quot;哈哈哈&quot;</span>, <span class="string">&quot;123456&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;插入成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = mapper.updateUser(<span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">&quot;呵呵呵&quot;</span>, <span class="string">&quot;123123&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = mapper.deleteUser(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>**注意：**增删改需要提交事务</p>
<h2 id="3-2、万能Map">3.2、万能Map</h2>
<p>假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！</p>
<ol>
<li>
<p>UserMapper类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 万能的Map</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser2</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>UserMappe.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--对象中的属性，可以直接取出来， 传递map的key--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    insert into mybatis.user (id, name, pwd) values (#&#123;userId&#125;, #&#123;userName&#125;, #&#123;userPwd&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;userId&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;userPwd&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = mapper.addUser2(map);</span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;插入成功！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Map传递参数，直接在sql中取出可以即可！  【parameterType=“map”】</p>
<p>对象传递参数，直接在sql取对象的属性即可！  【parameterType=“Object”】</p>
<p>只有一个基本类型参数的情况下，可以直接在sql中取到！</p>
<h2 id="3-3、模糊查询">3.3、模糊查询</h2>
<p>两种方式</p>
<ol>
<li>
<p>java代码执行的时候，传递通配符%%</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; userList = mapper.getUserLike(<span class="string">&quot;%李%&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在sql拼接中使用通配符</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>4、配置解析</h1>
<h2 id="4-1、核心配置">4.1、核心配置</h2>
<ul>
<li>
<p>mybatis-config.xml</p>
</li>
<li>
<p>MyBatis的配置文件包含了会深深影响MyBatis行为的设置和属性信息。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">configuration（配置）</span><br><span class="line">properties（属性）</span><br><span class="line">settings（设置）</span><br><span class="line">typeAliases（类型别名）</span><br><span class="line">typeHandlers（类型处理器）</span><br><span class="line">objectFactory（对象工厂）</span><br><span class="line">plugins（插件）</span><br><span class="line">environments（环境配置）</span><br><span class="line">environment（环境变量）</span><br><span class="line">transactionManager（事务管理器）</span><br><span class="line">dataSource（数据源）</span><br><span class="line">databaseIdProvider（数据库厂商标识）</span><br><span class="line">mappers（映射器）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-2、环境配置-environments">4.2、环境配置(environments)</h2>
<p>MyBatis可以配置成适应多种环境</p>
<p>不过要记住：尽管可以配置多个环境，但每个SQLSessionFactory实例只能选择一种环境。</p>
<p>学会使用配置多套运行环境！</p>
<p>MyBatis默认的事务管理器就是JDBC，连接池：POOLED</p>
<h2 id="4-3、属性-properties">4.3、属性(properties)</h2>
<p>我们可以通过properties属性来实现引用配置文件</p>
<p>这些属性都是可外部配置且可动态替换的，既可以在典型的java属性文件中配置，亦可通过properties元素的子元素来传递。【db.properties】</p>
<ol>
<li>
<p>编写配置文件</p>
<p>db.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8</span><br><span class="line">username=root</span><br><span class="line">password=970125</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在核心配置文件中引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入外部配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  <span class="comment">&lt;!--可以在这里写也可以在配置文件中写属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以直接引入外部文件</li>
<li>可以在其中增加一些属性配置</li>
<li>如果两个文件有同一个字段，优先使用外部配置文件的</li>
</ul>
</li>
</ol>
<h2 id="4-4、类型别名-typeAliases">4.4、类型别名(typeAliases)</h2>
<ul>
<li>类型别名是为java类型设置一个短的名字</li>
<li>存在的意义仅在于减少类完全限定名的冗余</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以给实体类起别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.song.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以指定一个包名，MyBatis会在包名下面搜索需要的JavaBean，比如：</p>
<p>扫描实体类的包，它默认别名就为这个类的类名，首写字小写！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.song.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在实体类比较少的时候，使用第一种方式。</p>
<p>如果实体类十分多，建议使用第二种。</p>
<p>第一种可以DIY别名，第二种则不行，如果非要改，需要在实体上增加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">User</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-5、设置">4.5、设置</h2>
<p>这是MyBatis中极为重要的调整设置，它们会改变MyBatis的运动行为。</p>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210925192517945.png" alt="image-20210925192517945"></p>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210925192553587.png" alt="image-20210925192553587"></p>
<h2 id="4-6、其他配置">4.6、其他配置</h2>
<ul>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins（插件）
<ul>
<li>mybatis-generator-core</li>
<li>mybatis-plus</li>
<li>通用Mapper</li>
</ul>
</li>
</ul>
<h2 id="4-7、映射器（mappers）">4.7、映射器（mappers）</h2>
<p>MapperRegistry：注册绑定我们的Mapper文件；</p>
<p>方式一：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册!--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/song/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>方式二：使用class文件绑定注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册!--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.song.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li>接口和它的Mapper配置文件必须同名！</li>
<li>接口和它的Mapper配置文件必须在同一个包下！</li>
</ul>
<p>方式三：使用扫描包进行注入绑定</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册!--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.song.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li>接口和它的Mapper配置文件必须同名！</li>
<li>接口和它的Mapper配置文件必须在同一个包下！</li>
</ul>
<h2 id="4-8、生命周期和作用域">4.8、生命周期和作用域</h2>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210925195433000.png" alt="image-20210925195433000"></p>
<p>生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong></p>
<p><strong>SqlSeesionFactoryBuilder:</strong></p>
<ul>
<li>一旦创建了SQLSessionFactoryBuilder，就不再需要它了</li>
<li>局部变量</li>
</ul>
<p><strong>SqlSeesionFactory</strong>：</p>
<ul>
<li>说白了就是可以想象为：数据库连接池</li>
<li>SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例</li>
<li>因此SQLSessionFactory的最佳作用域是应用作用域</li>
<li>最简单的就是使用单例模式或者静态单例模式</li>
</ul>
<p>SQLSession：</p>
<ul>
<li>连接到连接池的一个请求</li>
<li>SQLSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳作用域是请求或方法作用域</li>
<li>用完之后需要赶紧关闭，否则资源被占用</li>
</ul>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210925200356716.png" alt="image-20210925200356716"></p>
<p>这里面的每一个Mapper，就代表一个具体的业务。</p>
<h1>5、解决属性名和字段名不一致的问题</h1>
<h2 id="5-1、问题描述">5.1、问题描述</h2>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210925200524018.png" alt="image-20210925200524018"></p>
<p>新建一个项目，拷贝之前的，测试实体类字段不一致的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试出现问题：</p>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210925204845955.png" alt="image-20210925204845955"></p>
<p>password为null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mybatis.user <span class="keyword">where</span> id <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line"><span class="keyword">select</span> id,name,pwd <span class="keyword">from</span> mybatis.user <span class="keyword">where</span> id <span class="operator">=</span> #&#123;id&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<ul>
<li>起别名</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.song.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select id,name,pwd as password from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-2、resultMap">5.2、resultMap</h2>
<p>结果集映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id  name  pwd</span><br><span class="line">id  name  password</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--colum数据库中的字段，property实体类中的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>resultMap元素是MyBatis中最重要最强大的元素</li>
<li>ResultMap的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了</li>
<li>ResultMap最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到它们。</li>
</ul>
<h1>6、日志</h1>
<h2 id="6-1、日志工厂">6.1、日志工厂</h2>
<p>如果一个数据库操作，出现了异常，我们需要排错，日志就是最好的助手！</p>
<p>以前我们使用输出语句和debug</p>
<p>现在：日志工厂！</p>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210925192517945.png" alt="image-20210925192517945"></p>
<ul>
<li>SLF4J</li>
<li>LOG4J 【掌握】</li>
<li>LOG4J2</li>
<li>JDK_LOGGING</li>
<li>COMMONS_LOGGING</li>
<li>STDOUT_LOGGING</li>
<li>NO_LOGGING</li>
</ul>
<p>在Mybatis中具体使用哪个日志实现，在设置中设定！</p>
<p>STDOUT_LOGGING标准日志输出</p>
<p>在mybatis核心配置文件中，配置日志</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210925214529436.png" alt="image-20210925214529436"></p>
<h2 id="6-2、LOG4J">6.2、LOG4J</h2>
<p>什么是LOG4J？</p>
<ul>
<li>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI">GUI</a>组件</li>
<li>我们也可以控制每一条日志的输出格式</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程</li>
<li>通过一个<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码</li>
</ul>
<ol>
<li>先导入LOG4J的包</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>log4j.properties</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG,console,file</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#控制台输出的相关设置</span></span><br><span class="line"><span class="meta">log4j.appender.console</span> = <span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.Target</span> = <span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.console.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">【%c】-%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#文件输出的相关设置</span></span><br><span class="line"><span class="meta">log4j.appender.file</span> = <span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.file.File</span>=<span class="string">./log/kuang.log</span></span><br><span class="line"><span class="meta">log4j.appender.file.MaxFileSize</span>=<span class="string">10mb</span></span><br><span class="line"><span class="meta">log4j.appender.file.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="string">【%p】【%d&#123;yy-MM-dd&#125;】【%c】%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#日志输出级别</span></span><br><span class="line"><span class="meta">log4j.logger.org.mybatis</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.Statement</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.ResultSet</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>配置log4j为日志的实现</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>LOG4J的使用，直接测试运行</li>
</ol>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210925220750821.png" alt="image-20210925220750821"></p>
<p><strong>简单使用</strong></p>
<ol>
<li>在使用log4j的类中，导入包</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>日志对象，参数为当前类的class</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Logger logger = Logger.getLogger(UserDaoTest.class);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>日志级别</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.info(<span class="string">&quot;info:进入了testLog4j&quot;</span>);</span><br><span class="line">logger.debug(<span class="string">&quot;debug:进入了testLog4j&quot;</span>);</span><br><span class="line">logger.error(<span class="string">&quot;error:进入了testLog4j&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1>7、分页</h1>
<p><strong>思考</strong>：<strong>为什么要分页</strong></p>
<ul>
<li>减少数据的处理量</li>
</ul>
<h2 id="7-1、使用Limit分页">7.1、使用Limit分页</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit startIndex,pagesize;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">4</span>;  #[<span class="number">0</span>,n]</span><br></pre></td></tr></table></figure>
<p>使用MyBatis实现分页，核心SQL</p>
<ol>
<li>接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分页</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByLimit</span><span class="params">(Map&lt;String, Integer&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Mapper.xml</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--分页--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLimit&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;startIndex&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    map.put(<span class="string">&quot;pageSize&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = mapper.getUserByLimit(map);</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-2、RowBounds分页">7.2、RowBounds分页</h2>
<p>不再使用SQL实现分页</p>
<ol>
<li>接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分页2</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByRowBounds</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>mapper.xml</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--分页2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByRowBounds&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.user;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByRowBounds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RowBounds实现</span></span><br><span class="line">    RowBounds rowBounds = <span class="keyword">new</span> RowBounds(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过java代码层面实现分页</span></span><br><span class="line">    List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;com.song.dao.UserMapper.getUserByRowBounds&quot;</span>, <span class="keyword">null</span>, rowBounds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-3、分页插件">7.3、分页插件</h2>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210926222629205.png" alt="image-20210926222629205"></p>
<p><a href="https://pagehelper.github.io/">https://pagehelper.github.io/</a></p>
<p>了解即可！</p>
<h1>8、注解开发</h1>
<h2 id="8-1、面向接口编程">8.1、面向接口编程</h2>
<ul>
<li>大家之前都学过面向对象编程，也学过接口，但在真正的开发中，很多时候我们会选择面向接口编程</li>
<li>**根本原因：**解耦 ，可扩展，提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发得容易，规范性更好</li>
<li>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的，在这种情况下，各个对象内部是如何自己的，对系统设计人员来讲就不那么重要了</li>
<li>而各个对象之间的协作关系则成为系统设计的关键，小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</li>
</ul>
<p><strong>关于接口的理解</strong></p>
<ul>
<li>接口从更深层次的理解，应是定义（规范，约束）与实现（各实分离的原则）的分离</li>
<li>接口的本身反映了系统设计人员对系统的抽象理解</li>
<li>接口应是两类
<ul>
<li>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)</li>
<li>第二类是对一个个体某一方面的抽象，即形成一个抽象面(interface)</li>
<li>一个体有可能有多个抽象面。抽象体与抽象面有区别的</li>
</ul>
</li>
</ul>
<p><strong>三个面向区别</strong></p>
<ul>
<li>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法</li>
<li>面向过程是指，我们考虑问题时，一一个具体的流程（事务过程）为单位，考虑它的实现</li>
<li>接口设计与非接口设计是针对复用技术而言，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构</li>
</ul>
<h2 id="8-2、使用注解开发">8.2、使用注解开发</h2>
<ol>
<li>注解在接口上实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>需要在核心配置文件中绑定接口</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--绑定接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.song.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>测试</li>
</ol>
<p>本质：反射机制实现</p>
<p>底层：动态代理！</p>
<p><strong>MyBatis详细执行流程！</strong></p>
<p><img src="/mybatis-base/C:%5CUsers%5C86158%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210927205903005.png" alt="image-20210927205903005"></p>
<h2 id="8-3、CRUD">8.3、CRUD</h2>
<p>我们可以在工具类创建的时候实现自动提交事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写接口，增加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法存在多个参数，所有的参数前面必须加上@Param(&quot;&quot;)</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">User <span class="title">getUserByID</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert(&quot;insert into user(id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@Param(&quot;uid&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步：获取SqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 底层主要应用反射</span></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; userList = mapper.getUsers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭SQLSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByID</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步：获取SqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 底层主要应用反射</span></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User userByID = mapper.getUserByID(<span class="number">1</span>);</span><br><span class="line">        System.out.println(userByID);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭SQLSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步：获取SqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 底层主要应用反射</span></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        mapper.addUser(<span class="keyword">new</span> User(<span class="number">5</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;123123&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭SQLSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步：获取SqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 底层主要应用反射</span></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        mapper.updateUser(<span class="keyword">new</span> User(<span class="number">5</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="string">&quot;123123&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭SQLSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步：获取SqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 底层主要应用反射</span></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        mapper.deleteUser(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭SQLSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>【注意】必须要将接口注册绑定到我们的核心配置文件中！</p>
<p><strong>关于@Param()注解</strong></p>
<ul>
<li>基本类型的参数或者String类型，需要加上</li>
<li>引用类型不需要加</li>
<li>如果只有一个基本类型的话，可以忽略。但是建议加上</li>
<li>我们在SQL中引用的就是我们这里@Param()中设定的属性名</li>
</ul>
<h1>9、Lombok</h1>
<blockquote>
<p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>
Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p>
</blockquote>
<p>优缺点都有，方便但代码可读性差，争议大，了解即可，尽量不要用。</p>
<p>使用步骤：</p>
<ol>
<li>
<p>在IDEA中安装Lombok插件！</p>
</li>
<li>
<p>在项目中导入Lombok的jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter and @Setter</span><br><span class="line">@FieldNameConstants</span><br><span class="line">@ToString</span><br><span class="line">@EqualsAndHashCode</span><br><span class="line">@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor</span><br><span class="line">@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog</span><br><span class="line">@Data</span><br><span class="line">@Builder</span><br><span class="line">@SuperBuilder</span><br><span class="line">@Singular</span><br><span class="line">@Delegate</span><br><span class="line">@Value</span><br><span class="line">@Accessors</span><br><span class="line">@Wither</span><br><span class="line">@With</span><br><span class="line">@SneakyThrows</span><br><span class="line">@val</span><br><span class="line">@var</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data：无参构造，get，set，toString，hashcode，equals</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br></pre></td></tr></table></figure>
<h1>10、多对一处理</h1>
<p>数据库的一对多和多对一处理。</p>
<p>数据库创建：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> teacher(`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;秦老师&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`tid` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">	KEY `fktid` (`tid`),</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> `fktid` <span class="keyword">FOREIGN</span> KEY (`tid`) <span class="keyword">REFERENCES</span> `teacher` (`id`)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;小张&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;小李&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;小王&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="10-1、测试环境搭建">10.1、测试环境搭建</h2>
<ol>
<li>导入Lombok</li>
<li>新建实体类Teacher，Student</li>
<li>建立Mapper</li>
<li>建立Mapper.xml文件</li>
<li>在核心配置文件中绑定注册我们的Mapper接口或者文件</li>
<li>测试查询是否能够成功</li>
</ol>
<h2 id="10-2、按照查询嵌套处理">10.2、按照查询嵌套处理</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.song.dao.StudentMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	select s.id,s.name,t.name from student s, teacher t where s.tid = t.id;</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1、查询所有学生信息</span></span><br><span class="line"><span class="comment">        2、根据查询出来的学生的tid，寻找对应的老师</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.student;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.teacher where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="10-3、按照结果嵌套处理">10.3、按照结果嵌套处理</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--=========================按照结果嵌套处理============================--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher2&quot;</span>&gt;</span></span><br><span class="line">    select s.id sid,s.name sname,t.name tname</span><br><span class="line">    from mybatis.student s, mybatis.teacher t</span><br><span class="line">    where s.tid = t.id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">column</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1>11、一对多处理</h1>
<p>回顾MySQL多对一查询方式：</p>
<ul>
<li>子查询</li>
<li>联表查询</li>
</ul>
<h2 id="环境搭建">环境搭建</h2>
<p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个老师拥有多个学生</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按照结果嵌套处理">按照结果嵌套处理</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent&quot;</span>&gt;</span></span><br><span class="line">        select s.id sid, s.name sname, t.name tname, t.id tid</span><br><span class="line">        from mybatis.student s, mybatis.teacher t</span><br><span class="line">        where s.tid = t.id and t.id = #&#123;tid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="按照查询嵌套处理">按照查询嵌套处理</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent2&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.teacher where id = #&#123;tid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.student where tid = #&#123;tid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>1.关联 - association  【多对一】</p>
<p>2.集合 - collection   【一对多】</p>
<p>3.javaType   &amp;   ofType</p>
<p>​	1.JavaType用来指定实体类中属性的类型</p>
<p>​	2.ofType用来指定映射到List或者集合中的pojo类型，泛型中的约束类型！</p>
<p>注意点：</p>
<ul>
<li>保证SQL的可读性，尽量保证通俗易懂</li>
<li>注意一对多和多对一中，属性名和字段的问题</li>
<li>如果问题不好排查错误，可以使用日志，建议使用Log4j</li>
</ul>
<h1>12、动态SQL</h1>
<p>什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句</p>
<p>利用动态SQL这一特性可以彻底摆脱这种痛苦。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</span><br><span class="line"></span><br><span class="line">if</span><br><span class="line">choose (when, otherwise)</span><br><span class="line">trim (where, set)</span><br><span class="line">foreach</span><br></pre></td></tr></table></figure>
<h2 id="搭建环境">搭建环境</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `blog` (</span><br><span class="line">	`id` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;博客id&#x27;</span>,</span><br><span class="line">    `title` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;博客标题&#x27;</span>,</span><br><span class="line">    `author` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;博客作者&#x27;</span>,</span><br><span class="line">    `create_time` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `views` <span class="type">INT</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;浏览量&#x27;</span></span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>
<p>创建一个基础工程</p>
<ol>
<li>
<p>导包</p>
</li>
<li>
<p>编写配置文件</p>
</li>
<li>
<p>编写实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> views;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编写实体类对应Mapper接口和Mapper.XML文件</p>
</li>
</ol>
<h2 id="IF">IF</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogIF&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.blog</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">                title = #&#123;title&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">                and author = #&#123;author&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="choose-when-otherwise">choose(when, otherwise)</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogChoose&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.blog</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">                    title = #&#123;title&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">                    and title = #&#123;author&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                    and views = #&#123;views&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="trim-where-set">trim(where, set)</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        update mybatis.blog</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">                title = #&#123;title&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">                author = #&#123;author&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="sql片段">sql片段</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以实现代码复用    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;if-title-author&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">            title = #&#123;title&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">            and author = #&#123;author&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogIF&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.blog</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;if-title-author&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>最好基于单表来定义sql片段</li>
<li>不要存在where标签</li>
</ul>
<h1>13、缓存</h1>
<h2 id="Mybatis缓存">Mybatis缓存</h2>
<ul>
<li>
<p>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。</p>
</li>
<li>
<p>MyBatis系统中默认定义了两级缓存:一级缓存和二级缓存</p>
<ul>
<li>
<p>默认情况下，只有一级缓存开启。(SqlSession级别的缓存，也称为本地缓存)。</p>
</li>
<li>
<p>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</p>
</li>
<li>
<p>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</p>
</li>
</ul>
</li>
</ul>
<h2 id="一级缓存">一级缓存</h2>
<ul>
<li>一级缓存也叫本地缓存
<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库</li>
</ul>
</li>
</ul>
<p><strong>测试步骤：</strong></p>
<ol>
<li>
<p>开启日志</p>
</li>
<li>
<p>测试在一个Session中查询两次相同的记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user = mapper.queryUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line">        User user2 = mapper.queryUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user == user2);</span><br><span class="line"></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/mybatis-base/D:%5CLearning%5CPersonalBlog%5CCodeChenBlog%5Csource_posts%5Cmybatis-base%5CSnipaste_2022-03-13_16-49-28.jpg" alt></p>
</li>
</ol>
<p>缓存失效的情况：</p>
<ul>
<li>
<p>增删改操作，可能会改变原来的数据，所以必定会刷新缓存</p>
</li>
<li>
<p>查询不同的东西</p>
</li>
<li>
<p>查询不同的Mapper.xml</p>
</li>
<li>
<p>手动清理缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sqlSession.clearCache();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>小结：一级缓存默认是开启的，只在一次SQLSession中有效，也就是拿到连接到关闭这个区间段。</p>
<p>一级缓存就是一个Map</p>
<h2 id="二级缓存">二级缓存</h2>
<ul>
<li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</li>
<li>基于namespace级别的缓存，一个名称空间，对应一个二级缓存</li>
<li>工作机制
<ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存全没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容；</li>
<li>不同的Mapper查出的数据会放在自己对应的缓存（map）中；</li>
</ul>
</li>
</ul>
<p>步骤：</p>
<ol>
<li>
<p>开启全局缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        显示的开启全局缓存--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在要使用的二级缓存的Mapper开启</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    在当前Mapper.xml中使用二级缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以自定义参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--    在当前Mapper.xml中使用二级缓存--&gt;</span><br><span class="line">    &lt;cache eviction=&quot;FIFO&quot;</span><br><span class="line">           flushInterval=&quot;60000&quot;</span><br><span class="line">           size=&quot;512&quot;</span><br><span class="line">           readOnly=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>测试</p>
<p>问题：我们需要将实体类序列化！否则就会报错</p>
</li>
</ol>
<p>小结：</p>
<ul>
<li>只要开启了二级缓存，在同一个Mapper下就有效</li>
<li>所有的数据都会先放在一级缓存中</li>
<li>只有当会话提交，或者关闭的时候，才会提交到二级缓存中</li>
</ul>
<h2 id="自定义缓存Ehcache">自定义缓存Ehcache</h2>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>-java</tag>
      </tags>
  </entry>
  <entry>
    <title>python垃圾回收机制</title>
    <url>/python-gc/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>python采用的是<strong>引用计数</strong>机制为主，<strong>标记-清除</strong>和<strong>分代收集（隔代回收）</strong>两种机制为辅的策略。</p>
<h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><blockquote>
<p>引用计数法机制的原理是：每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，也有很多语言比如Java并没有采用该算法做来垃圾的收集机制。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">typedef struct_object &#123;</span><br><span class="line">     <span class="built_in">int</span> ob_refcnt;</span><br><span class="line">     struct_typeobject *ob_type;</span><br><span class="line">&#125;PyObject;</span><br></pre></td></tr></table></figure>

<p>在Python中每一个对象的核心就是一个结构体PyObject，它的内部有一个引用计数器（ob_refcnt）。程序在运行的过程中会实时的更新ob_refcnt的值，来反映引用当前对象的名称数量。当某对象的引用计数值为0,那么它的内存就会被立即释放掉。</p>
<p>以下情况是导致引用计数加一的情况:</p>
<ul>
<li>对象被创建，例如a=2</li>
<li>对象被引用，b=a</li>
<li>对象被作为参数，传入到一个函数中</li>
<li>对象作为一个元素，存储在容器中</li>
</ul>
<p>下面的情况则会导致引用计数减一:</p>
<ul>
<li>对象别名被显示销毁 del</li>
<li>对象别名被赋予新的对象</li>
<li>一个对象离开他的作用域</li>
<li>对象所在的容器被销毁或者是从容器中删除对象</li>
</ul>
<p>我们还可以通过sys包中的getrefcount()来获取一个名称所引用的对象当前的引用计数(注意，这里getrefcount()本身会使得引用计数加一)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure>



<p><strong>引用计数机制的优点：</strong></p>
<p>1、高效、实现逻辑简单</p>
<p>2、具备实时性：一旦没有引用，内存就直接释放了，不用像其他机制得等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。</p>
<p><strong>引用计数机制的缺点：</strong></p>
<p>1、在一些场景下，可能会比较慢。正常来说垃圾回收会比较平稳运行，但是当需要释放一个大的对象时，比如字典，需要对引用的所有对象循环嵌套调用，从而可能会花费比较长的时间。</p>
<p>2、循环引用。这将是引用计数的致命伤，引用计数对此是无解的，因此必须要使用其它的垃圾回收算法对其进行补充。</p>
<p>3、逻辑简单，但实现有些麻烦。每个对象需要分配单独的空间来统计引用计数，这无形中加大的空间的负担，并且需要对引用计数进行维护，在维护的时候很容易会出错。</p>
<h1 id="标记清除解决循环引用"><a href="#标记清除解决循环引用" class="headerlink" title="标记清除解决循环引用"></a>标记清除解决循环引用</h1><p>Python采用了**“标记-清除”(Mark and Sweep)**算法，解决容器对象可能产生的循环引用问题。(注意，只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列)</p>
<p>跟其名称一样，该算法在进行垃圾回收时分成了两步，分别是：</p>
<ul>
<li>A）标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达；</li>
<li>B）清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。</li>
</ul>
<p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\python-gc\mark-sweep.svg"></p>
<p>在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在python中维护了一个refchain的双向环状链表，这个链表中存储程序创建的所有对象，每种类型的对象中都有一个ob_refcnt引用计数器的值，引用个数+1、-1，最后当引用计数器变为0时会进行垃圾回收（对象销毁、refchain中移除）</p>
<p>但是，在python中对于那些可以有多个元素组成的对象可能存在循环引用的问题，为了解决这个问题python又引入了标记清除和分代回收，在其内部维护4个链表。</p>
<ul>
<li>refchain</li>
<li>2代</li>
<li>1代</li>
<li>0代</li>
</ul>
<p>在源码内部当达到各自的阈值时，就会触发扫描链表进行标记清除的动作（有循环各自-1）</p>
<p>但是，源码内部在上述的流程中提出了优化机制</p>
<h1 id="python缓存"><a href="#python缓存" class="headerlink" title="python缓存"></a>python缓存</h1><h2 id="池"><a href="#池" class="headerlink" title="池"></a>池</h2><p>为了避免重复创建和销毁一些常见对象，维护池</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动解释器时，python内部帮我们创建：-5、-4......257</span></span><br><span class="line">v1 = <span class="number">7</span>   <span class="comment"># 内部不会开辟内存，直接去池中获取</span></span><br><span class="line">v2 = <span class="number">9</span>   <span class="comment"># 内部不会开辟内存，直接去池中获取</span></span><br><span class="line">v3 = <span class="number">9</span>   <span class="comment"># 内部不会开辟内存，直接去池中获取</span></span><br><span class="line"></span><br><span class="line">v4 = <span class="number">999</span></span><br><span class="line">v5 = <span class="number">999</span></span><br><span class="line">v6 = <span class="number">999</span></span><br><span class="line">超过范围的会创建额外内存</span><br></pre></td></tr></table></figure>



<h2 id="free-list"><a href="#free-list" class="headerlink" title="free_list"></a>free_list</h2><p>当一个对象的引用计数器为0时，按理说应该回收，内部不会直接回收，而是将对象添加到free_list链表中当缓存。以后再创建对象时，不再重新开辟内存，而是直接使用free_list。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v1 = <span class="number">3.14</span>    <span class="comment"># 开辟内存，内部存储结构体中定义那几个值，并存到refchain中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> v1       <span class="comment"># refchain中移除，将对象添加到free_list中。</span></span><br><span class="line"></span><br><span class="line">V9 = <span class="number">999.9</span>   <span class="comment"># 不会重新开辟内存，去free_list中获取对象，对象内部数初始化，再放到refchain中。</span></span><br></pre></td></tr></table></figure>

































<p>原文链接：<a href="https://blog.csdn.net/xiongchengluo1129/article/details/80462651">https://blog.csdn.net/xiongchengluo1129/article/details/80462651</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python迭代器</title>
    <url>/python-iteration/</url>
    <content><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代器类型的定义：</span></span><br><span class="line">	<span class="number">1.</span>当类中定义了__iter__和__next__两个方法</span><br><span class="line">    <span class="number">2.</span>__iter__方法需要返回对象本身，即：self</span><br><span class="line">    <span class="number">3.</span>__next__方法，返回下一个数据，如果没有数据了，则需要抛出一个StopIteration的异常</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 创建迭代器类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IT</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.counter = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.counter == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.counter</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 根据类实例化创建一个迭代器对象：</span></span><br><span class="line">obj1 = IT()</span><br><span class="line"></span><br><span class="line"><span class="comment"># v1 = obj1.__next__()</span></span><br><span class="line"><span class="comment"># v2 = obj1.__next__()</span></span><br><span class="line"><span class="comment"># v3 = obj1.__next__() # 抛出异常</span></span><br><span class="line"></span><br><span class="line">v1 = <span class="built_in">next</span>(obj1)   <span class="comment"># obj.__next__()</span></span><br><span class="line"><span class="built_in">print</span>(v1)</span><br><span class="line"></span><br><span class="line">v2 = <span class="built_in">next</span>(obj1)</span><br><span class="line"><span class="built_in">print</span>(v2)</span><br><span class="line"></span><br><span class="line">v3 = <span class="built_in">next</span>(obj1)</span><br><span class="line"><span class="built_in">print</span>(v3)</span><br><span class="line"></span><br><span class="line">obj2 = IT()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> obj2:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 迭代器对象支持通过next取值，如果取值结束则自动抛出StopIteration。</span></span><br><span class="line"><span class="comment"># for循环内部在循环时，先执行__iter__方法，获取一个迭代器对象，然后不断执行的next取值（有异常StopIteration则终止循环）</span></span><br></pre></td></tr></table></figure>



<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建生成器对象（内部时根据生产器类generator创建的对象），生成器类的内部也声明了：__iter__、__next__方法。</span></span><br><span class="line">obj1 = func()</span><br><span class="line"></span><br><span class="line">v1 = <span class="built_in">next</span>(obj1)</span><br><span class="line"><span class="built_in">print</span>(v1)</span><br><span class="line"></span><br><span class="line">v2 = <span class="built_in">next</span>(obj2)</span><br><span class="line"><span class="built_in">print</span>(v2)</span><br><span class="line"></span><br><span class="line">v3 = <span class="built_in">next</span>(obj3)</span><br><span class="line"><span class="built_in">print</span>(v3)</span><br><span class="line"></span><br><span class="line">obj2 = func()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> obj2:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 如果按照迭代器的规定来看，其实生成器类也是一种特殊的迭代器类（生成器也是一个特殊的迭代器）</span></span><br></pre></td></tr></table></figure>



<h1 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果一个类中有__iter__方法且返回一个迭代器对象；则我们称以这个类创建的对象为可迭代对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> 迭代器对象(生成器对象)</span><br><span class="line">    </span><br><span class="line">obj = Foo()   <span class="comment"># obj是可迭代对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可迭代对象是可以使用for循环来进行循环，在循环内部其实是先执行__iter__方法，获取其迭代器对象，然后再在内部执行这个迭代器对象的next功能，逐步取值。</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>regular-expression-base</title>
    <url>/regular-expression-base/</url>
    <content><![CDATA[<h1>限定符</h1>
<p>**?：**表示某个字符需要出现0次或1次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">used?   # 这样就可以匹配use和used</span><br></pre></td></tr></table></figure>
<p>***：**表示某个字符可以出现0次或多次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ab*c</span><br><span class="line">ac</span><br><span class="line">abc</span><br><span class="line">abbbbc</span><br></pre></td></tr></table></figure>
<p>**+：**表示某个字符需要出现1次以上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ab+c</span><br><span class="line">abc</span><br><span class="line">abbbbbc</span><br></pre></td></tr></table></figure>
<p>{…}：指定出现次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ab&#123;2,6&#125;c</span><br><span class="line">abbc</span><br><span class="line">abbbc</span><br><span class="line">abbbbc</span><br><span class="line">abbbbbc</span><br><span class="line">abbbbbbc</span><br></pre></td></tr></table></figure>
<p>()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># (ab)+</span><br><span class="line">ab</span><br><span class="line">abab</span><br><span class="line">ababab</span><br></pre></td></tr></table></figure>
<h1>或运算符</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># a (cat|dog)</span><br><span class="line">a cat</span><br><span class="line">a dog</span><br></pre></td></tr></table></figure>
<h1>字符类</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># [abc]+</span><br><span class="line">abc</span><br><span class="line">aabbcc</span><br><span class="line"></span><br><span class="line"># [a-zA-Z]+</span><br><span class="line">abc</span><br><span class="line">tiger</span><br><span class="line">ABCD</span><br><span class="line"></span><br><span class="line"># [^0-9]   表示非数字字符</span><br><span class="line">abc</span><br><span class="line">aabbcc</span><br><span class="line">adfdg</span><br></pre></td></tr></table></figure>
<h1>元字符</h1>
<p>\d：表示数字字符</p>
<p>\w：表示单词字符（英文、数字以及下划线）</p>
<p>\s：空白符（包含Tab和换行符）</p>
<p>\D：非数字字符</p>
<p>\W：非单词字符</p>
<p>\S：非空白字符</p>
<p>.：包含任意字符，除了换行符</p>
<p>^：匹配行首</p>
<p>$：匹配行尾</p>
<h1>贪婪和慵懒</h1>
<h1>总结</h1>
<p><img src="/regular-expression-base/D:%5CLearning%5CPersonalBlog%5CCodeChenBlog%5Csource_posts%5Cregular-expression-base%5CSnipaste_2022-04-08_22-36-23.jpg" alt></p>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>zabbix</title>
    <url>/zabbix-base/</url>
    <content><![CDATA[<blockquote>
<p>监控服务的作用：</p>
<ul>
<li>当出现一些突发情况，及时响应</li>
<li>及时捕捉证据，追溯相关问题</li>
</ul>
</blockquote>
<h1 id="监控系统性能指标的命令"><a href="#监控系统性能指标的命令" class="headerlink" title="监控系统性能指标的命令"></a>监控系统性能指标的命令</h1><p>性能指标：</p>
<ul>
<li><p>CPU性能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line">htop</span><br><span class="line">uptime</span><br><span class="line">vmstat</span><br></pre></td></tr></table></figure></li>
<li><p>内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free</span><br></pre></td></tr></table></figure></li>
<li><p>磁盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iotop</span><br><span class="line">df</span><br></pre></td></tr></table></figure></li>
<li><p>网络/进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iftop</span><br><span class="line">ps</span><br><span class="line">pstree</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="企业常见监控工具"><a href="#企业常见监控工具" class="headerlink" title="企业常见监控工具"></a>企业常见监控工具</h1><p>catti：擅长出图，添加监控项很繁琐</p>
<p>nagios：可以添加监控项，但是不可以图形化</p>
<p>ganglia：分布式集群监控系统，适合于对上千台大型规模集群进行监控，性能成本比较低，批量管理更加方便。不可以发送告警。</p>
<p>zabbix：集合了上述的优点</p>
<p>promethus：适合于监控k8s</p>
<p>ELK：日志监控</p>
<h1 id="zabbix相关介绍"><a href="#zabbix相关介绍" class="headerlink" title="zabbix相关介绍"></a>zabbix相关介绍</h1><p>Zabbix 是由 Alexei Vladishev 创建，目前是由 Zabbix SIA 在持续开发和提供支持。</p>
<p>Zabbix 是一种企业级的分布式开源监控解决方案。</p>
<p>Zabbix 是一款能够监控众多网络参数和服务器的健康度和完整性的软件。Zabbix 使用灵活的通知机制，允许用户为几乎任何事件配置基于邮件的警报。这样可以快速相应服务器问题。Zabbix 基于存储的数据提供出色的报告和数据可视化。这些功能使得 Zabbix 成为容量规划的理想选择。</p>
<p>Zabbix 支持轮询和被动捕获。所有的 Zabbix 报告、统计信息和配置参数都可以通过基于 Web 的前端页面进行访问。基于 Web 的前端页面确保您的网络状态和服务器健康状况可以从任何地方进行评估。在经过适当的配置后，Zabbix 可以在监控 IT 基础设施方面发挥重要作用。无论是对于拥有少量服务器的小型组织，还是拥有大量服务器的大型公司而言，同样适用。</p>
<p>Zabbix 是免费的。Zabbix 是根据 GPL 通用公共许可证的第二版编写和分发的。这意味着它的源代码是免费分发的，并且可供公共使用。</p>
<h1 id="zabbix监控服务架构模型"><a href="#zabbix监控服务架构模型" class="headerlink" title="zabbix监控服务架构模型"></a>zabbix监控服务架构模型</h1><p><img src="/C:/Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220310152622084.png" alt="image-20220310152622084"></p>
<p>snmp：zabbix监控网络性能所依赖协议</p>
<p>IPMI：用于监控物理硬件性能指标，可以获取物理设备的温度、CPU转速</p>
<p>JMX：监控Java项目所使用的出口。</p>
<h1 id="安装部署zabbix监控架构"><a href="#安装部署zabbix监控架构" class="headerlink" title="安装部署zabbix监控架构"></a>安装部署zabbix监控架构</h1><p>部署环境：</p>
<p>系统：centos7</p>
<p>web应用：Nginx</p>
<p>php 72</p>
<p>mariadb</p>
<p>安装部署服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置源</span><br><span class="line">rpm -Uvh https://repo.zabbix.com/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm</span><br><span class="line"># 安装服务端与客户端</span><br><span class="line">yum install zabbix-server-mysql zabbix-agent</span><br><span class="line">yum install centos-release-scl -y</span><br></pre></td></tr></table></figure>

<p>单独配置前端源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装依赖</span><br><span class="line">修改 /etc/yum.repos.d/zabbix.repo</span><br><span class="line">[zabbix-fronted]</span><br><span class="line">enable=1</span><br><span class="line"></span><br><span class="line">安装前端包</span><br><span class="line">yum install zabbix-web-mysql-scl zabbix-nginx-conf-scl -y</span><br></pre></td></tr></table></figure>



<h1 id="准备数据库环境"><a href="#准备数据库环境" class="headerlink" title="准备数据库环境"></a>准备数据库环境</h1><p>安装数据库MySQL或mariadb</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install mariadb-server -y</span><br><span class="line">systemctl start mariadb.service</span><br></pre></td></tr></table></figure>

<p>创建zabbix业务库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database zabbix character set utf8 collate utf8_bin;</span><br></pre></td></tr></table></figure>

<p>授权zabbix用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all on zabbix.* to zabbix@localhost identified by &#x27;zabbix&#x27;;</span><br></pre></td></tr></table></figure>

<p>导入数据库数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zcat /usr/share/doc/zabbix-server-mysql-5.0.21/create.sql.gz &gt; zabbix.sql</span><br><span class="line">在zabbix.sql首行添加use zabbix;</span><br><span class="line">mysql -uzabbix -pzabbix &lt;zabbix.sql</span><br></pre></td></tr></table></figure>



<h1 id="配置服务端环境"><a href="#配置服务端环境" class="headerlink" title="配置服务端环境"></a>配置服务端环境</h1><p>配置zabbix_server连接数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/zabbix/zabbix_server.conf</span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPasswd=zabbix</span><br></pre></td></tr></table></figure>

<p>配置Nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/opt/rh/rh-nginx116/nginx/conf.d/zabbix.conf</span><br><span class="line">server_name ip;</span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">vim /etc/opt/rh/rh-nginx116/nginx/nginx.conf</span><br><span class="line">将server块注释掉</span><br></pre></td></tr></table></figure>



<p>配置php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/opt/rh/rh-php72/php-fpm.d/zabbix.conf</span><br><span class="line">listen.acl_users = apache,nginx</span><br><span class="line">php_value[date.timezone] = Asia/Shanghai</span><br><span class="line"></span><br><span class="line">vim /etc/opt/rh/rh-php72/php.ini</span><br><span class="line">date.timezone =Asia/Shanghai</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">getenforce</span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line">vim /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br><span class="line"></span><br><span class="line">systemctl start zabbix-server.service rh-php72-php-fpm.service rh-nginx116-nginx.service</span><br></pre></td></tr></table></figure>

<p>在浏览其访问当前部署机器的IP地址即可开始网页安装部署zabbix</p>
<h1 id="zabbix-agent2"><a href="#zabbix-agent2" class="headerlink" title="zabbix-agent2"></a>zabbix-agent2</h1><p>zabbix-agent2 作为一款新的agent，未来可能会替代原有的agent。</p>
<p>特性：</p>
<ul>
<li>降低了TCP连接的数据</li>
<li>zabbix-agent2用go语言开发的，集成了zabbix-agent原有的所有功能，并且易于通过插件扩展第三方功能。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置源</span><br><span class="line">rpm -Uvh https://repo.zabbix.com/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm</span><br><span class="line"># 安装</span><br><span class="line">yum install zabbix-agent2 -y</span><br></pre></td></tr></table></figure>



<h1 id="zabbix实战应用讲解"><a href="#zabbix实战应用讲解" class="headerlink" title="zabbix实战应用讲解"></a>zabbix实战应用讲解</h1><p>web界面介绍：</p>
<p>主机–&gt;监控项–&gt;模板–&gt;触发器–&gt;执行动作–&gt;告警媒介</p>
<h2 id="添加主机"><a href="#添加主机" class="headerlink" title="添加主机"></a>添加主机</h2><p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/zabbix/zabbix_agent2.conf</span><br><span class="line">修改 Server=服务端的ip</span><br><span class="line"></span><br><span class="line">[root@node1 ~]# getenforce</span><br><span class="line">Enforcing</span><br><span class="line">[root@node1 ~]# setenforce 0</span><br><span class="line">[root@node1 ~]# vim /etc/selinux/config </span><br><span class="line">SELINUX=disabled</span><br><span class="line"></span><br><span class="line">systemctl start zabbix-agent2.service</span><br></pre></td></tr></table></figure>

<p>服务端</p>
<p>模板选择Linux第一个</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-03-11_16-23-37.jpg"></p>
<h2 id="添加监控项"><a href="#添加监控项" class="headerlink" title="添加监控项"></a>添加监控项</h2><p>客户端自定义监控取值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.通过shell命令获取到关键数据</span><br><span class="line">2.将命令与key名配置文件中定义好</span><br><span class="line">3.服务端通过zabbix-get命令测试获取键值对</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 取当前用户连接数</span></span><br><span class="line">[root@node1 ~]# w</span><br><span class="line"> 15:39:59 up 34 min,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/0    192.168.31.33    15:05    7.00s  0.02s  0.00s w</span><br><span class="line">[root@node1 ~]# w | awk &#x27;&#123;print $5&#125;&#x27;</span><br><span class="line">1</span><br><span class="line">IDLE</span><br><span class="line">6.00s</span><br><span class="line">[root@node1 ~]# w | awk &#x27;NR==1&#123;print $5&#125;&#x27;</span><br><span class="line">1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将命令放入zabbix配置文件中</span></span><br><span class="line">[root@node1 zabbix]# vim /etc/zabbix/zabbix_agent2.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> UserParameter=</span></span><br><span class="line">UserParameter=User_num,w | awk &#x27;NR==1&#123;print $5&#125;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">[root@node1 zabbix]# systemctl restart zabbix-agent2</span><br></pre></td></tr></table></figure>

<p>去服务端测试一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@control ~]# yum install zabbix-get</span><br><span class="line">[root@control ~]# zabbix_get -s 192.168.31.145 -k User_num</span><br><span class="line">1</span><br></pre></td></tr></table></figure>





<p>服务端</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-03-11_21-07-03.jpg"></p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-03-11_21-08-47.jpg" alt="Snipaste_2022-03-11_21-08-47"></p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-01_15-56-28.jpg"></p>
<p>企业案例：通过zabbix监控nginx的服务运行状态</p>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>监控项：用于监控数据</p>
<p>触发器：对性能指标异常的数据进行报警</p>
<p>触发器配置界面</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_14-35-21.jpg"></p>
<p>示例：</p>
<p>在触发器和监控项中有修改主机名会提示</p>
<p>修改node1的主机名后就出现了提示信息</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_14-40-54.jpg"></p>
<h2 id="添加触发器"><a href="#添加触发器" class="headerlink" title="添加触发器"></a>添加触发器</h2><p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_14-50-05.jpg"></p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_14-47-13.jpg"></p>
<p>添加几个连接后就会触发报警</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_14-52-10.jpg"></p>
<p>在恢复项也可以设置恢复的触发</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_14-58-51.jpg"></p>
<p>减少用户连接后就可以恢复</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_15-00-14.jpg"></p>
<p>异常用户触发器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# w | awk &#x27;NR&gt;2&#123;print $3&#125;&#x27; | uniq -c</span><br><span class="line">      1 192.168.31.33</span><br><span class="line">[root@node1 ~]# w | awk &#x27;NR&gt;2&#123;print $3&#125;&#x27; | uniq -c | wc -l</span><br><span class="line">1</span><br><span class="line">[root@node1 ~]# w | awk &#x27;NR&gt;2&#123;print $3&#125;&#x27; | sort -r | uniq -c | wc -l</span><br><span class="line">1</span><br></pre></td></tr></table></figure>



<h1 id="邮件提示设置"><a href="#邮件提示设置" class="headerlink" title="邮件提示设置"></a>邮件提示设置</h1><p>配置发件人：</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_15-38-20.jpg"></p>
<p>这里的密码是邮箱授权码</p>
<p>配置收件人：</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_15-41-24.jpg"></p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_15-42-08.jpg" alt="Snipaste_2022-04-02_15-42-08"></p>
<p>配置动作</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_15-44-10.jpg"></p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_15-45-01.jpg" alt="Snipaste_2022-04-02_15-45-01"></p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_15-45-15.jpg" alt="Snipaste_2022-04-02_15-45-15"></p>
<p>之后就会触发动作发邮件</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_15-52-18.jpg" alt="Snipaste_2022-04-02_15-52-18"></p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zabbix-base\Snipaste_2022-04-02_15-52-03.jpg"></p>
<h1 id="zabbix通过percona对mysql进行监控"><a href="#zabbix通过percona对mysql进行监控" class="headerlink" title="zabbix通过percona对mysql进行监控"></a>zabbix通过percona对mysql进行监控</h1><p>percona：专门应用于针对数据库进行自动化维护的工具</p>
<p>通过zabbix监控mysql步骤：</p>
<p><strong>准备服务端</strong></p>
<p>下载percona插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://www.percona.com/downloads/percona-monitoring-plugins/percona-monitoring-plugins-1.1.8/binary/redhat/6/x86_64/percona-zabbix-templates-1.1.8-1.noarch.rpm</span><br><span class="line"></span><br><span class="line">[root@control home]# yum localinstall percona-zabbix-templates-1.1.8-1.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>文件结构介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@control home]# rpm -ql percona-zabbix-templates</span><br><span class="line">/var/lib/zabbix/percona</span><br><span class="line">/var/lib/zabbix/percona/scripts                                       # 插件脚本存放位置</span><br><span class="line">/var/lib/zabbix/percona/scripts/get_mysql_stats_wrapper.sh            # shell脚本，用于针对监控数据进行取值</span><br><span class="line">/var/lib/zabbix/percona/scripts/ss_get_mysql_stats.php                # php脚本，真正获取mysql数据库数据的脚本</span><br><span class="line">/var/lib/zabbix/percona/templates</span><br><span class="line">/var/lib/zabbix/percona/templates/userparameter_percona_mysql.conf    # zabbix-agent客户端监控项配置文件</span><br><span class="line">/var/lib/zabbix/percona/templates/zabbix_agent_template_percona_mysql_server_ht_2.0.9-sver1.1.8.xml</span><br><span class="line">                                                                      # 模板（监控项+触发器+自动发现+图像化展示等）</span><br></pre></td></tr></table></figure>

<p><strong>准备服务端</strong></p>
<p>下载percona插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://www.percona.com/downloads/percona-monitoring-plugins/percona-monitoring-plugins-1.1.8/binary/redhat/6/x86_64/percona-zabbix-templates-1.1.8-1.noarch.rpm</span><br><span class="line"></span><br><span class="line">[root@control home]# yum localinstall percona-zabbix-templates-1.1.8-1.noarch.rpm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要求php7以上，默认安装是5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/lib/zabbix/percona/templates/</span><br><span class="line"></span><br><span class="line">[root@node1 templates]# cp -a userparameter_percona_mysql.conf /etc/zabbix/zabbix_agent2.d/</span><br><span class="line"></span><br><span class="line">[root@node1 templates]# systemctl restart zabbix-agent2.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@node1 templates]# zabbix_agent2 -t MySQL.Questions</span><br><span class="line">MySQL.Questions                               [s|]</span><br></pre></td></tr></table></figure>



<h1 id="SNMP协议监控网络设备及固件"><a href="#SNMP协议监控网络设备及固件" class="headerlink" title="SNMP协议监控网络设备及固件"></a>SNMP协议监控网络设备及固件</h1><p>作用：snmp协议主要针对于无法使用zabbix客户端监控的设备对象，对于zabbix监控起到补充作用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">路由器</span><br><span class="line">交换机</span><br><span class="line">打印机</span><br><span class="line">UPS</span><br><span class="line">支持SNMP协议，snmp服务器配置，交互上zabbix服务端</span><br></pre></td></tr></table></figure>

<p>版本管理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. SNMPv1:最初版本，容易实现操作成本低，海量数据的读取能力比较薄弱，没有合理安全机制</span><br><span class="line">2.SNMPv2c:目前大部分网络设备厂商主要支持的协议，增加了GetBulk和inform操作</span><br><span class="line">3.SNMPV3:安全比较高，环境适应性好，易扩展</span><br></pre></td></tr></table></figure>



<h1 id="zabbix实现自动化监控"><a href="#zabbix实现自动化监控" class="headerlink" title="zabbix实现自动化监控"></a>zabbix实现自动化监控</h1>]]></content>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>shell入门</title>
    <url>/shell-base/</url>
    <content><![CDATA[<h1>简介</h1>
<p><strong>shell脚本</strong></p>
<p>日常运维工作大部分是一些繁琐的重复的工作，每天80%的工作就是重复干昨天的事情，而且工作量还比较大，这就可以让机器操作这些工作。</p>
<p>一个简单脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装Nginx的脚本</span></span><br><span class="line">vim install_nginx.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 内容如下</span></span><br><span class="line">yum -y install wget gcc pcre-devel zlib-devel</span><br><span class="line">wget http://nginx.org/download/nginx-1.16.0.tar.gz</span><br><span class="line">tar xf nginx-1.16.0.tar.gz</span><br><span class="line">cd nginx-1.16.0</span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行</span></span><br><span class="line">chmod 700 install_nginx.sh</span><br><span class="line">./install_nginx.sh</span><br></pre></td></tr></table></figure>
<h2 id="脚本规范">脚本规范</h2>
<ul>
<li>
<p>不要写中文，就算注释也最好不要中文</p>
</li>
<li>
<p>#代表注释，#!不是注释，是表示运行的环境</p>
</li>
<li>
<p>脚本最好标明作者、创建时间、描述</p>
</li>
<li>
<p>脚本组成</p>
<ul>
<li>解释环境 #！/usr/bin/env bash|python|perl</li>
<li>注释说明</li>
<li>执行代码</li>
</ul>
</li>
</ul>
<blockquote>
<p>运行脚本：</p>
<ul>
<li>给执行权限chmod 700 install_nginx.sh，然后./install_nginx.sh</li>
<li>解释器直接运行，不需要给权限，直接bash install_nginx.sh</li>
</ul>
</blockquote>
<h1>shell语法</h1>
<h2 id="shell中的特殊符号">shell中的特殊符号</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~:          家目录  # cd ~代表进入用户家目录</span><br><span class="line">!:          执行历史命令!!执行上一条命令</span><br><span class="line"><span class="meta">$</span><span class="bash">:          变量中取内容符</span></span><br><span class="line">+ - * 、 %:  对应数学运算加减乘除取余数</span><br><span class="line">&amp;:          后台执行</span><br><span class="line">*:          星号是shel1中的通配符匹配所有</span><br><span class="line">?:          问号是shell中的通配符―匹配除回车以外的一个字符</span><br><span class="line">;:          分号可以在shell中一行执行多个命令，命令之间用分号分割</span><br><span class="line">|:          管道符上一个命令的输出作为下一个命令的输入cat filename l grep &quot;abc&quot;</span><br><span class="line">\:          转义字符</span><br><span class="line">``:         反引号 命令中执行命令 echo &quot;today is `date +%F`&quot;</span><br><span class="line">&#x27; &#x27;:        单引号，脚本中字符串要用单引号引起来，但是不同于双引号的是，单引号不解释变量</span><br><span class="line">&quot; &quot;:        双引号，脚本中出现的字符串可以用双引号引起来</span><br></pre></td></tr></table></figure>
<h2 id="管道">管道</h2>
<p>| 管道符在shell中使用时最多的，很多组合命令都需要通过组合命令来完成输出。管道符其实就是下一个命令对上一个命令的输出做处理</p>
<h2 id="shell重定向">shell重定向</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">     重定向输入 覆盖原数据</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;    重定向追加输入，在原数据的末尾添加</span></span><br><span class="line">&lt;     重定向输出 wc -l &lt; /etc/passwd</span><br><span class="line">&lt;&lt;    重定向追加输出 fdisk /dev/sdb &lt;&lt;EOF ...... EOF</span><br></pre></td></tr></table></figure>
<h2 id="shell数学运算">shell数学运算</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expr命令：只能做整数运算，格式比较古板，注意空格</span><br><span class="line">[root@VM-24-12-centos ~]# expr 1 + 1</span><br><span class="line">2</span><br><span class="line">[root@VM-24-12-centos ~]# expr 5 - 1</span><br><span class="line">4</span><br><span class="line">[root@VM-24-12-centos ~]# expr 5 \* 2  # 注意*出现应该转义，否则认为是通配符</span><br><span class="line">10</span><br><span class="line">[root@VM-24-12-centos ~]# expr 5 / 2</span><br><span class="line">2</span><br><span class="line">[root@VM-24-12-centos ~]# expr 5 % 2</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">使用bc计算器处理浮点运算，scale=2代表小数点保留两位</span><br><span class="line">[root@VM-24-12-centos ~]# echo &quot;scale=2;3+100&quot;|bc</span><br><span class="line">103</span><br><span class="line">[root@VM-24-12-centos ~]# echo &quot;scale=2;100-3&quot;|bc</span><br><span class="line">97</span><br><span class="line">[root@VM-24-12-centos ~]# echo &quot;scale=2;100/3&quot;|bc</span><br><span class="line">33.33</span><br><span class="line">[root@VM-24-12-centos ~]# echo &quot;scale=2;100*3&quot;|bc</span><br><span class="line">300</span><br></pre></td></tr></table></figure>
<p><strong>或者使用bc程序交互计算</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos ~]# bc</span><br><span class="line">bc 1.06.95</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details type `warranty&#x27;. </span><br><span class="line">1+1</span><br><span class="line">2</span><br><span class="line">10-2</span><br><span class="line">8</span><br><span class="line">3*5</span><br><span class="line">15</span><br><span class="line">15/2</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">scale=2</span><br><span class="line">100/3</span><br><span class="line">33.33</span><br></pre></td></tr></table></figure>
<p>脚本方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos ~]# echo &quot;scale=2;141*100/7966&quot;|bc</span><br><span class="line">1.77</span><br><span class="line">[root@VM-24-12-centos ~]# echo &quot;`echo &quot;scale=2;141*100/7966&quot;|bc`%&quot;</span><br><span class="line">1.77%</span><br><span class="line">[root@VM-24-12-centos ~]# echo &quot;当前内存使用率：`echo &quot;scale=2;141*100/7966&quot;|bc`%&quot;</span><br><span class="line">当前内存使用率：1.77%</span><br></pre></td></tr></table></figure>
<p>双小圆括号运算，在shell中(())也可以用来做数学运算</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos ~]# echo $((100+3))</span><br><span class="line">103</span><br><span class="line">[root@VM-24-12-centos ~]# echo $((100-3))</span><br><span class="line">97</span><br><span class="line">[root@VM-24-12-centos ~]# echo $((100/3))</span><br><span class="line">33</span><br><span class="line">[root@VM-24-12-centos ~]# echo $((100%3))</span><br><span class="line">1</span><br><span class="line">[root@VM-24-12-centos ~]# echo $((100**3))</span><br><span class="line">1000000</span><br></pre></td></tr></table></figure>
<h2 id="格式化输出echo">格式化输出echo</h2>
<p>echo</p>
<h2 id="shell基本输入">shell基本输入</h2>
<p>read命令</p>
<h2 id="变量">变量</h2>
<blockquote>
<p>在编程中，我们总有一些数据需要临时存放在内存，以待后续使用时快速读出。内存在系统启动的时候被按照1B一个单位划分为若干个块，然后统一编号(16进制编号)，并对内存的使用情况做记录，保存在内存跟踪表中。</p>
</blockquote>
<p><strong>变量分类：</strong></p>
<p>1.本地变量︰用户私有变量，只有本用户可以使用，保存在家目录下的.bash_profile、.bashrc文件中</p>
<p>2.全局变量:所有用户都可以使用，保存在/etc/profile、letc/bashrc文件中</p>
<p>3.用户自定义变量:用户自定义，比如脚本中的变量</p>
<p><strong>定义变量：</strong></p>
<p>变量格式：变量名=值</p>
<p>在shell编程中的变量名和等号之间不能有空格</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">变量名命名规则:</span><br><span class="line">	命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</span><br><span class="line">	中间不能有空格，可以使用下划线(_)。</span><br><span class="line">	不能使用标点符号。</span><br><span class="line">	不能使用bash里的关键字(可用help命令查看保留关键字)。</span><br></pre></td></tr></table></figure>
<p><strong>读取变量内容：</strong></p>
<p>读取变量内容符：$</p>
<p>读取方法：$变量名</p>
<p><strong>取消变量unset：</strong></p>
<p>unset name</p>
<p><strong>定义全局变量export：</strong></p>
<p>export name=‘codechen’</p>
<p>上述设置的变量其实都是一次性变量,系统重启就会丢失。</p>
<p>如果希望本地变量或者全局变量可以永久使用，可以将需要设置的变量写入变量文件中即可。</p>
<p><strong>定义永久变量：</strong></p>
<p>本地变量:用户私有变量，只有本用户可以使用，保存在家目录下的.bash_profile、.bashrc文件中</p>
<p>全局变量:所有用户都可以使用，保存在/etc/profile、letc/bashrc文件中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">本地变量</span><br><span class="line">[root@www ~]#tail -1 ~/.bash_profile</span><br><span class="line">name=&#x27;codechen&#x27;</span><br><span class="line"></span><br><span class="line">全局变量</span><br><span class="line">[root@www ~]# tail -1 /etc/profile</span><br><span class="line">export age=30</span><br></pre></td></tr></table></figure>
<h2 id="数组">数组</h2>
<p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">数组名称=(元素1 元素2 元素3 ...)</span><br></pre></td></tr></table></figure>
<p><strong>数组读出</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;数组名称[索引]&#125;</span></span><br><span class="line">索引默认是元素在数组中的排队编号，默认第一个从0开始</span><br></pre></td></tr></table></figure>
<p><strong>数组赋值</strong></p>
<p>方法一：一次赋一个值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array0[0]=&#x27;tom&#x27;</span><br><span class="line">array0[1]=&#x27;jerry&#x27;</span><br><span class="line">array0[2]=&#x27;marry&#x27;</span><br></pre></td></tr></table></figure>
<p>方法二：一次赋多个值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array2=(tom jack alice)</span><br><span class="line">array3=(`cat /etc/passwd`)   # 希望是将该文件中的每行作为一个元素赋值给数组array3</span><br><span class="line">array4=(`ls /var/ftp/Shell/for*`)</span><br><span class="line">array5=(tom jack alice &quot;bash shell&quot;)</span><br></pre></td></tr></table></figure>
<p><strong>查看数组</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">declare</span> -a</span></span><br><span class="line">declare -a array1=&#x27;([0]=&quot;pear&quot; [1]=&quot;apple&quot; [2]=&quot;orange&quot; [3]=&quot;peach&quot;)&#x27;</span><br><span class="line">declare -a array2=&#x27;([0]=&quot;pear&quot; [1]=&quot;jack&quot; [2]=&quot;alice&quot;)&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>访问数组元素</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;array1[0]&#125;       # 访问数组中的第一元素</span><br><span class="line">echo $&#123;array1[@]&#125;       # 访问数组中所有元素等同于echo $&#123;array1[*]&#125;</span><br><span class="line">echo $&#123;#array1[@]&#125;      # 统计数组元素的个数</span><br><span class="line">echo $&#123;!array1[@]&#125;      # 获取数组元素的索引</span><br><span class="line">echo $&#123;array1[@]:1&#125;     # 从数组小标1开始</span><br><span class="line">echo $&#123;#array1[@]:1:2&#125;  # 从数组小标1开始，访问两个元素</span><br></pre></td></tr></table></figure>
<p><strong>遍历数组</strong></p>
<ul>
<li>
<p>默认数组通过数组元素的个数进行遍历</p>
</li>
<li>
<p>针对关联数组可以通过数组元素的索引进行遍历</p>
</li>
</ul>
<h2 id="关联数组">关联数组</h2>
<p>关联数组可以允许用户自定义数组的索引，这样使用起来更加方便、高效</p>
<p><strong>定义关联数组</strong></p>
<p>申明关联数组变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare -A ass_array1</span><br><span class="line">declare -A ass_array2</span><br></pre></td></tr></table></figure>
<p><strong>关联数组赋值</strong></p>
<p>方法一：一次赋一个值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 数组名[索引]=变量值</span></span><br><span class="line">ass_array1[index1]=peer</span><br><span class="line">ass_array1[index2]=apple</span><br><span class="line">ass_array1[index3]=orange</span><br><span class="line">ass_array1[index4]=peach</span><br></pre></td></tr></table></figure>
<p>方法二：一次赋多个值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ass_array2=([index1]=tom [index2]=jack [index3]=alice [index4]=&#x27;bash shell&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>查看数组</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">declare</span> -A</span></span><br><span class="line">declare -A ass_array1=&#x27;([lindex4]=&quot;peach&quot; [index1]=&quot;pear&quot; [index2]=&quot;apple&quot; [index3]=&quot;orange&quot;)&quot;</span><br><span class="line">declare -A ass_array2=&#x27;([Iindex4]=&quot;bash shell&quot; [index1]=&quot;tom&quot; [index2]=&quot;jack&quot; [index3]=&quot;alice&quot;)&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>访问数组元素</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;ass_array2[index2]&#125;   # 访问数组中的第二个元数</span><br><span class="line">echo $&#123;ass_array2[@]&#125;        # 访问数组中所有元数等同于 echo $&#123;array1[*]&#125;</span><br><span class="line">echo $&#123;#ass_array2[@]&#125;       # 获得数组元数的个数</span><br><span class="line">echo $&#123;!ass_array2[@]&#125;       # 获得数组元数的索引</span><br></pre></td></tr></table></figure>
<p><strong>遍历数组</strong></p>
<p>通过数组元数的索引进行遍历,针对关联数组可以通过数组元素的索引进行遍历</p>
<h2 id="shell流程控制-if判断语句">shell流程控制-if判断语句</h2>
<p><strong>一、shell中的运算</strong></p>
<p><strong>数学比较运算</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-eq   # 等于</span><br><span class="line">-gt   # 大于</span><br><span class="line">-lt   # 小于</span><br><span class="line">-ge   # 大于或等于</span><br><span class="line">-le   # 小于或等于</span><br><span class="line">-ne   # 不等于</span><br></pre></td></tr></table></figure>
<p><strong>字符串比较运算</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运算符解释，注意字符串一定别忘了使用引号引起来</span></span><br><span class="line">==   # 等于</span><br><span class="line">!=   # 不等于</span><br><span class="line">-n   # 检查字符串的长度是否大于e</span><br><span class="line">-z   # 检查字符串的长度是否为e</span><br></pre></td></tr></table></figure>
<p><strong>文件比较检查</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-d   # 检查文件是否存在且为目录</span><br><span class="line">-e   # 检查文件是否存在</span><br><span class="line">-f   # 检查文件是否存在且为文件</span><br><span class="line">-r   # 检查文件是否存在且可读</span><br><span class="line">-s   # 检查文件是否存在且不为空</span><br><span class="line">-w   # 检查文件是否存在且可写</span><br><span class="line">-x   # 检查文件是否存在且可执行</span><br><span class="line">-o   # 检查文件是否存在并且被当前用户拥有</span><br><span class="line">-G   # 检查文件是否存在并且默认组为当前用户组</span><br><span class="line">file1 -nt file2   # 检查file1是否比file2新</span><br><span class="line">file1 -ot file2   # 检查file1是否比file2日</span><br></pre></td></tr></table></figure>
<p><strong>逻辑运算</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&amp;&amp;   # 逻辑与运算</span><br><span class="line">||   # 逻辑或运算</span><br><span class="line">！   # 逻辑非运算</span><br></pre></td></tr></table></figure>
<p><strong>赋值运算</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=   # 赋值运算符   a=10   name=&#x27;baism&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="if语句">if语句</h3>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一</span></span><br><span class="line">if [ condition ]</span><br><span class="line">	then</span><br><span class="line">		commands</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 二</span></span><br><span class="line">if [ condition ]</span><br><span class="line">	then</span><br><span class="line">		commands</span><br><span class="line">else</span><br><span class="line">		commands</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 三</span></span><br><span class="line">if [ condition ]</span><br><span class="line">	then</span><br><span class="line">		commands</span><br><span class="line">elif [ condition ]</span><br><span class="line">	then</span><br><span class="line">		commands</span><br><span class="line">else</span><br><span class="line">		commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="shell流程控制-for循环语句">shell流程控制-for循环语句</h2>
<p>语法一：直接赋值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for var in value1 value2 ......</span><br><span class="line">	do</span><br><span class="line">		commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>语法二：命令赋值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for var in `seq 1 9`</span><br></pre></td></tr></table></figure>
<p>语法三：赋值是一个字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for var in baism\&#x27;s is cool, baism\&#x27;s is nice</span><br><span class="line">	do</span><br><span class="line">		echo &quot;word: $var&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="循环控制语句">循环控制语句</h2>
<p><strong>sleep N脚本执行到该步休眠N秒</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -n&quot;倒计时: &quot;</span><br><span class="line">for i in &#x27;seq 9 -1 1`</span><br><span class="line">	do</span><br><span class="line">		echo -n -e &quot; \b$i&quot;</span><br><span class="line">		sleep 1</span><br><span class="line">done</span><br><span class="line">echo</span><br></pre></td></tr></table></figure>
<p><strong>continue跳过循环中的某次循环</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((i=1;i&lt;10;i++))</span><br><span class="line">	do</span><br><span class="line">		if [ $i -eq 5 ]</span><br><span class="line">			then</span><br><span class="line">				continue</span><br><span class="line">		else</span><br><span class="line">				echo $i</span><br><span class="line">		fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p><strong>break跳出循环继续执行后续代码</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in &#x27;seq 1 9`</span><br><span class="line">	do</span><br><span class="line">		echo $i</span><br><span class="line">		if [ $i -eq 5 ]</span><br><span class="line">			then</span><br><span class="line">				break</span><br><span class="line">		fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h1>案例分享–学员信息系统</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for ((i=0;i&lt;3;i++))</span><br><span class="line">        do</span><br><span class="line">                read -p &quot;输入第$((i + 1))个人名：&quot; name[$i]</span><br><span class="line">                read -p &quot;输入第$[$i + 1]个年龄：&quot; age[$i]</span><br><span class="line">                read -p &quot;输入第`expr $i + 1`个性别：&quot; gender[$i]</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">clear</span><br><span class="line">        echo -e &quot;\t\t\t\t学员查询系统&quot;</span><br><span class="line">while :</span><br><span class="line">        do</span><br><span class="line">                cp=0</span><br><span class="line">                read -p &quot;输入要查询的姓名：&quot; xm</span><br><span class="line">                [ $xm == &quot;Q&quot; ]&amp;&amp;exit</span><br><span class="line">                for ((i=0;i&lt;3;i++))</span><br><span class="line">                        do</span><br><span class="line">                                if [ &quot;$xm&quot; == &quot;$&#123;name[$i]&#125;&quot; ];then</span><br><span class="line">                                        echo &quot;$&#123;name[$i]&#125; $&#123;age[$i]&#125; $&#123;gender[$i]&#125;&quot;</span><br><span class="line">                                        cp=1</span><br><span class="line">                                fi</span><br><span class="line">                        done</span><br><span class="line"></span><br><span class="line">                        [ $cp -eq 0 ]&amp;&amp;echo &quot;not found student&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vue基础</title>
    <url>/vue-base/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper</title>
    <url>/zookeeper-base/</url>
    <content><![CDATA[<h1 id="一、zookeeper介绍"><a href="#一、zookeeper介绍" class="headerlink" title="一、zookeeper介绍"></a>一、zookeeper介绍</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>zookeeper是一种分布式协调服务，用于管理大型主机。在分布式环境中协调和管理服务是一个复杂的过程。zookeeper通过其简单的架构和API解决了这个问题。zookeeper允许开发人员专注于核心应用程序逻辑，而不必担心应用程序的分布式特性</li>
<li>ZooKeeper主要<strong>服务于分布式系统</strong>，可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。</li>
<li>使用分布式系统就无法避免对节点管理的问题(需要实时感知节点的状态、对节点进行统一管理等等)，而由于这些问题处理起来可能相对麻烦和提高了系统的复杂性，ZooKeeper作为一个能够<strong>通用</strong>解决这些问题的中间件就应运而生了。</li>
</ul>
<p>假设我们的程序是分布式部署在多台机器上，如果我们要改变程序的配置文件，需要逐台机器去修改，非常麻烦，现在把这些配置全部放到zookeeper上去，保存在 zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 zookeeper 的通知，然后从 zookeeper 获取新的配置信息应用到系统中。</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zookeeper-base\20180712143454552.png"></p>
<h2 id="zookeeper应用场景"><a href="#zookeeper应用场景" class="headerlink" title="zookeeper应用场景"></a>zookeeper应用场景</h2><ul>
<li>分布式协调组件</li>
</ul>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zookeeper-base\Snipaste_2022-03-15_15-22-01.jpg"></p>
<p>​    在分布式系统中，需要有zookeeper作为分布式协调组件，协调分布式系统中的状态。</p>
<ul>
<li><p>分布式锁</p>
<p>zk在实现分布式锁上，可以做到强一致性，关于分布式锁相关的知识，在之后的ZAB协议中介绍。</p>
</li>
<li><p>无状态化的实现</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zookeeper-base\Snipaste_2022-03-15_15-25-22.jpg"></p>
</li>
</ul>
<h1 id="二、搭建zookeeper服务器"><a href="#二、搭建zookeeper服务器" class="headerlink" title="二、搭建zookeeper服务器"></a>二、搭建zookeeper服务器</h1><h2 id="zoo-cfg配置文件说明"><a href="#zoo-cfg配置文件说明" class="headerlink" title="zoo.cfg配置文件说明"></a>zoo.cfg配置文件说明</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">zookeeper时间配置中的基李单位（毫秒)</span></span><br><span class="line">tickTime=200o</span><br><span class="line"><span class="meta">#</span><span class="bash">允许follower初始化连接到leader最大时长，它表示tickTime时间倍数即:initLimit*tickTime</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="meta">#</span><span class="bash">允许follower与leader数据同步最大时长,它表示tickTime时间倍数</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="meta">#</span><span class="bash">zookeper数据存储目录及日志保存目录〈如果没有指明dataLogDir，则日志也保存在这个文件中)</span></span><br><span class="line">dataDir=/tmp/zookeeper</span><br><span class="line"><span class="meta">#</span><span class="bash">对客户端提供的端口号</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta">#</span><span class="bash">单个客户端与zookeeper最大并发连接数</span></span><br><span class="line">maxClientcnxns=60</span><br><span class="line"><span class="meta">#</span><span class="bash">保存的数据快照数量,之外的将会被清除</span></span><br><span class="line">autopurge.snapRetainCount=3</span><br><span class="line"><span class="meta">#</span><span class="bash">自动触发清除任务时间间隔，小时为单位。默认为0，表示不自动清除。</span></span><br><span class="line">autopurge.purgeInterval=1</span><br></pre></td></tr></table></figure>



<h2 id="zookeeper服务器的操作命令"><a href="#zookeeper服务器的操作命令" class="headerlink" title="zookeeper服务器的操作命令"></a>zookeeper服务器的操作命令</h2><ul>
<li><p>重命名conf中的文件zoo_sample.cfg-&gt;zoo.cfg</p>
</li>
<li><p>启动zk服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/zkServer.sh start ./conf/zoo.cfh</span><br></pre></td></tr></table></figure></li>
<li><p>查看zk服务器状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/zkServer.sh status ./conf/zoo.cfh</span><br></pre></td></tr></table></figure></li>
<li><p>停止zk服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/zkServer.sh stop ./conf/zoo.cfh</span><br></pre></td></tr></table></figure></li>
</ul>
<p>启动服务端后就可以启动客户端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-12-centos bin]# ./zkCli.sh</span><br></pre></td></tr></table></figure>



<h1 id="三、zookeeper内部的数据模型"><a href="#三、zookeeper内部的数据模型" class="headerlink" title="三、zookeeper内部的数据模型"></a>三、zookeeper内部的数据模型</h1><h2 id="zk是如何保存数据的"><a href="#zk是如何保存数据的" class="headerlink" title="zk是如何保存数据的"></a>zk是如何保存数据的</h2><p>Zookeeper维护一个类似文件系统的数据结构：</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zookeeper-base\201807121434154.png"></p>
<p>每个子目录项如 NameService 都被称作为 znode(目录节点)，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。</p>
<p>zk中的数据是保存在节点上的，节点就是znode，多个znode之间构成一颗树的目录结构。</p>
<p>zookeeper的数据模型是什么样子呢？它很像数据结构当中的树，也很像文件系统的目录。</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zookeeper-base\Snipaste_2022-03-15_16-06-17.jpg"></p>
<p>树是由节点所组成，zookeeper的数据存储也同样是基于节点，这种节点叫做Znode</p>
<p>但是，不同于树的节点，Znode的引用方式是路径引用，类似于文件路径</p>
<p>这种层级结构，让每一个Znode节点拥有唯一的路径，就像命名空间一样对不同信息作出清晰的隔离。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] create /test1</span><br><span class="line">Created /test1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /</span><br><span class="line">[test1, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] create /test1</span><br><span class="line">Node already exists: /test1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] create /test1/sub1</span><br><span class="line">Created /test1/sub1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] ls /</span><br><span class="line">[test1, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] create test2 abc</span><br><span class="line">Path must start with / character</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] create /test2 abc</span><br><span class="line">Created /test2</span><br><span class="line">[zk: localhost:2181(CONNECTED) 8] get /test2</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>



<h2 id="zk中的znode是什么样的结构"><a href="#zk中的znode是什么样的结构" class="headerlink" title="zk中的znode是什么样的结构"></a>zk中的znode是什么样的结构</h2><p>zk中的znode，包含了四个部分：</p>
<ul>
<li>data：保存数据</li>
<li>acl：权限，定义了什么样的用户能够操作这个节点，且能够进行怎样的操作。<ul>
<li>c：create创建权限，允许在该节点下创建子节点</li>
<li>w：write更新权限，允许更新该节点的数据</li>
<li>r：read读取权限，允许读取节点的内容以及子节点的列表信息</li>
<li>d：delete删除权限，允许删除该节点的子节点</li>
<li>a：admin管理者权限。允许对该节点进行acl权限设置</li>
</ul>
</li>
<li>stat：描述当前znode的元数据</li>
<li>child：当前节点的子节点</li>
</ul>
<h2 id="zk中节点znode的类型"><a href="#zk中节点znode的类型" class="headerlink" title="zk中节点znode的类型"></a>zk中节点znode的类型</h2><ul>
<li><p>持久节点：创建出的节点，在会话结束后依然存在。保存数据。</p>
</li>
<li><p>持久序号节点：创建出的节点，根据先后顺序，会在节点之后带上一个数值，越后执行数值越大，适用于分布式锁的应用场景-单调递增</p>
</li>
<li><p>临时节点：</p>
<p>临时节点是在会话结束后，自动被删除的，通过这个特性，zk可以实现服务注册与发现的效果。</p>
<p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\zookeeper-base\Snipaste_2022-03-15_16-28-46.jpg"></p>
</li>
<li><p>临时序号节点：和持久序号节点相同，适用于临时的分布式锁</p>
</li>
<li><p>Container节点：Container容器节点，当容器中没有任何子节点，该容器节点会被zk定期删除（60s）</p>
</li>
<li><p>TTL节点：可以指定节点的到期时间，到期后被zk定时删除，只能通过系统配置zookeeper.extendedTypesEnabled=true开启</p>
</li>
</ul>
<h2 id="zk的数据持久化"><a href="#zk的数据持久化" class="headerlink" title="zk的数据持久化"></a>zk的数据持久化</h2><p>zk的数据是运行在内存中，zk提供了两种持久化机制:</p>
<ul>
<li><p>事务日志</p>
<p>zk把执行的命令以日志形式保存在dataLogDir指定的路径中的文件中〈如果没有指定dataLogDir，则按dataDir指定的路径)。</p>
</li>
<li><p>数据快照</p>
<p>zk会在一定的时间间隔内做一次内存数据的快照，把该时刻的内存数据保存在快照文件中。</p>
</li>
</ul>
<p>zk通过两种形式的持久化，在恢复时先恢复快照文件中的数据到内存中，再用日志文件中的数据做增量恢复，这样的恢复速度更快。</p>
<h1 id="四、zookeeper客户端（zkCli）的使用"><a href="#四、zookeeper客户端（zkCli）的使用" class="headerlink" title="四、zookeeper客户端（zkCli）的使用"></a>四、zookeeper客户端（zkCli）的使用</h1><h2 id="多节点类型创建"><a href="#多节点类型创建" class="headerlink" title="多节点类型创建"></a>多节点类型创建</h2><ul>
<li>创建持久节点</li>
<li>创建持久序号节点</li>
<li>创建临时节点</li>
<li>创建临时序号节点</li>
<li>创建容器节点</li>
</ul>
<h2 id="监听通知机制"><a href="#监听通知机制" class="headerlink" title="监听通知机制"></a>监听通知机制</h2><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。</p>
<h2 id="查询节点"><a href="#查询节点" class="headerlink" title="查询节点"></a>查询节点</h2><ul>
<li>普通查询</li>
<li>查询节点相关信息<ul>
<li>cZxid：创建节点的事物ID</li>
<li>mZxid：修改节点的事物ID</li>
<li>pZxid：添加和删除子节点的事物ID</li>
<li>ctime：节点创建的时间</li>
<li>mtime：节点最近修改的时间</li>
<li>dataVersion：节点内数据的版本，每更新一次数据，版本会+1</li>
<li>aclVersion：此节点的权限版本</li>
<li>ephemeralOwner：如果当前节点是临时节点，该值是当前节点所有者的session id。如果节点不是临时节点，则该值为零。</li>
<li>dataLength：节点内数据的长度</li>
<li>numChildren：该节点的子节点个数</li>
</ul>
</li>
</ul>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><ul>
<li>删除节点</li>
<li>乐观锁删除</li>
</ul>
<h2 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h2><ul>
<li><p>注册当前会话的账号和密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addauth digest 账号:密码</span><br></pre></td></tr></table></figure></li>
<li><p>创建节点并设置权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create /test-node abcd auth:账号:密码:cdwra</span><br></pre></td></tr></table></figure></li>
<li><p>在另一个会话中必须先使用密码账号，才能拥有操作该节点的权限</p>
</li>
</ul>
<h1 id="五、curator客户端的使用"><a href="#五、curator客户端的使用" class="headerlink" title="五、curator客户端的使用"></a>五、curator客户端的使用</h1><h2 id="curator介绍"><a href="#curator介绍" class="headerlink" title="curator介绍"></a>curator介绍</h2><p>Curator是Netflix公司开源的一套zookeeper客户端框架，Curator是对Zookeeper支持最好的客户端框架。Curator封装了大部分Zookeeper的功能，比如Leader选举、分布式锁等，减少了技术人员在使用Zookeeper时的底层细节开发工作。</p>
<h2 id="引入curator"><a href="#引入curator" class="headerlink" title="引入curator"></a>引入curator</h2><ul>
<li><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="六、zk实现分布式锁"><a href="#六、zk实现分布式锁" class="headerlink" title="六、zk实现分布式锁"></a>六、zk实现分布式锁</h1><h1 id="zk中锁的种类："><a href="#zk中锁的种类：" class="headerlink" title="zk中锁的种类："></a>zk中锁的种类：</h1><ul>
<li><p>读锁：大家都可以读，要想上读锁的前提︰之前的锁没有写锁</p>
</li>
<li><p>写锁：只有得到写锁的才能写。要想上写锁的前提是，之前没有任何锁。</p>
</li>
</ul>
<h2 id="zk如何上读锁"><a href="#zk如何上读锁" class="headerlink" title="zk如何上读锁"></a>zk如何上读锁</h2><ul>
<li><p>创建一个临时序号节点，节点的数据是read，表示是读锁获取当前zk中序号比自己小的所有节点</p>
</li>
<li><p>判断最小节点是否是读锁:</p>
<ul>
<li><p>如果不是读锁的话，则上锁失败，为最小节点设置监听。阻塞等待，zk的watch机制会当最小节点发生变化时通知当前节点，于是再执行第二步的流程</p>
</li>
<li><p>如果是读锁的话，则上锁成功</p>
</li>
</ul>
</li>
</ul>
<h2 id="zk如何上写锁"><a href="#zk如何上写锁" class="headerlink" title="zk如何上写锁"></a>zk如何上写锁</h2><ul>
<li>创建一个临时序号节点，节点的数据是write，表示是写锁</li>
<li>获取zk中所有的子节点</li>
<li>判断自己是否是最小的节点：<ul>
<li>如果是，则上写锁成功</li>
<li>如果不是，说明前面还有锁，则上锁失败，监听最小的节点，如果最小节点有变化，则回到第二步。</li>
</ul>
</li>
</ul>
<h2 id="羊群效应"><a href="#羊群效应" class="headerlink" title="羊群效应"></a>羊群效应</h2><p>如果用上述的上锁方式，只要有节点发生变化，就会触发其他节点的监听事件，这样的话对水k的压力非常大，——羊群效应。可以调整成链式监听。解决这个问题。</p>
]]></content>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>spring基础</title>
    <url>/spring-base/</url>
    <content><![CDATA[<h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul>
<li>spring是一个开源的免费的框架（容器）</li>
<li>spring是一个轻量级的、非入侵式的框架</li>
<li>控制反转（IOC），面向切面编程（AOP）</li>
<li>支持事物的处理，对框架整合的支持！</li>
</ul>
<p><strong>总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架</strong></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>LVS负载均衡</title>
    <url>/%E6%97%A0%E7%94%A8/LVS-base/</url>
    <content><![CDATA[<h1 id="集群和分布式"><a href="#集群和分布式" class="headerlink" title="集群和分布式"></a>集群和分布式</h1><blockquote>
<p><strong>集群：</strong>同一个业务系统，部署在多台服务器上。集群中，每一台服务器实现的功能没有差别，数据和代码都一样的</p>
<p><strong>分布式：</strong>一个业务被拆成多个子业务，或者本身就是不同的业务，部署到多台服务器上。分布式中，每一台服务器实现的功能是有差别的，数据和代码也是不一样的，分布式每台服务器功能加起来才是完整的业务。</p>
<p>分布式是以缩短单个任务的执行时间来提升效率的，而集群是通过提高单位时间内执行的任务数来提升效率。</p>
<p>对于大型网站，访问用户很多，实现一个集群，在前面部署一个负载均衡服务器，后面几台服务器完成同一业务。如果有用户进行相应业务访问时，负载均衡器根据后端哪台服务器的负载情况，决定由哪一台去完成响应，并且一台服务器垮了，其它的服务器可以顶上来。分布式的每一个节点，都完成不同的业务，如果一个节点垮了，那这个业务可能会失败。</p>
</blockquote>
<h1 id="Linux-Virtual-Server-LVS"><a href="#Linux-Virtual-Server-LVS" class="headerlink" title="Linux Virtual Server(LVS)"></a>Linux Virtual Server(LVS)</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h2 id="LVS集群体系架构"><a href="#LVS集群体系架构" class="headerlink" title="LVS集群体系架构"></a>LVS集群体系架构</h2><p><img src="/D:/Learning\PersonalBlog\CodeChenBlog\source_posts\LVS-base\Snipaste_2022-03-15_15-02-35.jpg"></p>
<h2 id="LVS功能及组织架构"><a href="#LVS功能及组织架构" class="headerlink" title="LVS功能及组织架构"></a>LVS功能及组织架构</h2><p>负载均衡的应用场景为高访问量的业务，提高应用程序的可用性和可靠性</p>
<h3 id="应用于高访问量的业务"><a href="#应用于高访问量的业务" class="headerlink" title="应用于高访问量的业务"></a>应用于高访问量的业务</h3><p>如果您的应用访问量很高，可以通过配置监听规则将流量分发到不同的云服务器ECS(Elastic Compute Service弹性计算服务）实例上。此外，可以使用会话保持功能将同一客户端的请求转发到同一台后端ECS</p>
<h2 id="扩展应用程序"><a href="#扩展应用程序" class="headerlink" title="扩展应用程序"></a>扩展应用程序</h2><p>可以根据业务发展的需要，随时添加和移除ECS实例来扩展应用系统的服务能力，适用于各种Web服务器和App服务器。</p>
<h2 id="消除单点故障"><a href="#消除单点故障" class="headerlink" title="消除单点故障"></a>消除单点故障</h2><p>可以在负载均衡实例下添加多台ECS实例。当其中一部分ECS实例发生故障后，负载均衡会自动屏蔽故障的ECS实例，将请求分发给正常运行的ECS实例，保证应用系统仍能正常工作</p>
<h2 id="同城容灾-多可用区容灾"><a href="#同城容灾-多可用区容灾" class="headerlink" title="同城容灾(多可用区容灾)"></a>同城容灾(多可用区容灾)</h2><p>为了提供更加稳定可靠的负载均衡服务，阿里云负载均衡已在各地域部署了多可用区以实现同地域容灾。当主可用区出现机房故障或不可用时，负载均衡仍然有能力在非常短的时间内(如:大约30s中断)切换到另外一个备可用区恢复服务能力;当主可用区恢复时，负载均衡同样会自动切换到主可用区提供服务。</p>
]]></content>
      <tags>
        <tag>LVS</tag>
      </tags>
  </entry>
</search>
